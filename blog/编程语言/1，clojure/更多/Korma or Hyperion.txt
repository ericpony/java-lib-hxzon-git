Korma or Hyperion?
MONDAY, JANUARY 27, 2014
https://hackworth.be/2014/01/27/korma-or-hyperion/

====
I've spent the past weekend getting to know both Korma and Hyperion to talk to SQL databases with Clojure. 
I'm using Luminus, 
（http://www.luminusweb.net/）
and when you use lein new luminus myapp +site 
（http://www.luminusweb.net/docs/profiles.md）
you get a handy webapp template with user authentication and database backing (via Korma) out of the box.

Of course, I wasted no time in making my Korma code rather complicated and messy 
before deciding there has to another way, so I tried my hand at Hyperion.

Hyperion is interesting in that it radically simplifies the database interface, 
and treats it almost completely as a key value store (ala Redis):

Hyperion provides you with a simple API for data persistence 
allowing you to delay the choice of database without delaying your development.

All Hyperion implementations, even for relational databases, 
conform to the simple key/value store API.
使用键值对存储的api 。

Values are maps. 
Every 'value' that goes in or out of a Hyperion datastore is a map. :key and :kind. 
Every 'value' must have a :kind entry; a short string like "user" or "product". 
Persisted 'value's will have a :key entry; strings generated by the datastore.  

The appeal of Hyperion is that it feels less SQL-y, and more Clojure-y. 
For instance, this is how you create and update a row in an "accounts" table in Hyperion:

(let [account (save {:kind :accounts :username "bob"})]
    ; renaming account username to 'charlie'
    (save (assoc account :username "charlie"))
    ; searching the datastore for the account by key
    ; this works with SQLite, MySQL, etc...
    (find-by-key (account :key))) 

In comparison, here's Korma:

(let [account (insert accounts (values {:username "bob"}))]
    ; renaming username to "charlie"
    (update accounts 
        (set-fields {:username "charlie"})
        (where {:id (account :id)}))
    ; finding 'charlie' row
    (first (select accounts 
        (where {:id (account :id)}) 
        (limit 1)))  

After spending time with both, I'm not sure which one I'll ultimately settle on.

One aspect that stood out to me with Hyperion is that it includes functions 
for before-save, before-create, after-create (look in hyperion.api), 
which are reminiscent of ActiveRecord callbacks. 
I haven't seen if this is included out of the box with Korma.

Hyperion also has created-at and updated-at timestamps out of the box. 
You can also define entities with specific callbacks for processing attributes.

The find-by-key function is intriguing, but I'm not sure how well it performs. 
In addition, your schema feels a bit messy when it comes to relationships. 
You start with account_id, but the recommended approach is to keep that, 
but Hyperion adds :account-key instead due to it's key-value store approach.

====
ASSOCIATIONS?
关联关系。

Whilst Korma feels to me a lot more SQL-y (and I'm not really a SQL guy), 
one aspect thats starting to appeal is how relationships are handled. 
In Ruby/ActiveRecord I can do something like Account.find(1).Posts.all 
to find all posts for the first user with ActiveRecords near-natural language query interface. 
Korma is not quite that close to ActiveRecord's Query Interface, but it isn't too bad. 
The Korma equivalent to above would be similar to:

(select accounts (with posts) (where {:id 1}))

The Hyperion example:

Uhh... anyone able to help me here?  

====
VALIDATIONS?
验证。

Neither library provides anything quite like Ruby/ActiveModel validations (though you can do some typing with Hyperion). 
What I've been using so far is Metis which is a Clojure library for validations, loosely based on ActiveModel.

The thing is though, that validations work best when paired with callbacks (ie, before-save, validate my data matches the rules). 
It's incredibly powerful being able to put one (defmethod before-save ...) to handle validations for your various entities. 
I am able to do that with Hyperion, but I am not sure yet how to do it with Korma (aside from writing it myself).

This wasn't intended to be too much of a detailed walkthrough, more to dump some of my thoughts while still fresh. 
It feels like I still need to do a lot more testing before settling on either Korma or Hyperion. 
I suspect a lot will hinge on whether I want easy callbacks or associations more.

If you have any tips for using Korma or Hyperion, please leave a comment below.

