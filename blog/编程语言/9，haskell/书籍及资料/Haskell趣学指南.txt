Haskell趣学指南
作者: [斯洛文尼亚] Miran Lipovaca
出版社: 人民邮电出版社
原作名: Learn You a Haskell for Great Good!
译者: 李亚舟 / 宋方睿 
出版年: 2014-1
页数: 301
装帧: 平装
丛书: 新锐编程语言集萃
ISBN: 9787115335593

=====
编辑推荐

动手实践书中想象力丰富、略有点儿疯狂的示例，你将能够：

挥舞纯函数式编程技法，笑看各种“副作用”。
施展Haskell的“惰性”魔法，处理无限数据集。
通过自定义类型、类型类和模块来组织程序。
使用Haskell优雅的输入/输出系统与外部世界分享程序的灵魂。
学习Haskell这门强大的语言，再没有比阅读这本书更好的方法了！

作者简介

作者介绍
Miran Lipovaca 斯洛文尼亚共和国卢布尔雅那城的一位计算机科学专业的学生。
除了对Haskell的狂热，他还喜欢拳击，玩低音吉他，当然还有画画。

译者介绍

李亚舟 
毕业于山东理工大学，现就职于IBM LTC，从事Linux发行版相关工作。
对内核、体系结构、编程语言及技术翻译有浓厚兴趣，敬仰那些孜孜不倦地精益求精的人们。

宋方睿 
本科生，清华大学开源镜像站维护者，blue-lotus战队成员，
热爱算法和程序设计语言理论，关注高性能计算、自然语言处理及前端技术。
个人博客http://maskray.me。

=====
目录

第1章 各就各位，预备！ 1 
第2章 相信类型 20 
第3章 函数的语法 30 
第4章 你好，递归 43 
第5章 高阶函数 50 

第6章 模块 73 

第7章 构造我们自己的类型和类型类 91 

第8章 输入与输出 128 
第9章 更多的输入输出操作 141 

第10章 函数式地解决问题 169 
第11章 applicative函子 182 

第12章 Monoid 205 
第13章 更多monad的例子 224 
第14章 再多一些monad 249 

第15章 zipper 287 

====
目录

第1章 各就各位，预备！ 1 

1.1 调用函数 3 
1.2 小朋友的第一个函数 4 
1.3 列表入门 6 
1.3.1 拼接列表 6 
1.3.2 访问列表中的元素 8 
1.3.3 嵌套列表 8 
1.3.4 比较列表 8 
1.3.5 更多列表操作 9 
1.4 得州区间 11 
1.5 我是列表推导式 13 
1.6 元组 16 
1.6.1 使用元组 16 
1.6.2 使用序对 17 
1.6.3 找直角三角形 18 

第2章 相信类型 20 

2.1 显式类型声明 20 
2.2 Haskell的常见类型 21 
2.3 类型变量 22 
2.4 类型类入门 23 
2.4.1 Eq类型类 24 
2.4.2 Ord类型类 24 
2.4.3 Show类型类 25 
2.4.4 Read类型类 25 
2.4.5 Enum类型类 27 
2.4.6 Bounded类型类 27 
2.4.7 Num类型类 28 
2.4.8 Floating类型类 28 
2.4.9 Integeral类型类 28 
2.4.10 有关类型类的最后总结 29 

第3章 函数的语法 30 

3.1 模式匹配 30 
3.1.1 元组的模式匹配 32 
3.1.2 列表与列表推导式的模式匹配 32 
3.1.3 As模式 34 
3.2 注意，哨卫！ 34 
3.3 where？！ 36 
3.3.1 where的作用域 37 
3.3.2 where中的模式匹配 38 
3.3.3 where块中的函数 38 
3.4 let 39 
3.4.1 列表推导式中的let 40 
3.4.2 GHCi中的let 40 
3.5 case表达式 41 

第4章 你好，递归 43 

4.1 不可思议的最大值 43 
4.2 更多的几个递归函数 45 
4.2.1 replicate 45 
4.2.2 take 45 
4.2.3 reverse 46 
4.2.4 repeat 46 
4.2.5 zip 46 
4.2.6 elem 47 
4.3 快点，排序！ 47 
4.3.1 算法思路 47 
4.3.2 编写代码 48 
4.4 递归地思考 49 

第5章 高阶函数 50 

5.1 柯里函数 50 
5.1.1 截断 52 
5.1.2 打印函数 53 
5.2 再来点儿高阶函数 53 
5.2.1 实现zipWith 54 
5.2.2 实现flip 55 
5.3 函数式程序员工具箱 56 
5.3.1 map函数 56 
5.3.2 filter函数 57 
5.3.3 有关map与filter的更多示例 58 
5.3.4 映射带有多个参数的函数 60 
5.4 lambda 60 
5.5 折叠纸鹤 62 
5.5.1 通过foldl进行左折叠 63 
5.5.2 通过foldr进行右折叠 63 
5.5.3 foldl1函数与foldr1函数 64 
5.5.4 折叠的几个例子 65 
5.5.5 另一个角度看折叠 66 
5.5.6 无限列表的折叠 67 
5.5.7 扫描 68 
5.6 有$的函数应用 68 
5.7 函数组合 70 
5.7.1 带有多个参数函数的组合 70 
5.7.2 Point—Free风格 71 

第6章 模块 73 

6.1 导入模块 73 
6.2 使用模块中的函数求解问题 75 
6.2.1 统计单词数 75 
6.2.2 干草堆中的缝纫针 76 
6.2.3 凯撒密码沙拉 77 
6.2.4 严格左折叠 79 
6.2.5 寻找酷数 80 
6.3 映射键与值 82 
6.3.1 几乎一样好：关联列表 82 
6.3.2 进入Data.Map 83 
6.4 构造自己的模块 87 
6.4.1 几何模块 87 
6.4.2 模块的层次结构 89 

第7章 构造我们自己的类型和类型类 91 

7.1 定义新的数据类型 91 
7.2 成型 92 
7.2.1 借助Point数据类型优化Shape数据类型 93 
7.2.2 将图形导出到模块中 94 
7.3 记录语法 95 
7.4 类型参数 97 
7.4.1 要不要参数化我们的汽车？ 99 
7.4.2 末日向量 100 
7.5 派生实例 102 
7.5.1 相同的人 102 
7.5.2 告诉我怎么读 103 
7.5.3 法庭内保持秩序！ 104 
7.5.4 一周的一天 105 
7.6 类型别名 106 
7.6.1 使我们的电话本更好看些 107 
7.6.2 参数化类型别名 108 
7.6.3 向左走，向右走 109 
7.7 递归数据结构 111 
7.7.1 优化我们的列表 111 
7.7.2 种一棵树 113 
7.8 类型类 115 
7.8.1 深入Eq类型类 116 
7.8.2 TrafficLight数据类型 116 
7.8.3 子类化 118 
7.8.4 作为类型类实例的带参数类型 118 
7.9 Yes—No类型类 120 
7.10 Functor类型类 122 
7.10.1 Maybe函子 124 
7.10.2 树也是函子 124 
7.10.3 Eithera函子 125 
7.11 kind与无名类型 126 

第8章 输入与输出 128 

8.1 纯粹与非纯粹的分离 128 
8.2 Hello，World！ 129 
8.3 组合I/O操作 130 
8.3.1 在I/O操作中使用let 132 
8.3.2 反过来 133 
8.4 几个实用的I/O函数 135 
8.4.1 putStr 135 
8.4.2 putChar 135 
8.4.3 print 136 
8.4.4 when 137 
8.4.5 sequence 137 
8.4.6 mapM 138 
8.4.7 forever 139 
8.4.8 forM 139 
8.5 I/O操作回顾 140 

第9章 更多的输入输出操作 141 

9.1 文件和流 141 
9.1.1 输入重定向 141 
9.1.2 从输入流获取字符串 142 
9.1.3 转换输入 144 
9.2 读写文件 146 
9.2.1 使用withFile函数 147 
9.2.2 bracket的时间到了 148 
9.2.3 抓住句柄 149 
9.3 TODO列表 149 
9.3.1 删除条目 150 
9.3.2 清理 152 
9.4 命令行参数 153 
9.5 关于TODO列表的更多有趣的事 154 
9.5.1 一个多任务列表 155 
9.5.2 处理错误的输入 158 
9.6 随机性 159 
9.6.1 掷硬币 160 
9.6.2 更多随机函数 161 
9.6.3 随机性和I/O 162 
9.7 字节串 165 
9.7.1 严格的和惰性字节串 166 
9.7.2 用字节串复制文件 167 

第10章 函数式地解决问题 169 

10.1 逆波兰式计算器 169 
10.1.1 计算RPN表达式 169 
10.1.2 写一个RPN函数 170 
10.1.3 添加更多的操作符 172 
10.2 从希思罗机场到伦敦 173 
10.2.1 计算最快的路线 174 
10.2.2 在Haskell中表示道路系统 176 
10.2.3 实现计算最佳路径的函数 177 
10.2.4 从输入获取道路系统 179 

第11章 applicative函子 182 

11.1 函子再现 182 
11.1.1 作为函子的I/O操作 183 
11.1.2 作为函子的函数 185 
11.2 函子定律 187 
11.2.1 定律1 188 
11.2.2 定律2 188 
11.2.3 违反定律 189 
11.3 使用applicative函子 191 
11.3.1 向applicative问好 192 
11.3.2 Maybeapplicative函子 192 
11.3.3 applicative风格 193 
11.3.4 列表 195 
11.3.5 IO也是applicative函子 197 
11.3.6 函数作为applicative 198 
11.3.7 zip列表 199 
11.3.8 applicative定律 200 
11.4 applicative的实用函数 201 

第12章 Monoid 205 

12.1 把现有类型包裹成新类型 205 
12.1.1 用newtype创建类型类的实例 207 
12.1.2 关于newtype的惰性 208 
12.1.3 type、newtype和data三者的对比 210 
12.2 关于那些monoid 211 
12.2.1 Monoid类型类 212 
12.2.2 monoid定律 213 
12.3 认识一些monoid 213 
12.3.1 列表是monoid 213 
12.3.2 Product和Sum 214 
12.3.3 Any和All 216 
12.3.4 Orderingmonoid 217 
12.3.5 Maybemonoid 219 
12.4 monoid的折叠 221 

第13章 更多monad的例子 224 

13.1 升级我们的applicative函子 224 
13.2 体会Maybe 225 
13.3 Monad类型类 228 
13.4 一往无前 229 
13.4.1 代码，代码，代码 230 
13.4.2 我要飞走 231 
13.4.3 线上的香蕉 234 
13.5 do记法 235 
13.5.1 按我所说的去做 236 
13.5.2 我皮埃尔又回来了 237 
13.5.3 模式匹配和计算失败 238 
13.6 列表monad 239 
13.6.1 do记法和列表推导式 241 
13.6.2 MonadPlus和guard函数 242 
13.6.3 马的探索 243 
13.7 monad定律 245 
13.7.1 左单位元 246 
13.7.2 右单位元 246 
13.7.3 结合律 247 

第14章 再多一些monad 249 

14.1 Writer？我没听说过啊！ 249 
14.1.1 monad赶来营救 251 
14.1.2 Writer类型 253 
14.1.3 对Writer使用do记法 254 
14.1.4 给程序添加日志 255 
14.1.5 低效的列表构造 257 
14.1.6 使用差分列表 258 
14.1.7 比较性能 259 
14.2 Reader？呃，不开玩笑了 260 
14.2.1 作为monad的函数 261 
14.2.2 Readermonad 261 
14.3 带状态计算的优雅表示 262 
14.3.1 带状态的计算 263 
14.3.2 栈和石头 264 
14.3.3 Statemonad 265 
14.3.4 获取和设置状态 267 
14.3.5 随机性和Statemonad 268 
14.4 墙上的Error 269 
14.5 一些实用的monad式的函数 271 
14.5.1 liftM和它的朋友们 271 
14.5.2 join函数 274 
14.5.3 filterM 276 
14.5.4 foldM 278 
14.6 创建一个安全的RPN计算器 279 
14.7 组合monad式的函数 281 
14.8 创建monad 282 

第15章 zipper 287 

15.1 在树上移动 287 
15.1.1 面包屑 290 
15.1.2 向上走 291 
15.1.3 处理焦点处的树 293 
15.1.4 一路走到顶端，那里的空气既新鲜又干净 294 
15.2 在列表上定位 294 
15.3 一个非常简单的文件系统 295 
15.3.1 为文件系统创建一个zipper 296 
15.3.2 操作文件系统 298 
15.4 小心行事 299 
15.5 谢谢阅读！ 301


