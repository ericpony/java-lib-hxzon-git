Google C++编程规范-第31条，显式构造函数
http://roclinux.cn/?p=3495

本原创文章属于《Linux大棚》博客。
文章作者为roc wu。

==

【规范】

请使用explicit修饰那些仅有一个参数的构造函数，避免隐式转换的发生。

【什么是隐式转换】

正常情况下，如果一个构造函数接受一个参数，那么它可能是用于转换功能。

举例来说，如果你定义了Foo:Foo(string name)这样一个构造函数，
然后将一个字符串传递给一个以Foo类型作为参数的函数，那么构造函数将被调用，
将此字符串转换为Foo类型并传递给你的函数。
这或许会很方便，但是很可能不是你想要的。使用explicit来修饰构造函数可以阻止这种隐式转换的发生。

【支持者的声音】


可以避免一些不希望发生的类型转换。

【有反对者么】

没有。

【结论】

我们要求所有单参数的构造函数都要使用explicit来修饰，例如：

explicit Foo(string name);

需要注意的是，这里有一个例外，那就是拷贝构造函数，在这种情况下，可以不使用explicit。
另外，当某个类作为其他类的透明包装类时，也可以不使用explicit。
对于这些例外情况，请在注释中进行说明。

最后，当一个构造函数接受的是一个初始化列表时，也可以不使用explicit，这是为了允许通过大括号方式进行列表赋值来构造你的类型。

谢谢！

