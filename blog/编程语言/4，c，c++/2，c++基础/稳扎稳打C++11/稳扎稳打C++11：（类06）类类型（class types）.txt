稳扎稳打C++11：（类06）类类型（class types）
来源：ilanever.com | 作者：LanPei | 创建时间：2014-4-22 23:55:16
http://ilanever.com/article/sitedetail.html;jsessionid=612D1550D54A398C5871628498084252?id=277


因为在到达类定义的末尾之前，类是未定义的，所以一个类不能拥有它自己类型的数据成员。
然而，只要类名是已知的，类就可以看作是声明过的。
因此，类可以拥有指向自己类型的指针或引用的数据成员。

=======
即使两个类拥有完全一样的成员列表，他们还是不同的类型。
我们可以使用类名作为类型名称来引用一个类类型，也可以使用关键字class或struct类使用类名。

Sales_data item1;
class Sales_data item2;

以上两种方式是相等的，第二种方法来自于C。

====
类声明 

同函数一样，我们可以声明类，但不定义类。
class Window;

这种声明方式被叫做“提前声明（forward declaration）”。
这种方式将名称Window引入程序中，并且表明Window是一个类类型。
在声明之后和定义之前，Window是个不完整类型（incomplete type）。
我们知道Window是个类类型，但不知道它的成员。

我们只能在某些限定的方式中使用不完整类型：
我们可以定义该类型的指针或引用，我们可以声明（不是定义）将不完整类型作为函数的参数或返回类型。

在我们能够写代码创建对象前，类必须被定义。
否则，编译器不知道对象需要多少存储空间。

同样，在使用引用或指针访问类型的成员之前，类必须被定义。
最终，如果类没被定义，编译器不能知道类拥有哪些成员。

只有当类被定义以后，类类型才能作为数据成员使用。
类型必须完整，因为编译器需要知道数据成员需要多大的存储空间。
因为在到达类定义的末尾之前，类是未定义的，所以一个类不能拥有它自己类型的数据成员。
然而，只要类名是已知的，类就可以看作是声明过的。
因此，类可以拥有指向本身类型的指针或引用的数据成员。

class Link_screen
{
    Screen window;
    Link_screen *next;
    Link_screen *prev;
}

