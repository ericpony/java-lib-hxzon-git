Linux多线程服务端编程：使用muduo C++网络库

陈硕 (作者) 
66.60(7.5折)

========
出版社: 电子工业出版社; 第1版 (2013年3月1日)
平装: 600页
语种： 简体中文
开本: 16
ISBN: 9787121192821
条形码: 9787121192821

=======
编辑推荐

《Linux多线程服务端编程:使用muduo C++网络库》编辑推荐：示范在多核时代采用现代C++编写，多线程TCP网络服务器的正规做法。

作者简介

陈硕，北京师范大学硕士，擅长C++多线程网络编程和实时分布式系统架构。
曾在摩根士丹利IT部门工作5年，从事实时外汇交易系统开发。
现在在美国加州硅谷某互联网大公司工作，从事大规模分布式系统的可靠性工程。
编写了开源C++网络库muduo，参与翻译了《代码大全（第2版）》和《C++编程规范（繁体版）》，
整理了《C++ Primer（第4版）（评注版）》，并曾多次在各地技术大会演讲。

=======
目录


第1部分 C++多线程系统编程 

第1章 线程安全的对象生命期管理 

1.1 当析构函数遇到多线程 
1.1.1 线程安全的定义 
1.1.2 MutexLock与HutexLockGuard 
1.1.3 一个线程安全的Counter示例 

1.2 对象的创建很简单 

1.3 销毁太难 
1.3.1 mutex不是办法 
1.3.2 作为数据成员的mutex不能保护析构 

1.4 线程安全的Observer有多难 
1.5 原始指针有何不妥 
1.6 神器shared_ptr／weak_ptr 
1.7 插曲：系统地避免各种指针错误 
1.8 应用到Observer上 
1.9 再论shared_ptr的线程安全 
1.10 shared_ptr技术与陷阱 

1.11 对象池 
1.11.1 enable_shared_from_this 
1.11.2 弱回调 

1.12 替代方案 
1.13 心得与小结 
1.14 Observer之谬 

第2章 线程同步精要 

2.1 互斥器（mutex） 
2.1.1 只使用非递归的mutex 
2.1.2 死锁 

2.2 条件变量（condition variable） 
2.3 不要用读写锁和信号量 
2.4 封装MutexLock、MutexLockGuard、Condition 
2.5 线程安全的Singleton实现 
2.6 sleep（3）不是同步原语 
2.7 归纳与总结 
2.8 借shared_ptr实现copy-on-write 

第3章 多线程服务器的适用场合与常用编程模型 

3.1 进程与线程 
3.2 单线程服务器的常用编程模型 

3.3 多线程服务器的常用编程模型 
3.3.1 one loop per thread 
3.3.2 线程池 
3.3.3 推荐模式 

3.4 进程间通信只用TCP 

3.5 多线程服务器的适用场合 
3.5.1 必须用单线程的场合 
3.5.2 单线程程序的优缺点 
3.5.3 适用多线程程序的场景 

3.6 “多线程服务器的适用场合”例释与答疑 

第4章 C++多线程系统编程精要 

4.1 基本线程原语的选用 
4.2 C／C++系统库的线程安全性 
4.3 Linux上的线程标识 

4.4 线程的创建与销毁的守则 
4.4.1 pthread_cancel与C++ 
4.4.2 exit（3）在C++中不是线程安全的 

4.5 善用__thread关键字 
4.6 多线程与IO 
4.7 用RAII包装文件描述符 
4.8 RAII与fork（） 
4.9 多线程与fork（） 
4.10 多线程与signal 
4.11 Linux新增系统调用的启示 

第5章 高效的多线程日志 

5.1 功能需求 
5.2 性能需求 
5.3 多线程异步日志 
5.4 其他方案 


第2部分 muduo网络库 

第6章 muduo网络库简介 

6.1 由来 
6.2 安装 

6.3 目录结构 
6.3.1 代码结构 
6.3.2 例子 
6.3.3 线程模型 

6.4 使用教程 
6.4.1 TCP网络编程本质论 
6.4.2 echo服务的实现 
6.4.3 七步实现finger服务 

6.5 性能评测 
6.5.1 muduo与Boost.Asio、libevent2的吞吐量对比 
6.5.2 击鼓传花：对比muduo与libevent2的事件处理效率 
6.5.3 muduo与Nginx的吞吐量对比 
6.5.4 muduo与ZeroMQ的延迟对比 

6.6 详解muduo多线程模型 
6.6.1 数独求解服务器 
6.6.2 常见的并发网络服务程序设计方案 

第7章 muduo编程示例 

7.1 五个简单TCP示例 
7.2 文件传输 

7.3 Boost.Asio的聊天服务器 
7.3.1 TCP分包 
7.3.2 消息格式 
7.3.3 编解码器LengthHeaderCodec 
7.3.4 服务端的实现 
7.3.5 客户端的实现 

7.4 muduo Buffer类的设计与使用 
7.4.1 muduo的IO模型 
7.4.2 为什么non-blocking网络编程中应用层buffer是必需的 
7.4.3 Buffer的功能需求 
7.4.4 Buffer的数据结构 
7.4.5 Buffer的操作 
7.4.6 其他设计方案 
7.4.7 性能是不是问题 

7.5 一种自动反射消息类型的Google Protobuf网络传输方案 
7.5.1 网络编程中使用Protobuf的两个先决条件 
7.5.2 根据type name反射自动创建Message对象 
7.5.3 Protobuf传输格式 

7.6 在muduo中实现Protobuf编解码器与消息分发器 
7.6.1 什么是编解码器（codec） 
7.6.2 实现ProtobufCodec 
7.6.3 消息分发器（dispatcher）有什么用 
7.6.4 ProtobufCodec与ProtobufDispatcher的综合运用 
7.6.5 ProtobufDispatcher的两种实现 
7.6.6 ProtobufCodec和ProtobufDispatcher有何意义 

7.7 限制服务器的最大并发连接数 
7.7.1 为什么要限制并发连接数 
7.7.2 在muduo中限制并发连接数 

7.8 定时器 
7.8.1 程序中的时间 
7.8.2 Linux时间函数 
7.8.3 muduo的定时器接口 
7.8.4 Boost.Asio Timer示例 
7.8.5 Java Netty示例 

7.9 测量两台机器的网络延迟和时间差 

7.10 用timing wheel踢掉空闲连接 
7.10.1 timing wheel原理 
7.10.2 代码实现与改进 

7.11 简单的消息广播服务 
7.12 “串并转换”连接服务器及其自动化测试 

7.13 socks4a代理服务器 
7.13.1 TCP中继器 
7.13.2 socks4a代理服务器 
7.13.3 N：1与1：N连接转发 

7.14 短址服务 

7.15 与其他库集成 
7.15.1 UDNS 
7.15.2 c—ares DNS 
7.15.3 curl 
7.15.4 更多 
…… 

第8章 muduo网络库设计与实现 


第3部分 工程实践经验谈 

第9章 分布式系统工程实践 
第10章 C++编译链接模型精要 
第11章 反思C++面向对象与虚函数 
第12章 C++经验谈 


第4部分 附录 

附录A 谈一谈网络编程学习经验 
附录B 从《C++Primer（第4版）》入手学习C++ 
附录C 关于Boost的看法 
附录D 关于TCP并发连接的几个思考题与试验 
参考文献

========
序言

本书主要讲述采用现代C++ 在x86-64 Linux上编写多线程TCP网络服务程序的主流常规技术，
这也是我对过去5年编写生产环境下的多线程服务端程序的经验总结。
本书重点讲解多线程网络服务器的一种IO 模型，即one loop per thread。
这是一种适应性较强的模型，也是Linux 下以native语言编写用户态高性能网络程序最成熟的模式，掌握之后可顺利地开发各类常见的服务端网络应用程序。
本书以muduo网络库为例，讲解这种编程模型的使用方法及注意事项。
muduo 是一个基于非阻塞IO 和事件驱动的现代C++ 网络库，原生支持one loop per thread 这种IO 模型。
muduo 适合开发Linux 下的面向业务的多线程服务端网络应用程序，其中“面向业务的网络编程”的定义见附录A。
“现代C++”指的不是C++11 新标准，而是2005 年TR1 发布之后的C++ 语言和库。
与传统C++ 相比，现代C++ 的变化主要有两方面：资源管理（见第1 章）与事件回调（见第449 页）。

本书不是多线程编程教程，也不是网络编程教程，更不是C++教程。
读者应该已经大致读过《UNIX环境高级编程》、《UNIX网络编程》、《C++Primer》或与之内容相近的书籍。
本书不谈C++11，因为目前（2012年）主流的Linux 服务端发行版的g++版本都还停留在4.4，C++11 进入实用尚需一段时日。
本书适用的硬件环境是主流x86-64 服务器，多路多核CPU、几十GB 内存、千兆以太网互联。
除了第5章讲诊断日志之外，本书不涉及文件IO。

本书分为四大部分，
第1 部分“C++ 多线程系统编程”考察多线程下的对象生命期管理、线程同步方法、多线程与C++ 的结合、高效的多线程日志等。
第2 部分“muduo 网络库”介绍使用现成的非阻塞网络库编写网络应用程序的方法，以及muduo的设计与实现。
第3部分“工程实践经验谈”介绍分布式系统的工程化开发方法和C++在工程实践中的功能特性取舍。
第4部分“附录”分享网络编程和C++语言的学习经验。

本书的宗旨是贵精不贵多。
掌握两种基本的同步原语就可以满足各种多线程同步的功能需求，还能写出更易用的同步设施。
掌握一种进程间通信方式和一种多线程网络编程模型就足以应对日常开发任务，编写运行于公司内网环境的分布式服务系统。
（本书不涉及分布式存储系统，也不涉及UDP。）

术语与排版范例

本书大量使用英文术语，甚至有少量英文引文。
设计模式的名字一律用英文，例如Observer、Reactor、Singleton。
在中文术语不够突出时，也会使用英文，例如class、heap、event loop、STL algorithm等。
注意几个中文C++术语：对象实体（instance）、函数重载决议（resolution）、模板具现化（instantiation）、覆写（override）虚函数、提领（dereference）指针。
本书中的英语可数名词一般不用复数形式，例如两个class，6 个syscall；但有时会用(s) 强调中文名词是复数。
fd 是文件描述符（file descriptor）的缩写。
“CPU数目”一般指的是核（core）的数目。
容量单位kB、MB、GB表示的字节数分别为103、106、109，在特别强调准确数值时，会分别用KiB、MiB、GiB 表示210、220、230 字节。
用诸如§11.5 表示本书第11.5 节，L42 表示上下文中出现的第42 行代码。
[JCP]、[CC2e] 等是参考文献，见书末清单。




