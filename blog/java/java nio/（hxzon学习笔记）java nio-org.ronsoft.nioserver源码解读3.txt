（hxzon学习笔记）java nio-org.ronsoft.nioserver源码解读3by hxzon========7，同步synchronized7.1，HandlerAdapter ：synchronized (stateChangeLock)    public HandlerAdapter call() throws IOException {        logger.trace("handlerAdapter call thread");        try {            drainOutput();            fillInput();            ByteBuffer message;            // must process all buffered messages because Selector will            // not fire again for input that's already read and buffered            while ((message = clientHandler.nextMessage(this)) != null) {                clientHandler.handleInput(message, this);            }        } finally {            synchronized (stateChangeLock) {                running = false;            }        }        return this;    }    public void modifyInterestOps(int opsToSet, int opsToReset) {        synchronized (stateChangeLock) {            interestOps = (interestOps | opsToSet) & (~opsToReset);            if (!running) {                dispatcher.enqueueStatusChange(this);            }        }    }    void prepareToRun() {        synchronized (stateChangeLock) {            interestOps = key.interestOps();            readyOps = key.readyOps();            running = true;        }    }7.2，StandardAcceptor.public synchronized Thread newThread()StandardAcceptor.public synchronized void shutdown()InputQueueImpl.public synchronized int fillFrom(ByteChannel channel)InputQueueImpl.public synchronized ByteBuffer dequeueBytes(int count)InputQueueImpl.public synchronized boolean isEmpty()InputQueueImpl.public synchronized int indexOf(byte b)OutputQueueImpl.public synchronized int drainTo(ByteChannel channel)OutputQueueImpl.public synchronized boolean enqueue(ByteBuffer byteBuffer)OutputQueueImpl.public synchronized boolean isEmpty()7.3，NioDispatcher ：private final ReadWriteLock selectorGuard = new ReentrantReadWriteLock();    /**     * Called to acquire and then immediately release a write lock     * on the selectorGuard object. This method is only called by     * the selection thread and it has the effect of making that     * thread wait until all read locks have been released.     */	//有何作用？	//原文注释：使得选择器所在线程一直等待，直到所有的读锁释放。    private void selectorGuardBarrier() {        selectorGuard.writeLock().lock();        selectorGuard.writeLock().unlock();    }    // --------------------------------------------------------    // Reader lock acquire/release, called by non-selector threads    /**     * Grab a read lock on the selectorGuard object.  A handler thread     * calls this method when it wants to mutate the state of the     * Selector.  It must call releaserSelectorGuard when it is finished,     * because selection will not resume until all read locks have been     * released.     */    private void acquireSelectorGuard() {        selectorGuard.readLock().lock();        selector.wakeup();    }    /**     * Undo a previous call to acquireSelectorGuard to indicate that     * the calling thread no longer needs access to the Selector object.     */    private void releaseSelectorGuard() {        selectorGuard.readLock().unlock();    }----------------------    public void dispatch() throws IOException {        logger.trace("dispatch");        while (dispatching) {            selectorGuardBarrier();//获取写锁，又马上释放。使得选择器所在线程一直等待，直到所有的读锁释放。            selector.select();            checkStatusChangeQueue();            Set<SelectionKey> keys = selector.selectedKeys();            for (SelectionKey key : keys) {                HandlerAdapter adapter = (HandlerAdapter) key.attachment();                invokeHandler(adapter);            }            keys.clear();        }    }-----------------    public ChannelFacade registerChannel(SelectableChannel channel, InputHandler handler) throws IOException {        channel.configureBlocking(false);        HandlerAdapter adapter = new HandlerAdapter(handler, this, bufferFactory);        adapter.registering();        acquireSelectorGuard();//获取读锁        try {            SelectionKey key = channel.register(selector, SelectionKey.OP_READ, adapter);            adapter.setKey(key);            adapter.registered();            return adapter;        } finally {            releaseSelectorGuard();//释放读锁        }    }    public void unregisterChannel(ChannelFacade token) {        if (!(token instanceof HandlerAdapter)) {            throw new IllegalArgumentException("Not a valid registration token");        }        HandlerAdapter adapter = (HandlerAdapter) token;        SelectionKey selectionKey = adapter.key();        acquireSelectorGuard();//获取读锁        try {            adapter.unregistering();            selectionKey.cancel();        } finally {            releaseSelectorGuard();//释放读锁        }        adapter.unregistered();    }