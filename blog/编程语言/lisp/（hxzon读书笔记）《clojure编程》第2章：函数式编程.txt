（hxzon读书笔记）《clojure编程》第2章：函数式编程

by hxzon
《clojure编程》第2章：函数式编程

hxzon摘要：

1，高阶函数：map,reduce（规约）,partial（部分应用函数）,comp（函数组合）,complement,repeatedly。
2，匿名函数vs函数字面量。
3，内存化：memoize函数，core.memoize函数库。

=======

1，声明式处理，组合，值不随时间的改变而改变。
集合也能够作为map的key。


2，一个关键性的选择：

-1，可变对象不能被安全的传给方法调用。
-2，可变对象不能安全的作为map的key、sets的元素灯。因为它们的相等语义以及查询语义会随着时间的改变而改变。
-3，可变对象不能被安全地缓存。
-4，可变对象不能在多线程情况下被安全的使用，因为需要小心地在不同线程之间进行同步。

软件编程领域最大的挑战其实就是“如何辨别出那些不变的元素”。
你找打的不变元素越多，你就可以把越多的注意力集中在某段代码的本地改变上面。


========
3，高阶函数。
map,reduce（规约）,partial（部分应用函数）,comp（函数组合）,complement,repeatedly。

----
(map f [a b c]) 相当于 [(f a) (f b) (f c)] 。

(map f [a b c] [x y x]) 相当于 [(f a x) (f b y) (f c z)] 。

(reduce max [0 -3 10 48]) 相当于  (max (max (max 0 -3) 10) 48) 。

--
匿名函数vs函数字面量

函数字面量省略了fn符号和参数数组（使用%、%2来表示第1个、第2个参数），更简洁。
匿名函数能给参数起个有意义的名字，可读性好些。

(reduce
    (fn [m v] 
        (assoc m v (* v v)))
    {}  ;初始是个空集合
    [1 2 3 4])
;= {4 16, 3 9, 2 4, 1 1}

(reduce
    #(assoc % %2 (* %2 %2))
    {}
    [1 2 3 4])
;= {4 16, 3 9, 2 4, 1 1}

----
函数应用apply

(apply fnX paramsYY)
(apply fnX param1 param2 paramsYY)
可以先指定前几个参数。

----
部分应用函数partial

(def only-strings (partial filter string?))
;= #'user/only-strings

(only-strings ["a" 5 "b" 6])
;= ("a" "b")

部分应用函数vs函数字面量：
函数字面量提供了partial所提供的功能的超集。
而且函数字面量并不限制你去指定函数的开头几个参数。
但是，函数字面量强制指定要调用的函数的所有参数。

(#(map *) [1 2 3] [4 5 6] [7 8 9]) 
;= #<ArityException clojure.lang.ArityException:
;= Wrong number of args (3) passed to: user$eval812$fn>

(#(map * % %2 %3) [1 2 3] [4 5 6] [7 8 9]) 
;= (28 80 162)

(#(map * % %2 %3) [1 2 3] [4 5 6]) 
;= #<ArityException clojure.lang.ArityException:
;= Wrong number of args (2) passed to: user$eval843$fn>

(#(apply map * %&) [1 2 3] [4 5 6] [7 8 9]) 
;= (28 80 162)
可以通过“百分号与号”来说明这个函数字面量接受的剩余参数。


(#(apply map * %&) [1 2 3])
;= (1 2 3)

((partial map *) [1 2 3] [4 5 6] [7 8 9]) 
;= (28 80 162)

==========
4，函数（功能）的组合

(comp f3 f2 f1)

(defn negated-sum-str
    [& numbers]
    (str (- (apply + numbers))))
;= #'user/negated-sum-str

(negated-sum-str 10 12 3.4)
;= "-25.4"

(def negated-sum-str (comp str - +))
;= #'user/negated-sum-str

(negated-sum-str 10 12 3.4)
;= "-25.4"

--
(require '[clojure.string :as str]) 

(def camel->keyword (comp keyword
                          str/join
                          (partial interpose \-)
                          (partial map str/lower-case)
#(str/split % #"(?<=[a-z])(?=[A-Z])"))) 
;= #'user/camel->keyword

(camel->keyword "CamelCase")
;= :camel-case

(camel->keyword "lowerCamelCase")
;= :lower-camel-case

可以通过串行宏来实现函数组合的功能：

(defn camel->keyword
    [s]
    (->> (str/split s #"(?<=[a-z])(?=[A-Z])")
         (map str/lower-case)
         (interpose \-)
         str/join
         keyword))

--
(def camel-pairs->map 
    (comp   (partial apply hash-map)
            (partial map-indexed (fn [i x]
                                     (if (odd? i)
                                         x
                                         (camel->keyword x))))))
;= #'user/camel-pairs->map

(camel-pairs->map ["CamelCase" 5 "lowerCamelCase" 3])
;= {:camel-case 5, :lower-camel-case 3}

--
利用可组合的高阶函数构建一个日志系统。

打印日志到不同的地方。
打印日志到多个地方。
给日志添加时间戳。
用map来描述一个日志信息，可以很轻易的对这个map进行各种转换，实现日志消息的过滤等。

成熟的库：https://github.com/clojure/tools.logging
=========
5，

幂等的：总是返回同一个值。
纯的：没有副作用。

-1，纯函数更容易测试。
-2，纯函数的结果是可以被缓存的，并且很容易并行化。

clojure提供了一个memoize函数，可以返回一个函数的内存化版本：

(defn prime? 
    [n]
    (cond
        (== 1 n) false
        (== 2 n) true
        (even? n) false
        :else (->>  (range 3 (inc (Math/sqrt n)) 2)
                    (filter #(zero? (rem n %)))
                    empty?)))

(time (prime? 1125899906842679)) 
; "Elapsed time: 2181.014 msecs"
;= true

(let [m-prime? (memoize prime?)]
    (time (m-prime? 1125899906842679))
    (time (m-prime? 1125899906842679)))
; "Elapsed time: 2085.029 msecs" 
; "Elapsed time: 0.042 msecs" 
;= true

----
core.memoize(https://github.com/clojure/core.memoize)

memoize是怎么做到的呢？保存所有调用参数和对应返回值的映射，不会被垃圾回收。
所以如果一个函数的参数的取值范围很广，或者参数、返回值很占用内存，
那么通常会造成“内存泄露”，特别是当它们被用def幼稚地定义成一个全局的var。

对于这种问题的解决办法：
-1，不要把它们定义成顶层的函数，把它们定义成一个顶层函数的内部，然后只在需要的时候调用它们。
-2，使用core.memoize，这是一个内存化函数库，
它提供一些不同的内存化策略，包括在一定时间之后失效缓存的内容等。

=======
hxzon补充：
http://clojure-api-cn.readthedocs.org/en/latest/index.html

6，mapcat
(mapcat f & colls)

等同于调用 (concat (map f colls)) 。

user=> (mapcat reverse [[3 2 1 0]
                        [6 5 4]
                        [9 8 7]])
(0 1 2 3 4 5 6 7 8 9)

7，map-indexed
(map-indexed f coll)

返回一个惰性序列， 序列里的第一个元素是将 0 和 coll 的第一个元素应用到 f 所得出的值，
 序列里的第二个元素是将 1 和 coll 的第二个元素应用到 f 所得出的值。。。 
 以此类推，直到 coll 被处理完为止。

函数 f 应该接受两个参数：一个索引值，一个是 coll 的元素值。

user=> (map-indexed (fn [idx item] [idx item]) "foobar")
([0 \f] [1 \o] [2 \o] [3 \b] [4 \a] [5 \r])

user=> (map-indexed vector "foobar")    ; 另一种更简单的解法
([0 \f] [1 \o] [2 \o] [3 \b] [4 \a] [5 \r])

8，max-key
(max-key f item1)
(max-key f item1 item2)
(max-key f item1 item2 & items)

将函数 f 应用到所有给定元素上，其中 (f item) 值最大的那个 item 被返回。

(f item) 的结果必须是数字值。

user=> (max-key count "abc"
                      "abcd"
                      "a"
                      "abcdefg"
                      "aa")
"abcdefg"

----
9，range
(range)
(range end)
(range start end)
(range start end step)

返回一个惰性序列， 序列里包含从大于等于 start 到小于 end 区间内的所有数字(start <= numbers < end)， 数字的步进以 step 指定。
默认情况下， start 为 0 ， step 为 1 ，而 end 则为无限。

10，repeat
(repeat x)
(repeat n x)

返回一个包含 n 个 x 的惰性序列。
如果不指定 n ，那么值 x 可以被包含无限次。

11，repeatedly
(repeatedly f)
(repeatedly n f)

给定一个无参数的函数 f (通常带有副作用)，返回一个调用 f 函数 n 次的惰性序列。
如果不指定参数 n ，那么函数 f 可以执行无限次。

----
12，keep
(keep f coll)

对于 coll 中的每个项 item ， (keep f coll) 返回一个惰性序列， 序列包含 (f item) 除 nil 之外的所有计算结果。
因为带副作用的函数会返回与计算结果无关的虚假值， 因此，为了确保虚假值不会混进 keep 所生成的惰性序列中， f 必须是一个无副作用的函数。

user=> (keep inc [1 2 3])
(2 3 4)

; 将空的 collection 传给 seq 函数会返回 nil
; 可以根据这个性质来测试 keep
; 看它是否真的会省略等于 nil 的值
user=> (seq [])
nil

user=> (keep seq (list [1 2 3] [] [4 5 6]))
((1 2 3) (4 5 6))

----
13，keep-indexed
(keep-indexed f coll)

对于 coll 中的每个项 item ， 以及 item 对应的索引下标 index ， 
(keep-indexed f coll) 返回一个惰性序列， 序列中包含 (f index item) 除 nil 之外的所有计算结果。

因为带副作用的函数会返回与计算结果无关的虚假值， 
因此，为了确保虚假值不会混进 keep-indexed 所生成的惰性序列中， f 必须是一个无副作用的函数。

; 返回 0 - 9 内所有排序位置(index)为偶数的数字（对于奇数，匿名函数返回nil，这些nil被移除了。）
user=> (keep-indexed #(if (even? %1) %2 nil) (range 10))
(0 2 4 6 8)

----
14，reductions
(reductions f coll)
(reductions f init coll)

返回一个惰性序列， 序列里包含计算 (reduce f coll) 所产生的所有中间结果。
如果给定了 init ，那么将它用作所有中间结果的初始值。

user=> (reduce + (range 1 10))
45

user=> (reductions + (range 1 10))
(1 3 6 10 15 21 28 36 45)

user=> (reductions + 0 (range 1 10))    ; 注意 init 不止添加到序列头那么简单
(0 1 3 6 10 15 21 28 36 45)

user=> (reductions + 10 (range 1 10))   ; 它还作为每个中间值的初始化值（这里每个中间值都加上了初始值）
(10 11 13 16 20 25 31 38 46 55)

----
15，map-invert
(map-invert m)

反转一个 map ，将它原本的 value 映射为新 map 的 key ，原本的 key 映射为新 map 的 value 。
注意，当多个 key 有同一个 value 时，新 map 只保留其中的一个作为 key 。

16，iterate
(iterate f x)

返回一个惰性序列， 序列元素的值为 x 、 (f x) 、 (f (f x)) 、 (f (f (f x))) ， 诸如此类。
函数 f 必须是无副作用的。

17，select
(select pred xset)

返回 xset 中所有使 pred 为真的元素。
select 和 clojure.core/filter 类似，只是 select 的输入和输出都是 set 。

18，time
(time expr)

对 expr 进行求值，并打印求值所花费的时间。
expr 的值作为函数的返回值被返回。

19，pmap
(pmap f coll)
(pmap f coll & colls)

pmap 类似于 map ，唯一的不同是， pmap 对函数 f 的应用是并行的。
pmap 的返回值是半惰性的(semi-lazy)： 并行计算总是发生在消耗(consumption)之前， 不过，计算结果只有在被需要时，才会被 realize 。
只有当 f 为计算密集型函数， 而且并行获得的性能提升足以抵消并行所需的协调消耗时， 才应该使用 pmap 。

20，pcalls
(pcalls & fns)

并行计算 fns 中的无参数函数，并以惰性序列的形式返回它们的值。

注意，因为 pcalls 和 pvalues 的返回值都是惰性序列，
因此，如果有一个非常耗时的表达式阻塞在其他一些表达式的前面，那么就算后面的这些表达式已经计算完了，它们也不能被返回。
以下是这样一个实例，在序列前面的三个元素，可以立即被返回，
但是，后面的三个元素只有等待 (Thread/sleep 3000) 执行完毕之后，才会被返回，尽管它们早就在并发线程里被求值完了：

user=> (for [i (pvalues 1 2 3
                        (Thread/sleep 3000)
                        (do (println "eval 4") 4)
                        (do (println "eval 5") 5)
                        (do (println "eval 6") 6))
            ]
           (println i)
       )
(1
2
nil eval 5  ; 从 println 的输出可以看到
eval 4      ; 4 、 5 、 6 三个数已经被计算出来了，但还没办法返回
3
nil eval 6
nil         ; sleep 执行，停滞 3 秒
nil 4
nil 5
nil 6
nil nil)

21，pvalues
(pvalues & exprs)

并行计算 exprs 中的表达式，并以惰性序列的形式返回它们的值。

22，reverse
(reverse coll)

逆序给定的 coll 。这个操作不是惰性(lazy)的。

23，shuffle
(shuffle coll)

返回对 coll 进行乱序排列之后得出的序列。

24，doall
(doall coll)
(doall n coll)

对于那些带副作用的函数所生成的惰性序列来说，只有当列表的某个元素被求值时，该元素的副作用才会被显现出来。
doall 使用 next 函数遍历整个序列，从而迫使惰性序列的副作用产生。
这个函数返回序列的首个元素作为结果，因此它需要在内存中保存整个序列。

25，dorun
(dorun coll)
(dorun n coll)

对于那些带副作用的函数所生成的惰性序列来说，只有当列表的某个元素被求值时，该元素的副作用才会被显现出来。
dorun 使用 next 函数遍历整个序列，从而迫使惰性列表的副作用产生。
这个函数返回 nil ，而不是序列的首个元素。

26，complement （补充，补语。）
(complement f)

接受一个函数 f ，返回一个匿名函数。
这个匿名函数接受的参数、产生的作用都和 f 一样， 但它返回的真值和 f 相反。

user=> (defn f []
           (println "hello")
           false)
#'user/f

user=> (f)
hello
false

user=> ((complement f))
hello
true

27，constantly
(constantly x)

返回一个匿名函数， 接受任何数量的参数， 但总是返回 x 。

=======
http://clojure.github.io/clojure/

1，juxt
function
Usage: (juxt f)
       (juxt f g)
       (juxt f g h)
       (juxt f g h & fs)

Takes a set of functions and returns a fn that is the juxtaposition（并列） of those fns.  
The returned fn takes a variable number of args, and
returns a vector containing the result of applying each fn to the args (left-to-right).

((juxt a b c) x) => [(a x) (b x) (c x)]

2，group-by
function
Usage: (group-by f coll)

Returns a map of the elements of coll keyed by the result of f on each element. 
The value at each key will be a vector of the corresponding elements, 
in the order they appeared in coll.
对集合的每个元素调用f，按结果分组。

(group-by #(rem % 3) (range 10))
;= {0 [0 3 6 9], 1 [1 4 7], 2 [2 5 8]}

(def playlist
    [   {:title "Elephant", :artist "The White Stripes", :year 2003}
        {:title "Helioself", :artist "Papas Fritas", :year 1997}
        {:title "Stories from the City, Stories from the Sea",:artist "PJ Harvey", :year 2000}
        {:title "Buildings and Grounds", :artist "Papas Fritas", :year 2000}
        {:title "Zen Rodeo", :artist "Mardi Gras BB", :year 2002}])

(group-by :artist playlist)
;= {"Papas Fritas" [{:title "Helioself", :artist "Papas Fritas", :year 1997}
;=     {:title "Buildings and Grounds", :artist "Papas Fritas"}]
;= ...}

(into {} 
      (for [ [k v] (group-by key-fn coll)]
           [ k (summarize v)]))

