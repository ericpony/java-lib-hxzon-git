Visual C++ 2012入门经典(第6版)

I.) 霍尔顿 (Horton (作者), 苏正泉 (译者), 李文娟 (译者) 

68.60 (7折)
===========
出版社: 清华大学出版社; 第6版 (2013年5月1日)
外文书名: Ivor Horton's Beginning Visual C++ 2012
平装: 752页
语种： 简体中文
开本: 16

=========
编辑推荐

《Visual C++ 2012入门经典(第6版)》编辑推荐：世界著名的计算机畅销书作者、超级畅销书《C语言入门经典（第4版）》作者、编程导师霍尔顿（Ivor Horton）最新作品，国内第一本Visual C++ 2012 著作。

--
作者简介

作者：（美国）霍尔顿（Ivor Horton） 译者：苏正泉 李文娟

霍尔顿（Ivor Horton），是世界著名的计算机图书作家，主要从事与编程相关的顾问及撰写工作，曾帮助无数程序员步入编程的殿堂。他曾在IBM工作多年，能使用多种语言进行编程（在多种机器上使用汇编语言和高级语言），设计和实现了实时闭环工业控制系统。Horton拥有丰富的教学经验（教学内容包括C、C++、Fortran、PL/1、APL等），同时还是机械、加工和电子CAD系统、机械CAM系统和DNC/CNC系统方面的专家。

Ivor Horton原来是一位数学家，却因向往信息技术工作轻松而收入丰厚，因而涉足信息技术领域。尽管现实情况常常是工作辛苦而收入却相对不高，但他仍坚持从事计算机工作至今。在不同的时期，他从事过的工作包括程序设计、系统设计、顾问工作以及管理和实现相当复杂的项目。

Horton在计算机系统的设计和实现方面，拥有多年的工作经验，这些系统应用于多种行业的工程设计和制造运营。他不仅能运用多种编程语言开发特殊用途的应用程序，而且还为科研人员和工程人员提供教学，以帮助他们完成这类工作，在这些方面他都拥有相当丰富的经验。他多年来一直从事程序设计方面书籍的撰写工作，目前出版的著作有C、C++和Java等教程。目前，他既没有忙于写书，也不提供咨询服务，而是在钓鱼、旅游和尽情地享受生活。

Marc Gregoire，是来自比利时的一位软件工程师。他毕业于比利时天主教鲁汶大学，获得了“Burgerlijk ingenieur in de computer wetenschappen”学位（等同于计算机科学工程的科学硕士学位）。此后，他以优异成绩获得了同一所大学的人工智能硕士学位，并开始供职于一家大型软件咨询公司。他在西门子和诺基亚西门子通信公司为大型电信运营商开发运行于Solaris上至关重要的2G和3G软件，这需要在国际团队中工作，包括南美、USA、EMEA和亚洲。现在，Marc在尼康公司开发三维扫描软件。

他主要擅长C/C++，具体地说就是Microsoft VC++和MFC framework。除C/C++之外，他也喜欢C#，并使用PHP制作网页。除主要致力于Windows开发以外，他在开发全天候运行在Linux平台上的C++程序方面，也具有一定的经验，例如EIB家用自动控制和监视软件。

由于在Visual C++方面具有杰出的专业技能，Marc Gregoire自从2007年4月开始，每年都荣获了Microsoft MVP（Most Valuable Professional）大奖。
Marc不仅是Belgian C++用户组的创始人和CodeGuru论坛的活跃分子（会员名是Marc G）。

==========
目录

第1章 使用Visual C++编程 1
第2章 数据、变量和计算 21
第3章 判断和循环 79
第4章 数组、字符串和指针 113
第5章 程序结构(1) 157
第6章 程序结构(2) 191
第7章 自定义数据类型 229

第8章 深入理解类 277
第9章 类继承和虚函数 367
第10章 标准模板库 411

第11章 Windows编程的概念 503
第12章 使用MFC编写Windows程序 531
第13章 处理菜单和工具栏 551
第14章 在窗口中绘图 573
第15章 改进视图 615
第16章 使用对话框和控件 641
第17章 存储和打印文档 679

第18章 编写Windows 8应用程序 707

===========
目录

第1章 使用Visual C++编程 1

1.1 使用Visual C++学习 1
1.2 编写C++应用程序 2
1.3 学习桌面应用程序的编程 2
1.3.1 学习C++ 3
1.3.2 控制台应用程序 3
1.3.3 Windows编程概念 3
1.4 集成开发环境简介 5
1.4.1 编辑器 5
1.4.2 编译器 5
1.4.3 链接器 5
1.4.4 库 6
1.5 使用IDE 6
1.5.1 工具栏选项 7
1.5.2 可停靠的工具栏 8
1.5.3 文档 8
1.5.4 项目和解决方案 8
1.5.5 设置Visual C++的选项 16
1.5.6 创建和执行Windows应用程序 17
1.6 小结 19
1.7 本章主要内容 19

第2章 数据、变量和计算 21

2.1 C++程序结构 21
2.1.1 main()函数 28
2.1.2 程序语句 28
2.1.3 空白 30
2.1.4 语句块 30
2.1.5 自动生成的控制台程序 31
2.2 定义变量 32
2.2.1 命名变量 32
2.2.2 声明变量 33
2.2.3 变量的初始值 34
2.3 基本数据类型 34
2.3.1 整型变量 35
2.3.2 字符数据类型 36
2.3.3 整型修饰符 37
2.3.4 布尔类型 38
2.3.5 浮点类型 38
2.3.6 C++中的基本类型 39
2.3.7 字面值 39
2.3.8 定义数据类型的同义词 40
2.4 基本的输入/输出操作 41
2.4.1 从键盘输入 41
2.4.2 到命令行的输出 41
2.4.3 格式化输出 42
2.4.4 转义序列 43
2.5 C++中的计算 45
2.5.1 赋值语句 45
2.5.2 算术运算 45
2.5.3 计算余数 50
2.5.4 修改变量 50
2.5.5 增量和减量运算符 51
2.5.6 计算的顺序 53
2.6 类型转换和类型强制转换 54
2.6.1 赋值语句中的类型转换 55
2.6.2 显式类型转换 56
2.6.3 老式的类型强制转换 57
2.7 AUTO关键字 57
2.8 类型的确定 58
2.9 按位运算符 58
2.9.1 按位AND运算符 58
2.9.2 按位OR运算符 60
2.9.3 按位EOR运算符 61
2.9.4 按位NOT运算符 61
2.9.5 移位运算符 61
2.10 lvalue和rvalue 63
2.11 了解存储时间和作用域 64
2.11.1 自动变量 64
2.11.2 决定变量声明的位置 66
2.11.3 全局变量 67
2.11.4 静态变量 70
2.12 具有特定值集的变量 70
2.12.1 旧枚举 70
2.12.2 类型安全的枚举 72
2.13 名称空间 74
2.13.1 声明名称空间 75
2.13.2 多个名称空间 76
2.14 小结 77
2.15 练习 77
2.16 本章主要内容 78

第3章 判断和循环 79

3.1 比较数据值 79
3.1.1 if语句 80
3.1.2 嵌套的if语句 81
3.1.3 嵌套的if-else语句 85
3.1.4 逻辑运算符和表达式 87
3.1.5 条件运算符 89
3.1.6 switch语句 91
3.1.7 无条件转移 94
3.2 重复执行语句块 95
3.2.1 循环的概念 95
3.2.2 for循环的变体 97
3.2.3 while循环 104
3.2.4 do-while循环 106
3.2.5 基于范围的循环 107
3.2.6 嵌套的循环 107
3.3 小结 110
3.4 练习 110
3.5 本章主要内容 111

第4章 数组、字符串和指针 113

4.1 处理多个相同类型的数据值 113
4.1.1 数组 113
4.1.2 声明数组 114
4.1.3 初始化数组 117
4.1.4 使用基于范围的for循环 118
4.1.5 字符数组和字符串处理 119
4.1.6 多维数组 122
4.2 间接数据访问 125
4.2.1 指针的概念 125
4.2.2 声明指针 125
4.2.3 使用指针 126
4.2.4 初始化指针 127
4.2.5 sizeof操作符 132
4.2.6 常量指针和指向常量的指针 134
4.2.7 指针和数组 136
4.3 动态内存分配 142
4.3.1 堆的别名——空闲存储器 142
4.3.2 new和delete操作符 142
4.3.3 为数组动态分配内存 143
4.3.4 多维数组的动态分配 146
4.4 使用引用 146
4.4.1 引用的概念 147
4.4.2 声明并初始化lvalue引用 147
4.4.3 在基于范围的for循环中使用引用 148
4.4.4 rvalue引用 148
4.5 字符串的库函数 149
4.5.1 确定以空字符结尾的字符串的长度 149
4.5.2 连接以空字符结尾的字符串 150
4.5.3 复制以空字符结尾的字符串 151
4.5.4 比较以空字符结尾的字符串 152
4.5.5 搜索以空字符结尾的字符串 152
4.6 小结 154
4.7 练习 155
4.8 本章主要内容 155

第5章 程序结构(1) 157

5.1 理解函数 157
5.1.1 需要函数的原因 158
5.1.2 函数的结构 158
5.1.3 替代的函数语法 161
5.1.4 使用函数 161
5.2 给函数传递实参 164
5.2.1 按值传递机制 165
5.2.2 给函数传递指针实参 166
5.2.3 给函数传递数组 167
5.2.4 给函数传递引用实参 171
5.2.5 使用const修饰符 173
5.2.6 rvalue引用形参 174
5.2.7 main()函数的实参 176
5.2.8 接受数量不定的函数实参 177
5.3 从函数返回值 179
5.3.1 返回指针 179
5.3.2 返回引用 182
5.3.3 函数中的静态变量 184
5.4 递归函数调用 186
5.5 小结 189
5.6 练习 189
5.7 本章主要内容 189

第6章 程序结构(2) 191

6.1 函数指针 191
6.1.1 声明函数指针 191
6.1.2 函数指针作为实参 194
6.1.3 函数指针的数组 196
6.2 初始化函数形参 196
6.3 异常 198
6.3.1 抛出异常 199
6.3.2 捕获异常 200
6.3.3 重新抛出异常 201
6.3.4 MFC中的异常处理 202
6.4 处理内存分配错误 203
6.5 函数重载 204
6.5.1 函数重载的概念 204
6.5.2 引用类型和重载选择 207
6.5.3 何时重载函数 207
6.6 函数模板 208
6.7 使用decltype操作符 210
6.8 使用函数的示例 212
6.8.1 实现计算器 212
6.8.2 从字符串中删除空格 215
6.8.3 计算表达式的值 216
6.8.4 获得项值 218
6.8.5 分析数 219
6.8.6 整合程序 221
6.8.7 扩展程序 223
6.8.8 提取子字符串 224
6.8.9 运行修改过的程序 226
6.9 小结 227
6.10 练习 227
6.11 本章主要内容 228

第7章 自定义数据类型 229

7.1 C++中的结构 229
7.1.1 结构的概念 230
7.1.2 定义结构 230
7.1.3 初始化结构 230
7.1.4 访问结构的成员 231
7.1.5 伴随结构的智能感知帮助 234
7.1.6 RECT结构 235
7.1.7 使用指针处理结构 236
7.2 数据类型、对象、类和实例 237
7.2.1 类的起源 239
7.2.2 类的操作 239
7.2.3 术语 240
7.3 理解类 240
7.3.1 定义类 240
7.3.2 声明类的对象 241
7.3.3 访问类的数据成员 241
7.3.4 类的成员函数 243
7.3.5 成员函数定义的位置 245
7.3.6 内联函数 245
7.4 类构造函数 246
7.4.1 构造函数的概念 247
7.4.2 默认的构造函数 248
7.4.3 默认的形参值 250
7.4.4 在构造函数中使用初始化列表 252
7.4.5 声明显式的构造函数 253
7.5 类的私有成员 254
7.5.1 访问私有类成员 256
7.5.2 类的友元函数 257
7.5.3 默认复制构造函数 259
7.6 this指针 260
7.7 类的const对象 263
7.7.1 类的const成员函数 263
7.7.2 类外部的成员函数定义 264
7.8 类对象的数组 265
7.9 类的静态成员 267
7.9.1 类的静态数据成员 267
7.9.2 类的静态函数成员 270
7.10 类对象的指针和引用 270
7.10.1 类对象的指针 270
7.10.2 类对象的引用 273
7.11 小结 274
7.12 练习 274
7.13 本章主要内容 275

第8章 深入理解类 277

8.1 类析构函数 277
8.1.1 析构函数的概念 277
8.1.2 默认的析构函数 278
8.1.3 析构函数与动态内存分配 280
8.2 实现复制构造函数 283
8.3 在变量之间共享内存 284
8.3.1 定义联合 285
8.3.2 匿名联合 286
8.3.3 类和结构中的联合 286
8.4 运算符重载 287
8.4.1 实现重载的运算符 287
8.4.2 实现对比较运算符的完全支持 290
8.4.3 重载赋值运算符 294
8.4.4 重载加法运算符 299
8.4.5 重载递增和递减运算符 303
8.4.6 重载函数调用操作符 304
8.5 对象复制问题 305
8.5.1 避免不必要的复制操作 305
8.5.2 应用rvalue引用形参 308
8.5.3 命名的对象是lvalue 310
8.6 默认的类成员 314
8.7 类模板 315
8.7.1 定义类模板 316
8.7.2 根据类模板创建对象 318
8.7.3 使用有多个形参的类模板 321
8.7.4 函数对象模板 323
8.8 完美转发 324
8.9 使用类 327
8.9.1 类接口的概念 327
8.9.2 定义问题 327
8.9.3 实现CBox类 328
8.10 组织程序代码 343
8.11 字符串的库类 345
8.11.1 创建字符串对象 345
8.11.2 连接字符串 346
8.11.3 访问与修改字符串 350
8.11.4 比较字符串 353
8.11.5 搜索字符串 356
8.12 小结 364
8.13 练习 364
8.14 本章主要内容 365

第9章 类继承和虚函数 367

9.1 面向对象编程的基本思想 367
9.2 类的继承 368
9.2.1 基类的概念 369
9.2.2 基类的派生类 369
9.3 继承机制下的访问控制 372
9.3.1 派生类中构造函数的操作 375
9.3.2 声明类的保护成员 378
9.3.3 继承类成员的访问级别 380
9.4 派生类中的复制构造函数 382
9.5 禁止派生类 384
9.6 友元类成员 385
9.6.1 友元类 387
9.6.2 对类友元关系的限制 387
9.7 虚函数 387
9.7.1 虚函数的概念 389
9.7.2 确保虚函数的正确执行 391
9.7.3 禁止重写函数 391
9.7.4 使用指向类对象的指针 392
9.7.5 使用引用处理虚函数 393
9.7.6 纯虚函数 395
9.7.7 抽象类 395
9.7.8 间接基类 398
9.7.9 虚析构函数 400
9.8 类类型之间的强制转换 403
9.9 嵌套类 403
9.10 小结 407
9.11 练习 407
9.12 本章主要内容 409

第10章 标准模板库 411

10.1 标准模板库的定义 411
10.1.1 容器 412
10.1.2 容器适配器 414
10.1.3 迭代器 414
10.2 智能指针 415
10.3 算法 418
10.4 STL中的函数对象 418
10.5 STL容器范围 419
10.6 序列容器 419
10.6.1 创建矢量容器 420
10.6.2 矢量容器的容量和大小 423
10.6.3 访问矢量中的元素 428
10.6.4 在矢量中插入和删除元素 428
10.6.5 在矢量中存储类对象 431
10.6.6 排序矢量元素 436
10.6.7 排序矢量中的指针 437
10.6.8 双端队列容器 442
10.6.9 使用列表容器 445
10.6.10 使用forward_list容器 454
10.6.11 使用其他序列容器 456
10.6.12 tuple< >类模板 466
10.7 关联容器 469
10.7.1 使用映射容器 469
10.7.2 使用多重映射容器 480
10.8 关于迭代器的更多内容 481
10.8.1 使用输入流迭代器 481
10.8.2 使用插入迭代器 484
10.8.3 使用输出流迭代器 485
10.9 关于函数对象的更多内容 487
10.10 关于算法的更多内容 488
10.10.1 fill() 489
10.10.2 replace() 489
10.10.3 find() 489
10.10.4 transform() 490
10.11 类型特质和静态断言 491
10.12 λ表达式 492
10.12.1 capture子句 493
10.12.2 捕获特定的变量 494
10.12.3 模板和λ表达式 494
10.12.4 包装λ表达式 498
10.13 小结 500
10.14 练习 500
10.15 本章主要内容 501


第11章 Windows编程的概念 503

11.1 Windows编程基础 503
11.1.1 窗口的元素 504
11.1.2 Windows程序与操作系统 505
11.1.3 事件驱动型程序 505
11.1.4 Windows消息 506
11.1.5 Windows API 506
11.1.6 Windows数据类型 506
11.1.7 Windows程序中的符号 507
11.2 Windows程序的结构 508
11.2.1 WinMain()函数 509
11.2.2 消息处理函数 519
11.3 MFC 524
11.3.1 MFC表示法 524
11.3.2 MFC程序的组织方式 525
11.4 小结 528
11.5 本章主要内容 528

第12章 使用MFC编写Windows程序 531

12.1 MFC的文档/视图概念 531
12.1.1 文档的概念 531
12.1.2 文档界面 532
12.1.3 视图的概念 532
12.1.4 链接文档和视图 533
12.1.5 应用程序和MFC 534
12.2 创建MFC应用程序 535
12.2.1 创建SDI应用程序 536
12.2.2 MFC Application Wizard的输出 539
12.2.3 创建MDI应用程序 548
12.3 小结 549
12.4 练习 550
12.5 本章主要内容0 550

第13章 处理菜单和工具栏 551

13.1 与Windows进行通信 551
13.1.1 了解消息映射 552
13.1.2 消息类别 554
13.1.3 处理程序中的消息 554
13.2 扩展Sketcher程序 555
13.3 菜单的元素 556
13.4 为菜单消息添加处理程序 559
13.4.1 选择处理菜单消息的类 560
13.4.2 创建菜单消息函数 560
13.4.3 编写菜单消息函数的代码 562
13.4.4 添加更新菜单消息的处理程序 565
13.5 添加工具栏按钮 568
13.5.1 编辑工具栏按钮的属性 569
13.5.2 练习使用工具栏按钮 570
13.5.3 添加工具提示 571
13.6 小结 571
13.7 练习 571
13.8 本章主要内容 571

第14章 在窗口中绘图 573

14.1 窗口绘图的基础知识 573
14.1.1 窗口工作区 573
14.1.2 Windows图形设备界面 574
14.2 MFC的绘图机制 576
14.2.1 应用程序中的视图类 576
14.2.2 CDC类 577
14.3 实际绘制图形 585
14.4 对鼠标进行编程 587
14.4.1 鼠标发出的消息 587
14.4.2 鼠标消息处理程序 588
14.4.3 使用鼠标绘图 590
14.5 绘制草图 611
14.5.1 运行示例 612
14.5.2 捕获鼠标消息 612
14.6 小结 613
14.7 练习题 613
14.8 本章主要内容 614

第15章 改进视图 615

15.1 Sketcher应用程序的缺陷 615
15.2 改进视图 616
15.2.1 更新多个视图 616
15.2.2 滚动视图 617
15.2.3 使用MM_LOENGLISH映射模式 622
15.3 删除和移动元素 622
15.4 实现上下文菜单 623
15.4.1 关联菜单和类 624
15.4.2 选中上下文菜单项 625
15.5 标识位于光标下的元素 626
15.5.1 练习弹出菜单 627
15.5.2 突出显示元素 627
15.5.3 实现移动和删除功能 631
15.6 处理屏蔽的元素 637
15.7 小结 639
15.8 练习 639
15.9 本章主要内容 639

第16章 使用对话框和控件 641

16.1 理解对话框 641
16.2 理解控件 642
16.3 创建对话框资源 642
16.3.1 给对话框添加控件 643
16.3.2 测试对话框 644
16.4 对话框的编程 644
16.4.1 添加对话框类 644
16.4.2 模态和非模态对话框 645
16.4.3 显示对话框 646
16.5 支持对话框控件 648
16.5.1 初始化对话框控件 648
16.5.2 处理单选按钮消息 649
16.6 完成对话框的操作 650
16.6.1 给文档添加线宽 651
16.6.2 给元素添加线宽 651
16.6.3 在视图中创建元素 653
16.6.4 练习使用对话框 654
16.7 使用微调按钮控件 655
16.7.1 添加Scale菜单项和工具栏按钮 655
16.7.2 创建微调按钮 655
16.7.3 生成比例对话框类 656
16.7.4 显示微调按钮 659
16.8 使用缩放比例 660
16.8.1 可缩放的映射模式 660
16.8.2 设置文档的大小 661
16.8.3 设置映射模式 662
16.8.4 同时实现滚动与缩放 663
16.9 使用状态栏 665
16.9.1 给框架窗口添加状态栏 665
16.9.2 CString类 669
16.10 使用编辑框控件 669
16.10.1 创建编辑框资源 670
16.10.2 创建对话框类 671
16.10.3 添加Text菜单项 672
16.10.4 定义文本元素 672
16.10.5 实现CText类 673
16.11 小结 677
16.12 练习 678
16.13 本章主要内容 678

第17章 存储和打印文档 679

17.1 了解序列化 679
17.2 序列化文档 680
17.2.1 文档类定义中的序列化 680
17.2.2 文档类实现中的序列化 681
17.2.3 基于CObject的类的功能 683
17.2.4 序列化的工作方式 684
17.2.5 如何实现类的序列化 685
17.3 应用序列化 685
17.3.1 记录文档修改 686
17.3.2 序列化文档 687
17.3.3 序列化元素类 689
17.4 练习序列化 693
17.5 打印文档 694
17.6 实现多页打印 697
17.6.1 获取文档的总尺寸 698
17.6.2 存储打印数据 698
17.6.3 准备打印 699
17.6.4 打印后的清除 700
17.6.5 准备设备上下文 701
17.6.6 打印文档 701
17.6.7 获得文档的打印输出 705
17.7 小结 705
17.8 练习 705
17.9 本章主要内容 706


第18章 编写Windows 8应用程序 707

18.1 理解Windows 8应用程序 707
18.2 开发WINDOWS 8应用程序 708

18.3 Windows Runtime的概念 709
18.3.1 WinRT名称空间 709
18.3.2 WinRT对象 709

18.4 C++ COMPONENT EXTENSIONS(C++/CX) 710
18.4.1 C++/CX名称空间 710
18.4.2 定义WinRT类类型 711
18.4.3 Ref类类型的变量 713
18.4.4 访问ref类对象的成员 713
18.4.5 事件处理函数 714
18.4.6 转换ref类引用的类型 714

18.5 XAML 714
18.5.1 XAML元素 715
18.5.2 XAML中的UI元素 716
18.5.3 附加属性 719
18.5.4 父元素和子元素 719
18.5.5 控件元素 719
18.5.6 布局元素 720
18.5.7 处理UI元素的事件 720

18.6 创建Windows 8应用程序 721
18.6.1 应用程序文件 721
18.6.2 定义用户界面 722
18.6.3 创建标题 724
18.6.4 添加游戏控件 726
18.6.5 创建包含纸牌的网格 727
18.6.6 实现游戏的操作 732
18.6.7 初始化MainPage对象 735
18.6.8 初始化一副纸牌 736
18.6.9 建立cardGrid的子元素 736
18.6.10 初始化游戏 738
18.6.11 洗牌 740
18.6.12 突出显示UI纸牌 741
18.6.13 处理翻牌事件 741
18.6.14 处理图形事件 743
18.6.15 确认赢家 745
18.6.16 处理游戏控件的按钮事件 746

18.7 缩放UI元素 747

18.8 平移 749
18.8.1 应用程序的启动动画 749
18.8.2 故事板动画 750

18.9 小结 752
18.10 本章主要内容 752

