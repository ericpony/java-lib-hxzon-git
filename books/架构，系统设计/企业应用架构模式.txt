企业应用架构模式
~ 福勒(Martin Fowler) (作者), UML China (合著者), 王怀民 (译者), 周斌 (译者)
============
出版社: 机械工业出版社; 第1版 (2010年4月1日)
外文书名: Patterns of Enterprise Application Architecture
丛书名: 经典重读
平装: 363页
语种： 简体中文
开本: 16
ISBN: 9787111303930, 7111303938
----
编辑推荐

《企业应用架构模式》：
企业应用开发的实践得益于多种新技术的出现，多层的面向对象平台（如Java、.NET）已经日渐平常。这些新工具和新技术有能力构建更强大的企业应用程序，但是在实现上还不太容易。由于开发人员未能充分理解有经验的对象程序开发人员在架构方面的经验和教训.因此企业应用中经常存在一些共同的错误。

《企业应用架构模式》就是面向企业应用开发者的，可帮助他们迎接这种艰难挑战。《企业应用架构模式》的作者Martin Fowler注意到，尽管技术本身存在变化——从Smalltalk到CORBA，再到。Java和NET，但基本的设计思想并没有太多变化.可以加以适当调整，用来解决那些共同的问题。在一组专家级合作者的帮助下，作者将40多种经常出现的解决方案转化成模式，最终写成这本能够应用于任何一种企业应用平台的、关于解决方案的、不可或缺的手册。《企业应用架构模式》曾于2002年荣获美国软件开发杂志图书类的生产效率奖和读者选择奖。

《企业应用架构模式》涉及两部分内容。第一部分是关于如何开发企业应用的简单介绍。在阅读这部分时读者可以从头到尾通读，以掌握《企业应用架构模式》的范围。第二部分是《企业应用架构模式》的主体，是关于模式的详细参考手册。每个模式都给出使用方法和实现信息，并配有详细的Java代码或C#代码的示例。此外，整《企业应用架构模式》中还用了大量UML图来进一步阐明有关概念。

《企业应用架构模式》主要内容：

将企业应用分层
组织企业业务逻辑的主要方法
在对象和关系数据库之间进行映射的深层次解决方案
通过模型一视图一控制器来组织Web表现
处理跨多事务的数据的并发问题
设计分布式对象接口
----
作者简介

福勒（Martin Fower），是一位独立咨询顾问，他运用对象技术解决企业问题已经超过十年。他的顾问领域包括健康管理、金融贸易，以及法人财务。他的客户包括Chrysler，Citibank，UK National Health Service，AndersenConsulting，NetscapeCommunications。此外Fowler也是objects、UML、patterns技术的一位合格讲师，他是《Analysis Patterns》和《UML Distilled》的作者。
============
目录

译者序
前言
模式列表

引言 1


第一部分 表述

第1章 分层 12


第2章 组织领域逻辑 19

第3章 映射到关系数据库 25
3.1 架构模式 25
3.2 行为问题 28
3.3 读取数据 29
3.4 结构映射模式 30
3.4.1 关系的映射 30
3.4.2 继承 33
3.5 建立映射 34
3.6 使用元数据 35
3.7 数据库连接 36

第4章 Web表现层 39
4.1 视图模式 41
4.2 输入控制器模式 43


第5章 并发 45


第6章 会话状态 57
6.1 无状态的价值 57
6.2 会话状态 58
6.3 存储会话状态的方法 59

第7章 分布策略 61
7.1 分布对象的诱惑 61
7.2 远程接口和本地接口 62
7.3 必须使用分布的情况 63
7.4 关于分布边界 64
7.5 分布接口 64

第8章 通盘考虑 67
8.1 从领域层开始 67
8.2 深入到数据源层 68
8.3 表现层 69
8.4 一些关于具体技术的建议 70
8.4.1 Java和J2EE 70
8.4.2 .NET 71
8.4.3 存储过程 71
8.4.4 Web Services 72
8.5 其他分层方式 72

第二部分 模 式

第9章 领域逻辑模式 76
9.1 事务脚本（Transaction Script） 76
9.2 领域模型（Domain Model） 81
9.3 表模块（Table Module） 87
9.4 服务层（Service Layer） 93

第10章 数据源架构模式 101
10.1 表数据入口（Table Data Gateway） 101
10.2 行数据入口（Row Data Gateway） 106
10.3 活动记录（Active Record） 112
10.4 数据映射器（Data Mapper） 115

第11章 对象－关系行为模式 129
11.1 工作单元（Unit of Work） 129
11.2 标识映射（Identity Map） 137
11.3 延迟加载（Lazy Load） 140

第12章 对象－关系结构模式 151
12.1 标识域（Identity Field） 151
12.2 外键映射（Foreign Key Mapping） 166
12.3 关联表映射（Association Table Mapping） 175
12.4 依赖映射（Dependent Mapping） 186
12.5 嵌入值（Embedded Value） 190
12.6 序列化LOB（Serialized LOB） 192
12.7 单表继承（Single Table Inheritance） 196
12.8 类表继承（Class Table Inheritance） 202
12.9 具体表继承（Concrete Table Inheritance） 208
12.10 继承映射器（Inheritance Mappers） 214

第13章 对象－关系元数据映射模式 217
13.1 元数据映射（Metadata Mapping） 217
13.2 查询对象（Query Object） 224
13.3 资源库（Repository） 228

第14章 Web表现模式 233
14.1 模型－视图－控制器（Model View Controller） 233
14.2 页面控制器（Page Controller） 235
14.3 前端控制器（Front Controller） 243
14.4 模板视图（Template View） 248
14.5 转换视图（Transform View） 256
14.6 两步视图（Two Step View） 259
14.7 应用控制器（Application Controller） 269

第15章 分布模式 275
15.1 远程外观（Remote Facade） 275
15.2 数据传输对象（Data Transfer Object） 285

第16章 离线并发模式 295
16.1 乐观离线锁（Optimistic Offline Lock） 295
16.2 悲观离线锁（Pessimistic Offline Lock） 302
16.3 粗粒度锁（Coarse-Grained Lock） 310
16.4 隐含锁（Implicit Lock） 318

第17章 会话状态模式 321
17.1 客户会话状态（Client Session State） 321
17.2 服务器会话状态（Server Session State） 322
17.3 数据库会话状态（Database Session State） 324

第18章 基本模式 327
18.1 入口（Gateway） 327
18.2 映射器（Mapper） 331
18.3 层超类型（Layer Supertype） 332
18.4 分离接口（Separated Interface） 333
18.5 注册表（Registry） 335
18.6 值对象（Value Object） 339
18.7 货币（Money） 340
18.8 特殊情况（Special Case） 346
18.9 插件（Plugin） 348
18.10 服务桩（Service Stub） 352
18.11 记录集（Record Set） 355

参考文献 359
===========
目录

译者序
前言
模式列表

引言 1
0.1 架构 1
0.2 企业应用 2
0.3 企业应用的种类 3
0.4 关于性能的考虑 4
0.5 模式 6
0.5.1 模式的结构 7
0.5.2 模式的局限性 9

第一部分 表述

第1章 分层 12
1.1 企业应用中层次的演化 13
1.2 三个基本层次 14
1.3 为各层选择运行环境 15

第2章 组织领域逻辑 19
2.1 抉择 22
2.2 服务层 23

第3章 映射到关系数据库 25
3.1 架构模式 25
3.2 行为问题 28
3.3 读取数据 29
3.4 结构映射模式 30
3.4.1 关系的映射 30
3.4.2 继承 33
3.5 建立映射 34
3.6 使用元数据 35
3.7 数据库连接 36
3.8 其他问题 38
3.9 进一步阅读 38

第4章 Web表现层 39
4.1 视图模式 41
4.2 输入控制器模式 43
4.3 进一步阅读 43

第5章 并发 45
5.1 并发问题 45
5.2 执行语境 46
5.3 隔离与不变性 47
5.4 乐观并发控制和悲观并发控制 48
5.4.1 避免不一致读 49
5.4.2 死锁 49
5.5 事务 50
5.5.1 ACID 51
5.5.2 事务资源 51
5.5.3 减少事务隔离以提高灵活性 52
5.5.4 业务事务和系统事务 53
5.6 离线并发控制的模式 54
5.7 应用服务器并发 55
5.8 进一步阅读 56

第6章 会话状态 57
6.1 无状态的价值 57
6.2 会话状态 58
6.3 存储会话状态的方法 59

第7章 分布策略 61
7.1 分布对象的诱惑 61
7.2 远程接口和本地接口 62
7.3 必须使用分布的情况 63
7.4 关于分布边界 64
7.5 分布接口 64

第8章 通盘考虑 67
8.1 从领域层开始 67
8.2 深入到数据源层 68
8.2.1 事务脚本的数据源 68
8.2.2 表模块的数据源 69
8.2.3 领域模型的数据源 69
8.3 表现层 69
8.4 一些关于具体技术的建议 70
8.4.1 Java和J2EE 70
8.4.2 .NET 71
8.4.3 存储过程 71
8.4.4 Web Services 72
8.5 其他分层方式 72

第二部分 模 式

第9章 领域逻辑模式 76
9.1 事务脚本（Transaction Script） 76
9.1.1 运行机制 76
9.1.2 使用时机 77
9.1.3 收入确认问题 78
9.1.4 例：收入确认（Java） 78
9.2 领域模型（Domain Model） 81
9.2.1 运行机制 81
9.2.2 使用时机 83
9.2.3 进一步阅读 83
9.2.4 例：收入确认（Java） 84
9.3 表模块（Table Module） 87
9.3.1 运行机制 88
9.3.2 使用时机 90
9.3.3 例：基于表模块的收入确认（C#） 90
9.4 服务层（Service Layer） 93
9.4.1 运行机制 94
9.4.2 使用时机 96
9.4.3 进一步阅读 96
9.4.4 例：收入确认（Java） 96

第10章 数据源架构模式 101
10.1 表数据入口（Table Data Gateway） 101
10.1.1 运行机制 101
10.1.2 使用时机 102
10.1.3 进一步阅读 102
10.1.4 例：人员入口（C#） 103
10.1.5 例：使用ADO.NET数据集（C#） 104
10.2 行数据入口（Row Data Gateway） 106
10.2.1 运行机制 107
10.2.2 使用时机 108
10.2.3 例：人员记录（Java） 108
10.2.4 例：领域对象的数据保持器（Java） 111
10.3 活动记录（Active Record） 112
10.3.1 运行机制 112
10.3.2 使用时机 113
10.3.3 例：一个简单的Person类（Java） 113
10.4 数据映射器（Data Mapper） 115
10.4.1 运行机制 116
10.4.2 使用时机 119
10.4.3 例：一个简单的数据映射器（Java） 119
10.4.4 例：分离查找方法（Java） 123
10.4.5 例：创建一个空对象（Java） 126

第11章 对象－关系行为模式 129
11.1 工作单元（Unit of Work） 129
11.1.1 运行机制 129
11.1.2 使用时机 133
11.1.3 例：使用对象注册的工作单元（Java） 134
11.2 标识映射（Identity Map） 137
11.2.1 运行机制 137
11.2.2 使用时机 139
11.2.3 例：标识映射中的方法（Java） 139
11.3 延迟加载（Lazy Load） 140
11.3.1 运作机制 140
11.3.2 使用时机 142
11.3.3 例：延迟初始化（Java） 142
11.3.4 例：虚代理（Java） 142
11.3.5 例：使用值保持器（Java） 144
11.3.6 例：使用重影（C#） 144

第12章 对象－关系结构模式 151
12.1 标识域（Identity Field） 151
12.1.1 工作机制 151
12.1.2 使用时机 154
12.1.3 进一步阅读 154
12.1.4 例：整型键（C#） 154
12.1.5 例：使用键表（Java） 155
12.1.6 例：使用组合键（Java） 157
12.2 外键映射（Foreign Key Mapping） 166
12.2.1 运行机制 167
12.2.2 使用时机 169
12.2.3 例：单值引用（Java） 169
12.2.4 例：多表查询（Java） 172
12.2.5 例：引用集合（C#） 173
12.3 关联表映射（Association Table Mapping） 175
12.3.1 运行机制 176
12.3.2 使用时机 176
12.3.3 例：雇员和技能（C#） 177
12.3.4 例：使用直接的SQL（Java） 179
12.3.5 例：用一次查询查多个雇员（Java） 182
12.4 依赖映射（Dependent Mapping） 186
12.4.1 运行机制 186
12.4.2 使用时机 187
12.4.3 例：唱片和曲目（Java） 188
12.5 嵌入值（Embedded Value） 190
12.5.1 运行机制 190
12.5.2 使用时机 190
12.5.3 进一步阅读 191
12.5.4 例：简单值对象（Java） 191
12.6 序列化LOB（Serialized LOB） 192
12.6.1 运行机制 193
12.6.2 使用时机 194
12.6.3 例：在XML中序列化一个部门层级（Java） 194
12.7 单表继承（Single Table Inheritance） 196
12.7.1 运行机制 197
12.7.2 使用时机 197
12.7.3 例：运动员的单表（C#） 198
12.7.4 从数据库中加载对象 199
12.8 类表继承（Class Table Inheritance） 202
12.8.1 运行机制 202
12.8.2 使用时机 203
12.8.3 进一步阅读 203
12.8.4 例：运动员和他们的家属（C#） 203
12.9 具体表继承（Concrete Table Inheritance） 208
12.9.1 运行机制 209
12.9.2 使用时机 210
12.9.3 例：具体运动员（C#） 210
12.10 继承映射器（Inheritance Mappers） 214
12.10.1 运行机制 215
12.10.2 使用时机 216

第13章 对象－关系元数据映射模式 217
13.1 元数据映射（Metadata Mapping） 217
13.1.1 运行机制 217
13.1.2 使用时机 218
13.1.3 例：使用元数据和反射（Java） 219
13.2 查询对象（Query Object） 224
13.2.1 运行机制 225
13.2.2 使用时机 225
13.2.3 进一步阅读 226
13.2.4 例：简单的查询对象（Java） 226
13.3 资源库（Repository） 228
13.3.1 运行机制 229
13.3.2 使用时机 230
13.3.3 进一步阅读 231
13.3.4 例：查找一个人所在的部门（Java） 231
13.3.5 例：资源库交换策略（Java） 231

第14章 Web表现模式 233
14.1 模型－视图－控制器（Model View Controller） 233
14.1.1 运行机制 233
14.1.2 使用时机 234
14.2 页面控制器（Page Controller） 235
14.2.1 运行机制 235
14.2.2 使用时机 236
14.2.3 例：Servlet控制器和JSP视图的简单演示（Java） 236
14.2.4 例：使用JSP充当处理程序（Java） 238
14.2.5 例：代码隐藏的页面控制器（C#） 241
14.3 前端控制器（Front Controller） 243
14.3.1 运行机制 244
14.3.2 使用时机 245
14.3.3 进一步阅读 246
14.3.4 例：简单的显示（Java） 246
14.4 模板视图（Template View） 248
14.4.1 运行机制 249
14.4.2 使用时机 251
14.4.3 例：分离的控制器，使用JSP充当视图（Java） 252
14.4.4 例：ASP.NET服务器页面（C#） 253
14.5 转换视图（Transform View） 256
14.5.1 运行机制 256
14.5.2 使用时机 257
14.5.3 例：简单的转换（Java） 257
14.6 两步视图（Two Step View） 259
14.6.1 运行机制 259
14.6.2 使用时机 260
14.6.3 例：两阶XSLT（XSLT） 264
14.6.4 例：JSP和定制标记（Java） 266
14.7 应用控制器（Application Controller） 269
14.7.1 运行机制 270
14.7.2 使用时机 271
14.7.3 进一步阅读 271
14.7.4 例：状态模型应用控制器（Java） 271

第15章 分布模式 275
15.1 远程外观（Remote Facade） 275
15.1.1 运行机制 276
15.1.2 使用时机 278
15.1.3 例：使用Java语言的会话bean来作为远程外观（Java） 278
15.1.4 例：Web Service（C#） 281
15.2 数据传输对象（Data Transfer Object） 285
15.2.1 运行机制 285
15.2.2 使用时机 288
15.2.3 进一步阅读 289
15.2.4 例：传输唱片信息（Java） 289
15.2.5 例：使用XML实现序列化（Java） 293

第16章 离线并发模式 295
16.1 乐观离线锁（Optimistic Offline Lock） 295
16.1.1 运行机制 296
16.1.2 使用时机 298
16.1.3 例：领域层与数据映射器（Java） 298
16.2 悲观离线锁（Pessimistic Offline Lock） 302
16.2.1 运行机制 303
16.2.2 使用时机 305
16.2.3 例：简单锁管理对象（Java） 305
16.3 粗粒度锁（Coarse-Grained Lock） 310
16.3.1 运行机制 310
16.3.2 使用时机 312
16.3.3 例：共享的乐观离线锁（Java） 312
16.3.4 例：共享的悲观离线锁（Java） 316
16.3.5 例：根对象乐观离线锁（Java） 317
16.4 隐含锁（Implicit Lock） 318
16.4.1 运行机制 318
16.4.2 使用时机 319
16.4.3 例：隐含的悲观离线锁（Java） 319

第17章 会话状态模式 321
17.1 客户会话状态（Client Session State） 321
17.1.1 运行机制 321
17.1.2 使用时机 322
17.2 服务器会话状态（Server Session State） 322
17.2.1 运行机制 322
17.2.2 使用时机 324
17.3 数据库会话状态（Database Session State） 324
17.3.1 运行机制 324
17.3.2 使用时机 325

第18章 基本模式 327
18.1 入口（Gateway） 327
18.1.1 运行机制 327
18.1.2 使用时机 328
18.1.3 例：私有消息服务的入口（Java） 329
18.2 映射器（Mapper） 331
18.2.1 运行机制 332
18.2.2 使用时机 332
18.3 层超类型（Layer Supertype） 332
18.3.1 运行机制 332
18.3.2 使用时机 333
18.3.3 例：领域对象（Java） 333
18.4 分离接口（Separated Interface） 333
18.4.1 运行机制 334
18.4.2 使用时机 335
18.5 注册表（Registry） 335
18.5.1 运行机制 336
18.5.2 使用时机 337
18.5.3 例：单子注册表（Java） 337
18.5.4 例：线程安全的注册表（Java） 338
18.6 值对象（Value Object） 339
18.6.1 运行机制 339
18.6.2 使用时机 340
18.7 货币（Money） 340
18.7.1 运行机制 341
18.7.2 使用时机 342
18.7.3 例：货币类（Java） 343
18.8 特殊情况（Special Case） 346
18.8.1 运行机制 347
18.8.2 使用时机 347
18.8.3 进一步阅读 347
18.8.4 例：一个简单的空对象（C#） 347
18.9 插件（Plugin） 348
18.9.1 运行机制 349
18.9.2 使用时机 350
18.9.3 例：ID生成器（Java） 350
18.10 服务桩（Service Stub） 352
18.10.1 运行机制 352
18.10.2 使用时机 353
18.10.3 例：销售税服务（Java） 353
18.11 记录集（Record Set） 355
18.11.1 运行机制 355
18.11.2 使用时机 356
参考文献 359


