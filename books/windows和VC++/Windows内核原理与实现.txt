Windows内核原理与实现

潘爱民
76.30(7.7折)

==========
出版社: 电子工业; 第1版 (2013年5月1日)
平装: 716页
语种： 简体中文
开本: 16
ISBN: 7121200562
条形码: 9787121200564

==========
编辑推荐

潘爱民编著的《Windows内核原理与实现》从操作系统原理角度组织材料，深度解析了Windows内核如何实现现代操作系统的各个关键部件，并直接以Windows核源代码(WRK， Windows Research Kernel)为参照。
在内容选取方面，侧重Windows核中基本的系统部件，同时也兼顾作为一个操作系统的完整性。
在讲解代码实现的同时并未局限于代码本身，而是着重阐述了Windows内核中运用的算法和机制。


作者简介

潘爱民，任职于阿里云计算有限公司，担任阿里云0S首席架构师。长期从事软件和系统技术的研究与开发工作，撰写了大量软件技术文章，
著译了多部经典计算机图书，在国内外学术刊物上发表了30多篇文章。
曾经任教于北京大学和清华大学(兼职)。后进入工业界，先后任职于微软亚洲研究院、盛大网络发展有限公司和阿里云计算有限公司。
目前也是工信部移动操作系统专家组成员。

潘爱民先生获得了数学学士学位和计算机科学博士学位，主要研究领域包括软件设计、信息安全、操作系统和互联网技术。


=============
目录

第1章 概述 1
第2章 Windows系统总述 17

第3章 Windows进程和线程 99
第4章 Windows内存管理 175
第5章 Windows中的并发和同步 295
第6章 Windows I/O系统 381
第7章 Windows存储管理 469
第8章 Windows系统服务 541

第9章 Windows内核高级话题 587

附录A 建立编译和调试WRK环境 641

A.1 编译WRK 641
A.2 启动WRK 645
A.3 调试WRK 648

附录B 内核代码插入工具KInjectToolKit 657

B.1 KInjectToolKit功能介绍 658
B.2 KInjectToolKit的代码实现 659
B.3 KInjectToolKit的限制 663

============
目录


第1章 概述 1

1.1 操作系统基础 2
1.1.1 计算机系统的硬件资源管理 2
1.1.2 为应用程序提供执行环境 5
1.2 学习操作系统之必备知识 7
1.3 Windows操作系统发展历史 9
1.4 Windows内核的版本 11
1.5 操作系统的研究与发展 13
1.6 本章总结 16


第2章 Windows系统总述 17

2.1 现代操作系统的基本结构 17
2.2 Windows系统结构 18
2.2.1 Windows内核结构 20
2.2.2 Windows内核中的关键组件 22
2.2.3 Windows子系统 29
2.2.4 系统线程和系统进程 32

2.3 关于Windows研究内核 34
2.3.1 WRK包含了什么 35
2.3.2 WRK源代码说明 36
2.3.3 本书对WRK源代码的引用 38

2.4 Windows内核的基本概念 39
2.4.1 处理器模式 40
2.4.2 内存管理 41
2.4.3 进程和线程管理 43
2.4.4 中断和异常 45
2.4.5 同步 48

2.5 Windows内核中的公共管理设施 50
2.5.1 Windows内核中的对象管理 50
2.5.2 注册表和配置管理器 58
2.5.3 事件追踪（ETW） 69
2.5.4 安全性管理 72

2.6 Windows引导过程 79
2.6.1 内核加载 79
2.6.2 内核初始化 86
2.6.3 建立用户登录会话 91
2.7 本章总结 97


第3章 Windows进程和线程 99

3.1 进程基本概念 99
3.1.1 多进程模型 99
3.1.2 进程和程序 101

3.2 线程基本概念 104
3.2.1 线程模型 104
3.2.2 线程调度算法 106
3.2.3 线程和进程的关系 108

3.3 Windows中进程和线程数据结构 108
3.3.1 内核层的进程和线程对象 108
3.3.2 执行体层的进程和线程对象 120

3.4 Windows的进程和线程管理 131
3.4.1 Windows进程中的句柄表 131
3.4.2 获得当前线程和进程 136
3.4.3 进程和线程的创建过程 137
3.4.4 进程和线程的结束 147
3.4.5 系统初始进程和线程 149

3.5 Windows中的线程调度 151
3.5.1 线程优先级 152
3.5.2 线程状态转移 154
3.5.3 时限管理 164
3.5.4 优先级调度和环境切换 166

3.6 进程和线程状态监视工具 172
3.6.1 ProcMon使用示例 172
3.6.2 ProcMon实现原理 174
3.7 本章总结 174


第4章 Windows内存管理 175

4.1 内存管理概述 176
4.1.1 页式内存管理 177
4.1.2 段式内存管理 181
4.1.3 内存管理算法介绍 184
4.1.4 Windows内存管理概述 192

4.2 Windows系统内存管理 194
4.2.1 系统地址空间初始化 194
4.2.2 系统地址空间内存管理 209
4.2.3 系统PTE区域的管理 224

4.3 进程虚拟内存管理 229
4.3.1 地址空间的创建和初始化 229
4.3.2 地址空间切换 234
4.3.3 虚拟地址空间的管理 235
4.3.4 内存区对象 241

4.4 内存页面交换 249
4.4.1 x86中的PTE 250
4.4.2 软件PTE：无效PTE和原型PTE 253
4.4.3 页面错误处理 257
4.4.4 Windows的写时复制 263

4.5 物理内存管理 265
4.5.1 PFN数据库 265
4.5.2 物理页面的状态变化 270
4.5.3 物理页面链表的管理和操作 274
4.5.4 修改页面写出器 279
4.5.5 进程/栈交换器 281
4.5.6 低内存通知和高内存通知 284

4.6 工作集管理 285
4.6.1 Windows工作集管理器 285
4.6.2 平衡集管理器 291

4.7 内存监视工具Mem_Mon 292
4.7.1 Mem_Mon使用介绍 292
4.7.2 Mem_Mon实现原理 293
4.8 本章总结 294


第5章 Windows中的并发和同步 295

5.1 进程和线程同步基础 295
5.1.1 并发性基础 296
5.1.2 进程或线程之间的通讯 299
5.1.3 经典的同步问题 303

5.2 Windows中断与异常 308
5.2.1 硬件中断的发生和处理 308
5.2.2 中断请求级别（IRQL） 314
5.2.3 中断对象 317
5.2.4 DPC（延迟过程调用） 320
5.2.5 时钟中断和定时器管理 324
5.2.6 APC（异步过程调用） 328
5.2.7 异常分发 333

5.3 不依赖于线程调度的同步机制 340
5.3.1 提升IRQL实现数据同步 340
5.3.2 互锁操作 342
5.3.3 无锁的单链表实现 343
5.3.4 自旋锁 345

5.4 基于线程调度的同步机制 351
5.4.1 线程进入等待 351
5.4.2 分发器对象 358
5.4.3 门等待 365
5.4.4 执行体资源（executive resource） 367
5.4.5 推锁（push lock） 370
5.4.6 死锁 375

5.5 使用工具DPerfLite 376
5.5.1 DPerfLite使用示例 376
5.5.2 DPerfLite实现原理 378
5.6 本章总结 379


第6章 Windows I/O系统 381

6.1 I/O概述 382
6.1.1 现代计算机系统的I/O 382
6.1.2 I/O软件技术 386
6.1.3 Windows的I/O系统结构 388

6.2 I/O管理器 390
6.2.1 驱动程序初始化 390
6.2.2 驱动程序对象和设备对象 397
6.2.3 文件对象 401
6.2.4 对象生命周期管理 405

6.3 即插即用管理器 406
6.3.1 即插即用的基本要求 407
6.3.2 Windows中驱动程序的即插即用支持 408
6.3.3 设备列举与设备树 409

6.4 电源管理器 411
6.4.1 电源管理概述 412
6.4.2 Windows中的电源管理 415

6.5 设备驱动程序 420
6.5.1 驱动程序分类 420
6.5.2 例子驱动程序toaster 423
6.5.3 驱动程序的代码结构 425
6.5.4 toaster设备的设备栈 430
6.5.5 过滤驱动程序的配置和加载 431
6.5.6 非即插即用驱动程序 435

6.6 I/O处理 437
6.6.1 I/O请求包（IRP） 438
6.6.2 针对独立设备对象的I/O处理 444
6.6.3 处理I/O请求过程中的事项 449
6.6.4 针对设备栈的I/O处理 459
6.6.5 I/O完成端口 463

6.7 I/O监视工具IRPMon 466
6.7.1 IRPMon使用介绍 466
6.7.2 IRPMon实现原理 467
6.8 本章总结 468


第7章 Windows存储管理 469

7.1 存储管理概述 469
7.1.1 硬件存储体系（Memory hierarchy） 470
7.1.2 Windows的存储管理结构 472

7.2 Windows缓存管理 474
7.2.1 Windows缓存空间的内存管理 474
7.2.2 缓存管理器的数据访问路径 481
7.2.3 直接使用缓存中的数据 484
7.2.4 缓存管理器的预读处理 491
7.2.5 缓存管理器的延迟写 494

7.3 Windows卷管理 497
7.3.1 Windows中存储栈结构 497
7.3.2 卷的挂载 501
7.3.3 卷与文件系统 504
7.3.4 文件对象的I/O处理 508

7.4 Windows文件系统 510
7.4.1 文件系统驱动程序结构 511
7.4.2 RAW文件系统和FsRtl 516
7.4.3 文件系统的过滤 520
7.4.4 FAT文件系统 527
7.4.5 NTFS文件系统 532
7.5 本章总结 540


第8章 Windows系统服务 541

8.1 Windows系统服务原理 541
8.1.1 Intel x86的用户模式-内核模式切换 541
8.1.2 Windows的用户模式-内核模式切换 546
8.1.3 Windows中的系统服务分发 550
8.1.4 增加系统服务表或表项 557

8.2 LPC（本地过程调用）服务 561
8.2.1 LPC结构模型 561
8.2.2 LPC端口和LPC消息 563
8.2.3 LPC通讯模型的实现 565
8.2.4 LPC应用 571

8.3 命名管道（Named Pipe）服务 573
8.3.1 命名管道的名称解析 573
8.3.2 命名管道的通讯模型 575
8.3.3 命名管道的实现 577

8.4 邮件槽（Mailslot）服务 580
8.4.1 邮件槽的名称解析 580
8.4.2 邮件槽的通讯模型 581
8.4.3 邮件槽的实现 581

8.5 SDT显示工具SDTViewer 583
8.5.1 SDTViewer使用介绍 583
8.5.2 SDTViewer实现原理 584
8.6 本章总结 585


第9章 Windows内核高级话题 587

9.1 网络 587
9.1.1 Windows网络体系结构 587
9.1.2 TDI（传输驱动程序接口） 591
9.1.3 NDSI（网络驱动程序接口规范） 594
9.1.4 Windows Vista以后的网络结构 597

9.2 Windows子系统 599
9.2.1 Windows子系统结构 599
9.2.2 Windows子系统初始化与GUI线程 602
9.2.3 窗口管理 606
9.2.4 GDI（图形设备接口） 616
9.2.5 Windows Vista以后的子系统变化 622

9.3 内核日志 625
9.3.1 WRK中的内核记录器 625
9.3.2 利用ETW信息诊断性能问题 628

9.4 Windows Vista/Server 2008/7的重要变化 636
9.4.1 MinWin工程 636
9.4.2 ？？ 639


附录A 建立编译和调试WRK环境 641

A.1 编译WRK 641
A.2 启动WRK 645
A.3 调试WRK 648


附录B 内核代码插入工具KInjectToolKit 657

B.1 KInjectToolKit功能介绍 658
B.2 KInjectToolKit的代码实现 659
B.3 KInjectToolKit的限制 663


