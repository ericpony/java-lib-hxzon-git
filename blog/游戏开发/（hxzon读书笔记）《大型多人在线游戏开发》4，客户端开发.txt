（hxzon读书笔记）《大型多人在线游戏开发》4，客户端开发

by hxzon
========
《4，客户端开发》
（2013.11.15）

《4.1，客户端移动预测》
《4.1.1，游戏的开发需要良好的移动预测》
两个原因让游戏开发人员必须进行客户端移动预测：用户对获得即时反馈的需求，以及网络数据包延迟的不确定性。

关于多人游戏的文献通常认为，这个更新频率应该是每秒钟4到20次。
这篇文章将对三种独立的技术进行讨论，它们中的任意一种都可以帮助我们解决这个问题。
-1，命令时间同步。
-2，插值和推导。
-3，可逆仿真。

《4.1.2，命令时间同步》
类似于《网络风暴》这样的即时战略游戏，必须基于寻路请求来把对象移动到特定的位置。
然而，如果每个客户都用相同的速度来移动他们的对象，那么，
每个客户端的对象到达最终位置的时间将由服务器发出的移动命令的延迟决定。
这样，离服务端较远的电脑更容易收到过时的信息。

客户端与其仅发送“移动单元x使它到达位置p”，不如同时发送预计的完成时间：“移动单元x使它在未来的某个时间t到达位置p”。
如果客户端和服务器的时间是同步的，服务端就可以调节移动单元x的速度，使它在正确时间到达终点。

这可以解决本文开始时所提出的两个问题。
如果某个客户端收到命令的时间比其它客户端要晚，那它可以以一个较快的速度移动坦克，使其可以在正确时间到达终点。
《4.1.3，合并路点》
路点（waypoint）是物体移动路径上的一系列关键点。
基于路点的移动方法，只需要在移动开始的时候发送一个初始的路点列表，在这个怪物停止移动前就不用再去更新它了。
所有的移动请求都必须得到服务端的认可，
但是如果客户端发现它到终点的直线上没有障碍物，客户端也可以自行移动。
当一个对象撞上另一个对象时，服务端会发出停止移动的命令。
这些特殊情况使得服务端的对象位置和当前路径与客户端的对象位置和当前路径存在差别。
服务端和客户端之间的这种矛盾必须要在客户端得到解决。

为了减少跳跃的出现，必须把服务端更新过的位置和路径与客户端的位置和路径合并起来。
（略）

《4.1.4，插值和推导》

客户端做了一个很大的转向以使客户端对象的位置和速度在200毫秒后与服务端的相同。
如果这条路径不是畅通无阻的（例如有墙阻隔），那就把客户端对象直接放到正确的路径上。
线性插值技术。
Catmull-Rom样条插值。

《4.1.5，为瞄准延迟使用反向仿真》
类似第一人称射击游戏，不依赖路点工作，所以无论命令时间同步还是路点合并技术都是无效的。
如果服务端可以知道客户端进行射击时的情景，它就能正确地判断这个人是否被击中了。
最简单的方法是由客户端来告诉服务端它是否击中对象。但这等于邀请黑客来摧毁游戏服务。

反向的仿真，服务端的游戏代码可以通过它发给客户端，从而得到确认的消息序列来沿着历史记录回溯，并且计算发出命令时，客户端对象的位置。
完成是否击中的计算后，这个有疑问的对象会被放到它当前的时间和位置中去。
这需要客户端和服务端用一个同步时钟来精确地计算延迟。

图4-9的例子，客户端在400毫秒前收到最后一个移动数据包，但还没有确认任何后续的命令。
因此服务端知道它必须回到客户端确认过的最后一个命令的时间上去。
然后，服务端必须推断，如果客户端没有收到任何后续指令，将会发生什么。
现在，服务端这个士兵的位置和客户端所看到的一样，因此服务端可以证实坦克确实击中了士兵。

=============
《4.2，保持流畅：异步客户和时空穿梭》
（2013.11.15）

“异步客户（asynchronous client）”本质上就是一个拒绝等待数据的客户端。
游戏开发人员应该要把处理问题的角度定位在游戏真正发生的地方，也就是玩家的电脑屏幕前，而不是将自己置身于服务端中。

设计人员必须确定哪些状态需要在不同玩家的游戏世界中进行同步，并且为它们设定优先级。

《4.2.1，共享状态的基本问题》
美国军方对创建“分布式虚拟环境”进行了广泛的研究，其中一些重要成果有“分布式交互仿真”，“仿真网络”，“高级架构”等。
但要把它们直接应用于因特网多人游戏还非常困难。
一是它们以完善的高速局域网为前提，二是为了实现互用性而非常注重标准化。

很多关于状态传播的讨论都强调吞吐量，也就是被移动数据的总量。
很少有人从“延迟和一致性的折中”角度来思考这个问题，这正是本文的目的。

《4.2.2，航位推测法（dead reckoning）：时空探索者会做得更好》
这是一种客户端预测的方式，被广泛用在那些需要发布位置数据的游戏中，例如第一人称射击游戏。
怎样用它来补偿网络延迟。
简单说，它就是根据一个物体过去的行为来判断它“现在”应该在做些什么。

服务端可以根据更新时间和当前仿真时间的区别再一次对新位置进行预测。

《4.2.3，仿真时间表示：为时空穿梭建立通道》
需要一个大家一致公认的共享仿真时间来让所有参与者能够同步。
只要所有的事件使用同一个地点产生的时间戳来进行排序，就不会在仿真逻辑中由于时间之间互相依赖而导致错误。

仿真时间必须完全独立于帧频（frame rate）。
我们对客户端时间的操作应该独立于画面更新的节奏。

为了获得最大的灵活性，对象行为的计算必须基于时间的改变（time delta），
而不是基于固定的离散仿真更新（tick）。

《4.2.4，直接操纵时间》

游戏中，处理时间的一种常见方法是让每个客户端的仿真时间略微落后于实际时间。
这样在服务端需要使用某个网络消息时，可以向它提供一个到达客户端的时间，不过，这种方法会给玩家的交互带来一个固定的延迟。

可以看看流畅预测的例子的一个退化情况。
如果客户端仿真时钟指向的是过去的某一个时间，服务端通常可以在一个远程对象真正到达某个位置之前预先知道那个位置。
这意味着服务端是要与这个对象未来的某个位置进行插值，而不是从某个已知的过去位置进行推导。
这样一来，就不会产生偏差，因为服务端可以有规律地获得真实的路径。

这个方法的另一个改进是使用可变的延迟。
（略）


《4.2.5，总结》
-1，要让游戏在客户端的运行保持流畅，这比精确更重要。
-2，要让玩家能够知道游戏中发生的事情，并且能够参与其中。
让玩家可以掌控自己的游戏世界要比让他们为其它玩家的游戏世界做贡献更为重要。


通过事件展开（event unfold）来让时间向前推进这种方法，对于所有网络多人游戏的开发人员来说都很有帮助。

=============
《4.3，使用程序生成游戏世界：避免数据激增》
《4.4，为固定大小的对象编写一个高速有效的分配器》
《4.5，使用贴图定制三维角色》
======
《4.6，游戏机平台上MMP游戏的独特挑战》
游戏机平台最大的好处在于一致的硬件，这极大地简化了针对不同配置所要做的测试工作。
《4.6.1，环境》
游戏机平台和pc的第一个区别在于放置硬件的地点。
游戏机通常放在起居室（或说客厅）里，即一个共享的环境。
分屏模式，让2到4个人在同一台游戏机共同游戏可以降低很多问题的复杂度，包括交流、分组和交易。

游戏机环境的另一个要求是必须减少单次游戏的持续时间。
很多MMP游戏可能需要花费半个小时来进行连接；寻找朋友；决定要做什么，然后到达目的地。
在游戏机上，必须加快这一过程使得玩家在半小时内足以进行一次有效的游戏。
《4.6.2，登录》
《4.6.4，聊天频道》
需求：
--1，和朋友一对一的个别聊天。
--2，和少量其它玩家一起组织分组和游戏。
--3，和大量的朋友或是在行会中聊天。
--4，大型事件中关于战略或是战术的聊天。
使用语音通讯的问题。
使用“表情”。

也可以把聊天的需要最小化。
《4.6.5，选择目标》
pc游戏玩家习惯于使用鼠标或是键盘热键来选择目标。
便捷菜单：
--1，在可能的目标中选择下一个对手。
--2，在可能的目标中选择最近的对手。
--3，选择在攻击范围内最弱的对手。
--4，选择同一个对手作为当前目标。
--5，选择下一个小组成员。

系统自动把处于攻击范围内的对手作为目标，例如第一人称射击游戏，玩家对准什么就攻击什么。这种方式大大简化游戏设计。
这种隐式的目标选取会在很大程序上改变战斗、交易和其它交互形式的工作方式。
这也是玩家非常熟悉的一种方式，它让游戏具有更多的行动性，从而使玩家可以在瞄准和跟随目标时变得更为主动。


（第4章结束。）
