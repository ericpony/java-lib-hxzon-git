Scala语言将加入宏指令http://www.infoq.com/cn/news/2013/01/scala-macros作者 Josh Suereth ，译者 朱伟健 发布于 一月 22, 2013Scala开发团队正在将实验版宏指令加入到即将发行的2.10版中。Scala宏指令提供了编译时元编程的高级形式。Scala宏网站（http://scalamacros.org/index.html）描述道：“宏指令显著简化了代码分析和代码生成，这使得它们成为处理大量现实用例的一种可选工具。传统上涉及编写和维护样板的场合可用宏以简单且易维护的方式实现。因此我们认为宏对于Scala编程语言是一项非常有价值的资产。”Scala的宏指令允许开发者创建方法时以语法树转化的形式实现。这些是标准方法的定义，其在编译期间被显式地转换。举一个简单的例子，如assert方法：import scala.reflect.makro.Contextimport language.experimental.macrosobject Asserts {   def assert(cond: Boolean, msg: Any) = macro Asserts.assertImpl   def raise(msg: Any) = throw new AssertionError(msg)   def assertImpl(c: Context)(cond: c.Expr[Boolean], msg: c.Expr[Any]): c.Expr[Unit] =         if(assertionsEnabled) c.reify(if(!cond.splice) raise(msg.splice))          else c.reify(())}assert宏就像代码中的一个普通的方法。该实现使用macro方法委托成为编译器扩展。该编译器扩展是方法assertImpl。assertImpl使用当前编译的上下文作为参数，而参数传给assert作为语法树（Expr）。这些语法树接下来被用作产生一个新的语法树并被插入至assert宏方法被调用的位置。对于assert宏来说，调用assert的方法assert(x != null, "X is null") 会给cond变量填充x != null的语法树而给msg变量填充"X is null"的语法树。对reify的调用会产生一个 if(x != null) Asserts.raise("X is null")的或者()的新语法树。这个语法树会替代原始的assert(x != null, "X is null") 调用。reify和自清洁宏系统的更多细节可参考《自清洁宏建议》（http://docs.scala-lang.org/sips/pending/self-cleaning-macros.html）。有些人怀疑添加宏的效果，在一份题为《Scala Macros: "Oh God Why?"》（http://blog.empathybox.com/post/19126121307/scala-macros-oh-god-why）博客中， Jay Kreps 评论道：“这也是我对于Scala 宏指令的看法（Oh God Why?）。并不是因为宏指令或者这项提议有什么坏处，问题在于这真的是最重要的事情吗？”Kreps接下来列举了一系列更重要的事情，包括编译速度、IDE支持、文档和编译文件大小。支持Kreps观点的大有人在。Ivan Todoroski在一封给Scala邮件列表的信中写到：“在搜索问题的时候，Scala宏指令看起来只是一个低级别的、hacking风格的解决方案。它们在编写时太复杂，不太像Scala的风格，调试也麻烦，而且可能不过是为Scala的‘太多高深莫测的魔法’的形象增添了一笔。”对此，Scala的发明者Martin Odersky回复说：“宏的设计初衷和Scala语言的其他一般设计一样，都是为了使事情简单化。我们已经实现通过宏替换代码，希望其他功能也能这样实现。比如说，有一种强推在某种情况下消除 atomic { implicit transaction => ... }中的隐含参数和许多其他相关情形。有了宏，这类问题就微不足道了。”围绕着Scala宏的讨论已经逐渐偃旗息鼓，社区成员们正在等着看最终的实现。最终发布的版本始终没有放弃在宏指令方面的冒险。许多社区内基于宏的项目已经逐渐生根发芽，包括：Macrocosm——测试宏指令实际用例的库。Expecty——Groovy的Spock框架中的断言语句在Scala中的适应性改编。Slick——引进类似LINQ的数据库操作的尝试。Slick能转化Scala语法为数据库查询。ScalaMock——Scala的模拟对象测试库。在2.10.0-M4发布说明里可以找到其他一系列Scala2.10中的功能，包括：字符串插值（http://docs.scala-lang.org/sips/pending/string-interpolation.html）Futures和Promises（http://docs.scala-lang.org/sips/pending/futures-promises.html）Value类（http://docs.scala-lang.org/sips/pending/value-classes.html）动态类型（http://docs.scala-lang.org/sips/pending/type-dynamic.html）隐式类（http://docs.scala-lang.org/sips/pending/implicit-classes.html）Scala2.10版马上就要发布了，Scala开发团队号召人们试用最新的milestone发行版并提供反馈意见。你可以从这里下载最新版本。