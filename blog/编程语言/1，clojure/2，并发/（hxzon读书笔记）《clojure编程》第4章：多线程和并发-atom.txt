（hxzon读书笔记）《clojure编程》第4章：多线程和并发-atom

by hxzon
=====
1，clojure中有4种引用类型可以用来 表达标识：var，ref，agent和atom。

对引用类型解引用，绝对不会阻塞，也绝不会跟其它操作相互干扰。
这点和delay，future，promise形成鲜明对比。

引用类型除了可以解引用，还可以添加元数据。
但是跟普通值不同，不能使用with-meta或者vary-meta，
对引用类型必须使用alter-meta! ，它会直接修改引用类型的元数据（而不是返回一个新的引用类型）。
atom，ref，agent都接受一个额外的:meta关键字参数，用来设置元数据。


对引用类型可以指定“观察器”，在引用类型状态发生变化时会调用观察器函数，
但不保证值真的变化。

对引用类型还可以指定“校验器”，如果引用类型的新值让校验器函数返回非真，会阻止新值。

2，并发操作的分类

根据同步，非同步，协调，非协调，会产生4种组合。
ref是协调的，同步的。
atom是独立的（所以不需协调），同步的。
agent是不协调的，异步的。

var的主要用途则是线程内对于状态的修改。

clojure的兴趣是解决进城内的并发和并行问题，
所以没有提供协调的、异步的引用类型。
这种类型在分布式系统里面更常见，
例如最终一致性数据库，只保证一段时间后，所有对于状态的修改会合并到最终状态中。

----
两个用来帮助测试的宏。

(defmacro futures
  [n & exprs]
  (vec (for [_ (range n)
             expr exprs]
         `(future ~expr))))

(defmacro wait-futures
  [& args]
  `(doseq [f# (futures ~@args)]
     @f#))

========
3，atom

(def sarah (atom {:name "Sarah" :age 25 :wears-glasses? false}))
;= #'user/sarah

(swap! sarah update-in [:age] + 3) 
;= {:age 28, :wears-glasses? false, :name "Sarah"}

(swap! sarah (comp #(update-in % [:age] inc)
               #(assoc % :wears-glasses? true)))
;= {:age 29, :wears-glasses? true, :name "Sarah"}

(def xs (atom #{1 2 3}))
;= #'user/xs

(wait-futures 1 (swap! xs (fn [v]
                            (Thread/sleep 250)
                            (println "trying 4")
                            (conj v 4)))
  (swap! xs (fn [v]
              (Thread/sleep 500)
              (println "trying 5")
              (conj v 5))))
;= nil
; trying 4
; trying 5 
; trying 5

@xs
;= #{1 2 3 4 5}

(def x (atom 2000))
;= #'user/x

(swap! x #(Thread/sleep %))
;= nil

(compare-and-set! xs :wrong "new value")
;= false

(compare-and-set! xs @xs "new value")
;= true

@xs
;= "new value"

(def xs (atom #{1 2}))
;= #'user/xs

(compare-and-set! xs #{1 2} "new value")
;= false

(reset! xs :y)
;= :y

@xs
;= :y


=======
通知器

(defn echo-watch
  [key identity old new]
  (println key old "=>" new))
;= #'user/echo-watch

(def sarah (atom {:name "Sarah" :age 25}))
;= #'user/sarah

(add-watch sarah :echo echo-watch)
;= #<Atom@418bbf55: {:name "Sarah", :age 25}>

(swap! sarah update-in [:age] inc)
; :echo {:name Sarah, :age 25} => {:name Sarah, :age 26}
;= {:name "Sarah", :age 26}

(add-watch sarah :echo2 echo-watch)
;= #<Atom@418bbf55: {:name "Sarah", :age 26}>

(swap! sarah update-in [:age] inc)
; :echo {:name Sarah, :age 26} => {:name Sarah, :age 27}
; :echo2 {:name Sarah, :age 26} => {:name Sarah, :age 27}
;= {:name "Sarah", :age 27}

(remove-watch sarah :echo2)
;= #<Atom@418bbf55: {:name "Sarah", :age 27}>

(swap! sarah update-in [:age] inc)
; :echo {:name Sarah, :age 27} => {:name Sarah, :age 28}
;= {:name "Sarah", :age 28}

(reset! sarah @sarah)
; :echo {:name Sarah, :age 28} => {:name Sarah, :age 28}
;= {:name "Sarah", :age 28}

(def history (atom ()))

(defn log->list
  [dest-atom key source old new]
  (when (not= old new)
    (swap! dest-atom conj new)))

(def sarah (atom {:name "Sarah", :age 25}))
;= #'user/sarah

(add-watch sarah :record (partial log->list history))
;= #<Atom@5143f787: {:age 25, :name "Sarah"}>

(swap! sarah update-in [:age] inc)
;= {:age 26, :name "Sarah"}

(swap! sarah update-in [:age] inc)
;= {:age 27, :name "Sarah"}

(swap! sarah identity)
;= {:age 27, :name "Sarah"}

(swap! sarah assoc :wears-glasses? true)
;= {:age 27, :wears-glasses? true, :name "Sarah"}

(swap! sarah update-in [:age] inc)
;= {:age 28, :wears-glasses? true, :name "Sarah"}

(pprint @history)
;= ;= nil
;= ; ({:age 28, :wears-glasses? true, :name "Sarah"}
;= ; {:age 27, :wears-glasses? true, :name "Sarah"}
;= ; {:age 27, :name "Sarah"}
;= ; {:age 26, :name "Sarah"})

(defn log->db
  [db-id identity old new]
  (when (not= old new)
    (let [db-connection (get-connection db-id)]
      ...)))

(add-watch sarah "jdbc:postgresql://hostname/some_database" log->db)


=====
校验器

(def n (atom 1 :validator pos?))
;= #'user/n

(swap! n + 500)
;= 501

(swap! n - 1000)
;= #<IllegalStateException java.lang.IllegalStateException: Invalid reference state>

(def sarah (atom {:name "Sarah" :age 25}))
;= #'user/sarah

(set-validator! sarah :age)
;= nil

(swap! sarah dissoc :age)
;= #<IllegalStateException java.lang.IllegalStateException: Invalid reference state>

(set-validator! sarah #(or (:age %)
                         (throw (IllegalStateException. "People must have `:age`s!"))))
;= nil

(swap! sarah dissoc :age)
;= #<IllegalStateException java.lang.IllegalStateException: People must have `:age`s!>

https://github.com/scgilardi/slingshot
