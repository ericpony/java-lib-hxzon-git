（hxzon读书笔记）《clojure编程》第3章：集合和数据结构-生命游戏

by hxzon

hxzon摘要：

1，获得下一代板子，基于二维数组下标，indexed-step。
2，获得下一代板子不基于下标，index-free-step。
3，stepper。

=======
Revisiting a classic: Conway’s Game of Life
https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life

生命游戏中，对于任意细胞，规则如下：

1，每个细胞有两种状态-存活或死亡，每个细胞与以自身为中心的周围八格细胞产生互动。
2，当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。 （模拟繁殖）
3，当前细胞为存活状态时，当周围低于2个（不包含2个）存活细胞时， 该细胞变成死亡状态。（模拟人口稀少）
4，当前细胞为存活状态时，当周围有2个或3个存活细胞时， 该细胞保持原样。
5，当前细胞为存活状态时，当周围有3个以上的存活细胞时，该细胞变成死亡状态。（模拟过度拥挤）

可以把最初的细胞结构定义为种子，当所有在种子中的细胞同时被以上规则处理后，可以得到第一代细胞图。
继续按规则处理当前的细胞图，可以得到下一代的细胞图，周而复始。

======
生成板子（二维向量）。
(defn empty-board
    "Creates a rectangular empty board of the specified width and height."
    [w h]
    (vec (repeat w (vec (repeat h nil)))))

--
初始化板子。
(defn populate
    "Turns :on each of the cells specified as [y, x] coordinates."
    [board living-cells]   ;living-cells，活格子的坐标
    (reduce (fn [board coordinates]
                (assoc-in board coordinates :on))
            board
            living-cells))

(def glider (populate (empty-board 6 6) #{[2 0] [2 1] [2 2] [1 2] [0 1]}))

(pprint glider)
; [ [nil :on nil nil nil nil]
;   [nil nil :on nil nil nil]
;   [:on :on :on nil nil nil]
;   [nil nil nil nil nil nil]
;   [nil nil nil nil nil nil]
;   [nil nil nil nil nil nil]]

--
返回格子的8个邻居的坐标。
(defn neighbours
    [[x y]]
    (for [dx [-1 0 1] dy [-1 0 1] :when (not= 0 dx dy)]
        [(+ dx x) (+ dy y)]))

--
计算格子的活邻居数。
(defn count-neighbours
    [board loc]
    (count (filter #(get-in board %) (neighbours loc)))) 
;(filter #(get-in board %) (neighbours loc)) 返回活着的邻居的坐标。

--
得到下一代板子。

(defn indexed-step
    "Yields the next state of the board, using indices to determine neighbors,liveness, etc."
    [board]
    (let [  w (count board)
            h (count (first board))]	;这里假定了板子是矩形。
        (loop   [new-board board x 0 y 0]
                (cond
                    (>= x w) new-board		;处理完毕，返回新板子。
                    (>= y h) (recur new-board (inc x) 0)		;逐行递归
                    :else
                    (let [  new-liveness
                            (case (count-neighbours board [x y])
                                  2 (get-in board [x y])	;当有两个活邻居时，格子维持原样。
                                  3 :on	;当有三个活邻居时，维持活着或复活。
                                  nil)]
                         (recur (assoc-in new-board [x y] new-liveness) x (inc y)))))))		;更新[x,y]格子的状态，逐列递归

--
第八代的结果。

注，(iterate f x)返回一个惰性序列， 序列元素的值为 x 、 (f x) 、 (f (f x)) 、 (f (f (f x))) ， 诸如此类。

(-> (iterate indexed-step glider) (nth 8) pprint)
; [[nil nil nil nil nil nil]
; [nil nil nil nil nil nil]
; [nil nil nil :on nil nil]
; [nil nil nil nil :on nil]
; [nil nil :on :on :on nil]
; [nil nil nil nil nil nil]]

----
使用两层reduce消除loop。
先逐列规约，再逐行规约。

(defn indexed-step2
    [board]
    (let [  w (count board)
            h (count (first board))]
        (reduce
            (fn [new-board x]
                (reduce
                    (fn [new-board y]
                        (let [  new-liveness
                                (case (count-neighbours board [x y])
                                      2 (get-in board [x y])
                                      3 :on
                                      nil)]
                            (assoc-in new-board [x y] new-liveness)))
                    new-board (range h)))
            board (range w))))

----
两层reduce可以变成一层reduce。
逐单元格规约。

(defn indexed-step3
    [board]
    (let [  w (count board)
            h (count (first board))]
         (reduce
            (fn [new-board [x y]]
                (let [     new-liveness
                         (case (count-neighbours board [x y])
                               2 (get-in board [x y])
                               3 :on
                               nil)]
                    (assoc-in new-board [x y] new-liveness)))
            board (for [x (range h) y (range w)] [x y]))))

=========
窗口函数，返回分区列表，
每个分区3个元素，每个分区头相距一个步长，最后一个分区如果不满3个元素，用nil填充。
(defn window
    "Returns a lazy sequence of 3-item windows centered around each item of coll."
    [coll]
    (partition 3 1 (concat [nil] coll [nil])))

--
注：partition，分区，每个分区3个元素，每个分区的头元素相距1个步长。

(partition 3 1 (range 5))
;= ((0 1 2) (1 2 3) (2 3 4))

(partition 3 1 (concat [nil] (range 5) [nil]))
;= ((nil 0 1) (0 1 2) (1 2 3) (2 3 4) (3 4 nil))

----
单元格块。
(defn cell-block
    "Creates a sequences of 3x3 windows from a triple of 3 sequences."
    [[left mid right]]
    (window (map vector
                 (or left (repeat nil)) mid (or right (repeat nil)))))

注：(or left (repeat nil))，如果left为nil，返回元素为nil的无限序列。
（triple，三重。）

===========
同上边的窗口函数，但是新增pad参数，pad作为一个元素用于填充。
(defn window
    "Returns a lazy sequence of 3-item windows centered around each item of coll, padded as necessary with pad or nil."
    (   [coll] (window nil coll))
    (   [pad coll]      ;coll是一个3元素的向量，它的元素也是序列。
        (partition 3 1 (concat [pad] coll [pad]))))

示例，注意，这里整个向量作为元素（而不是用向量的元素）用来填充：
(window [\a \b ] [1 2 3 4 5 6 7 8 9 10])
;= (    ([\a \b] 1 2) (1 2 3) (2 3 4) (3 4 5) 
;       (4 5 6) (5 6 7) (6 7 8) 
;       (7 8 9) (8 9 10) (9 10 [\a \b]))

(window [\a \b] [[1 2 3] [4 5 6]  [7 8 9 10] [11 12 13 14 15] [16 17] ])
;=( ([\a \b] [1 2 3] [4 5 6]) 
;   ([1 2 3] [4 5 6] [7 8 9 10]) 
;   ([4 5 6] [7 8 9 10] [11 12 13 14 15]) 
;   ([7 8 9 10] [11 12 13 14 15] [16 17]) 
;   ([11 12 13 14 15] [16 17] [\a \b])  )

--
(defn cell-block
    "Creates a sequences of 3x3 windows from a triple of 3 sequences."
    [[left mid right]]  ;left，mid，right都是序列。
    (window (map vector left mid right)))   ;将left，mid，right都转成向量。

示例，注意，只处理前三个序列：
(cell-block [ [1 2 3] [4 5 6] [7 8 9]])
;= ((nil [1 4 7] [2 5 8]) ([1 4 7] [2 5 8] [3 6 9]) ([2 5 8] [3 6 9] nil))

(cell-block [ [1 2 3] [4 5 6] [7 8 9] [10 11 12]])
;= ((nil [1 4 7] [2 5 8]) ([1 4 7] [2 5 8] [3 6 9]) ([2 5 8] [3 6 9] nil))

(cell-block [ [1 2 3 \a] [4 5 6 \b] [7 8 9 \c] [10 11 12 \d]])
;= (    (nil [1 4 7] [2 5 8])   ([1 4 7] [2 5 8] [3 6 9])   ([2 5 8] [3 6 9] [\a \b \c])    ([3 6 9] [\a \b \c] nil)    )

----
计算给定块的中心格子，在下一轮中的状态。

(defn liveness
    "Returns the liveness (nil or :on) of the center cell for the next step."
    [block]     ;3*3的块。
    (let [[_ [_ center _] _] block]
         (case (- (count (filter #{:on} (apply concat block)))  ;块中的活格子数。
                  (if (= :on center) 1 0))  ;中心格子的当前状态如果为存活，返回1，否则0。
;排除中心格子后，得到块的中心格子的活邻居数。

               2 center     ;两个活邻居，维持原状态。
               3 :on
               nil)))

(defn- step-row
    "Yields the next state of the center row."
    [rows-triple]
    (vec (map liveness (cell-block rows-triple))))

----
得到下一代板子，不再依赖下标。

(defn index-free-step
    "Yields the next state of the board."
    [board]
    (vec (map step-row (window (repeat nil) board))))

检验新的函数是否和旧的函数元算结果相同。
(= (nth (iterate indexed-step glider) 8)
   (nth (iterate index-free-step glider) 8))
;= true

----
(pprint glider)
; [ [nil :on nil nil nil nil]
;   [nil nil :on nil nil nil]
;   [:on :on :on nil nil nil]
;   [nil nil nil nil nil nil]
;   [nil nil nil nil nil nil]
;   [nil nil nil nil nil nil]]

(index-free-step glider)
;[  [nil nil nil nil nil nil] 
;   [:on nil :on nil nil nil] 
;   [nil :on :on nil nil nil] 
;   [nil :on nil nil nil nil] 
;   [nil nil nil nil nil nil] 
;   [nil nil nil nil nil nil]]

=====
(defn step
    "Yields the next state of the world"
    [cells]     ;cells，序列，元素为活格子的坐标。
    (set (for [ [loc n] (frequencies (mapcat neighbours cells))     ;解构，loc是单元格的邻居数，n是邻居数出现的次数。
                :when (or (= n 3) (and (= n 2) (cells loc)))    ]
            loc)))

注：
;mapcat等同于调用 (concat (map f colls)) 。计算每个格子的邻居数。
;frequencies返回集合中，元素及元素出现的次数，如{"a" 3, "b" 1, "c" 2, "d" 1} 。

示例：
(mapcat neighbours  #{[2 0] [2 1] [2 2] [1 2] [0 1]} )
;= ( [1 0] [1 1] [1 2] [2 0] [2 2] [3 0] [3 1] [3 2] [1 1] [1 2] [1 3] [2 1] 
;    [2 3] [3 1] [3 2] [3 3] [-1 0] [-1 1] [-1 2] [0 0] [0 2] [1 0] [1 1] [1 2] 
;    [0 1] [0 2] [0 3] [1 1] [1 3] [2 1] [2 2] [2 3] [1 -1] [1 0] [1 1] [2 -1] [2 1] [3 -1] [3 0] [3 1])

(frequencies (mapcat neighbours #{[2 0] [2 1] [2 2] [1 2] [0 1]} )  )
;={   [2 1] 3, [3 2] 2, [1 0] 3, [1 -1] 1, [2 2] 2, [3 3] 1, [-1 0] 1, [0 0] 1, 
;     [1 1] 5, [2 3] 2, [-1 1] 1, [0 1] 1, [1 2] 3, [-1 2] 1, [0 2] 2, [1 3] 2, 
;     [0 3] 1, [3 0] 2, [3 -1] 1, [3 1] 3, [2 0] 1, [2 -1] 1}

----
(->> (iterate step #{[2 0] [2 1] [2 2] [1 2] [0 1]}) 
     (drop 8)
     first
     (populate (empty-board 6 6))
     pprint)
; [[nil nil nil nil nil nil]
; [nil nil nil nil nil nil]
; [nil nil nil :on nil nil]
; [nil nil nil nil :on nil]
; [nil nil :on :on :on nil]
; [nil nil nil nil nil nil]]

========
(defn stepper
    "Returns a step function for Life-like cell automata.
    neighbours takes a location and return a sequential collection
    of locations. survive? and birth? are predicates on the number
    of living neighbours."

    [neighbours birth? survive?]
    (fn [cells]
        (set (for [[loc n] (frequencies (mapcat neighbours cells))
                :when (if (cells loc) (survive? n) (birth? n))]
                loc))))

(defn hex-neighbours
    [[x y]]
    (for [dx [-1 0 1] dy (if (zero? dx) [-2 2] [-1 1])]
         [(+ dx x) (+ dy y)]))

(def hex-step (stepper hex-neighbours #{2} #{3 4}))
;= ; this configuration is an oscillator of period 4

(hex-step #{[0 0] [1 1] [1 3] [0 4]})
;= #{[1 -1] [2 2] [1 5]}

(hex-step *1)
;= #{[1 1] [2 4] [1 3] [2 0]}

(hex-step *1)
;= #{[1 -1] [0 2] [1 5]}

(hex-step *1)
;= #{[0 0] [1 1] [1 3] [0 4]}

(stepper #(filter (fn [[i j]] (and (< -1 i w) (< -1 j h)))
                  (neighbours %))
         #{2 3} #{3})


