Clojure程序设计
外文书名: Programming Clojure, Second Edition
出版社: 人民邮电出版社; 第1版 (2013年3月20日)
丛书名: 新锐编程语言集萃
平装: 230页
语种： 简体中文
开本: 16
ISBN: 9787115308474
条形码: 9787115308474
品牌: 人民邮电出版社
ASIN: B00BN5N7R4
http://www.amazon.cn/Clojure%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-Stuart-Halloway/dp/B00BN5N7R4
-------------
作者简介
作者：（美国）Stuart Halloway （美国）Aaron Bedra 译者：温瑞云

Stuart Halloway： Clojure/core成员、Relevance公司CTO。
Aaron Bedra，Clojure/core成员，在担任Relevance公司开发者期间，他成为一名技术领袖、演讲家和作家。他对Clojure语言及其支持库贡献颇多，同时也是Clojure社区中的活跃分子。Aaron牵头开发了一些商业的Clojure项目。目前他在Groupon工作。
=================
目录

第1章 启航 1

1.1 为什么是Clojure 2
1.1.1 Clojure非常优雅 2
1.1.2 Clojure是Lisp的再度崛起 5
1.1.3 为什么是Lisp 5
1.1.4 它是Lisp，但括号少了 6
1.1.5 Clojure是函数式语言 8
1.1.6 Clojure简化了并发编程 9
1.1.7 Clojure与Java虚拟机彼此亲密无间 10

1.2 Clojure编程快速入门 11
1.2.1 使用REPL 12
1.2.2 特殊变量 13
1.2.3 添加共享状态 14

1.3 探索Clojure的程序库 16
1.3.1 require和use 17
1.3.2 查找文档 18

1.4 小结 20

第2章 探索Clojure 21

2.1 形式 21
2.1.1 使用数值类型 22
2.1.2 符号 24
2.1.3 字符串与字符 25
2.1.4 布尔值与nil 27
2.1.5 映射表、关键字和记录 28

2.2 读取器宏 30

2.3 函数 32
2.3.1 匿名函数 34
2.3.2 何时使用匿名函数 36

2.4 变量、绑定和命名空间 36
2.4.1 绑定 37
2.4.2 解构 38
2.4.3 命名空间 40

2.5 调用Java 43
2.5.1 访问构造函数、方法和字段 43
2.5.2 Javadoc 45

2.6 流程控制 45
2.6.1 分支结构与if 45
2.6.2 用do引入副作用 46
2.6.3 循环与loop/recur 47

2.7 我的for循环哪儿去了 48

2.8 元数据 52

2.9 小结 53

第3章 一切皆序列 55

3.1 一切皆序列 56

3.2 使用序列库 61
3.2.1 创建序列 61
3.2.2 过滤序列 64
3.2.3 序列谓词 65
3.2.4 序列转换 66

3.3 惰性和无限序列 69

3.4 Java亦可序化 71
3.4.1 序化Java容器 71
3.4.2 序化正则表达式 73
3.4.3 序化文件系统 74
3.4.4 序化流 75
3.4.5 序化XML 76

3.5 调用特定于结构的函数 77
3.5.1 列表函数 77
3.5.2 向量函数 78
3.5.3 映射表函数 79
3.5.4 集合函数 82

3.6 小结 85

第4章 函数式编程 86

4.1 函数式编程理念 86
4.1.1 纯函数 87
4.1.2 持久性数据结构 87
4.1.3 惰性和递归 88
4.1.4 引用透明性 89
4.1.5 FP的优势 89
4.1.6 6条规则 90

4.2 怎样偷个懒 91
4.2.1 尾递归 92
4.2.2 自递归与recur 94
4.2.3 惰性序列 95
4.2.4 聊聊变现 97
4.2.5 丢弃头元素 98

4.3 懒上加懒 99
4.4 再议递归 105
4.4.1 转换为自递归 106
4.4.2 采用Trampolining技术 107
4.4.3 用惰性化替代递归 109
4.4.4 用快存为递归抄条近路 112

4.5 小结 114

第5章 状态 115

5.1 并发、并行和锁定 116

5.2 引用与软事务内存 117
5.2.1 ref-set 118
5.2.2 事务的属性 118
5.2.3 alter 119
5.2.4 STM的工作原理：MVCC 120
5.2.5 commute 121
5.2.6 alter优先 122
5.2.7 为引用添加验证 123

5.3 使用原子进行非协同、同步的更新 124

5.4 使用代理进行异步更新 125
5.4.1 代理的验证与错误处理 126
5.4.2 在事务中包含代理 127
5.4.3 统一的更新模型 129

5.5 用变量管理线程内状态 129
5.5.1 远距离作用 131
5.5.2 用于Java回调API 132

5.6 Clojure贪吃蛇 134
5.6.1 函数式模型 135
5.6.2 使用STM建立可变模型 139
5.6.3 贪吃蛇的GUI 140
5.6.4 没有引用的贪吃蛇 143

5.7 小结 144

第6章 协议和数据类型 145

6.1 针对抽象编程 145

6.2 接口 148

6.3 协议 149

6.4 数据类型 153

6.5 记录 158

6.6 具体化 164

6.7 小结 165

第7章 宏 166

7.1 何时使用宏 166

7.2 编写流程控制宏 167
7.2.1 特殊形式、设计模式和宏 169
7.2.2 宏展开 170
7.2.3 when与when-not 172

7.3 让宏更加简单 173
7.3.1 语法引述、解引述和解引述拼接 175
7.3.2 在宏内部创建名称 176

7.4 宏的分类 178
7.4.1 有条件的求值 180
7.4.2 创建变量 181
7.4.3 Java互操作 183
7.4.4 延迟求值 184
7.4.5 对求值进行包装 184
7.4.6 避免Lambda表达式 186

7.5 小结 187

第8章 多重方法 188

8.1 没有多重方法的日子 188

8.2 定义多重方法 190
8.2.1 调度是继承感知的 192
8.2.2 多重方法的默认值 192

8.3 调度不简单 193

8.4 创建特设分类法 195

8.5 何时应该使用多重方法 199
8.5.1 Inspector 200
8.5.2 clojure.test 201
8.5.3 反例 202

8.6 小结 203

第9章 极尽Java之所能 204

9.1 异常处理 205
9.1.1 保持简单的异常处理 205
9.1.2 清理资源 206
9.1.3 响应异常 207

9.2 与整数搏斗 209

9.3 性能优化 210
9.3.1 使用基本类型提升性能 210
9.3.2 添加类型提示 213

9.4 在Clojure中创建Java类 215
9.4.1 创建Java代理 215
9.4.2 使用Java容器 217

9.5 真实世界的例子 220
9.5.1 真正的持续循环 222
9.5.2 日志 224
9.5.3 配置 226

9.6 小结 227

第10章 搭建应用 228

10.1 为电码译员游戏计分 229

10.2 测试计分器 232
10.2.1 手工构造输入 233
10.2.2 运行测试 234
10.2.3 验证输出 235
10.2.4 回归测试 236

10.3 test.generative 237
10.3.1 生成数据 237
10.3.2 程序化验证 238
10.3.3 defspec 240
10.3.4 运行测试 241
10.3.5 规格执行失败时 242
10.3.6 计分函数的产生式测试 243

10.4 创建用户界面 244
10.4.1 该是时候处理状态了 245
10.4.2 玩家界面 246

10.5 部署代码 249
10.5.1 Procfile 250
10.5.2 Heroku库 250
10.5.3 Git 251
10.5.4 安置你的应用 251
10.5.5 部署 252

10.6 小结 252

附录 编辑器 254

参考书目 255
