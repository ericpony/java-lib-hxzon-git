Programming Clojure学习笔记——与Java一起工作

http://blog.csdn.net/zh2qiang/article/details/7080485
修订by hxzon。

========
调用java构造函数，方法及属性。语法糖。
使用java数组。
便利函数。
类型提示。
创建和编译java类。
资源清理和异常处理。

==========
3.1  调用Java

Clojure提供了简单直接的语法调用Java代码：创建对象，调用方法，访问静态方法和属性。

----
访问构造函数，方法和属性

Clojure提供了new形式调用构造函数创建实例：

(new classname)

下面的代码创建Ramdom对象，赋给rnd变量：
user=> (def rnd (new java.util.Random))
#'user/rnd

使用特殊形式(.)调用方法：
(. class-or-instance member-symbol & args)
(. class-or-instance (member-symbo & args))

下面的代码调用rnd的nextInt方法：
user=> (. rnd nextInt)
-1663716284

特殊形式(.)可以作用在静态或实例属性和方法上。如：
user=> (. Math PI)

可以通过import显示引入类，使用时就可以不需要用类全名称：
(import [& import-lists])

在Clojure中调用Java大致分为以下几步：
1. 引入类名
2. 创建实例
3. 访问实例属性
4. 调用实例方法

----
语法糖

大部分Java形式都有一个缩写形式，如：

(1) new形式可以缩写为Classname.
(new Random)可以缩写为(Random.)

(2) 对于静态域，缩写形式Classname/membername，如：
(. Math PI)可以缩写为Math/PI

(3) 同样对于静态方法，也可以缩写为(Classname/membername)，如：
(System/currentTimeMillis)

(4) .形式的缩写形式.methodOrFieldName，如：
(. rnd nextInt)可以缩写为(.nextInt rnd)

(5) 多次连续调用的缩写形式(.. class-or-instance form & forms)，如：
(.getLocation (.getCodeSource (.getProtectionDomain (.getClass '(1 2)))))可以缩写为
(.. '(1 2) getClass getProtectionDomain getCodeSource getLocation)

(6) 在同一对象上调用多个方法(doto class-or-inst & member-access-forms)，如：
(doto (System/getProperties)
   (.setProperty "name" "Stuart")
   (.setProperty "favoriteColor" "blue"))

=======
使用Java数组

Clojure提供make-array函数创建Java数组：

创建一维数组 (make-array class length)，如
user=> (make-array String 5)
#<String[] [Ljava.lang.String;@5f6303>

创建多维数组 (make-array class dim & more-dims)，如
user=> (make-array String 2 2)
#<String[][] [[Ljava.lang.String;@766a24>

可以使用seq将任意Java数组包装成Clojure序列，如
user=> (seq (make-array String 5))
(nil nil nil nil nil)

Clojure还提供了一系列类似int-array的函数用来创建Java基础类型数组，如
user=> (int-array 5)
#<int[] [I@1742700>

Clojure提供了一组Java数组基本操作函数：

aset 设置Java数组项值：
一维数组 (aset java-array index value)
多维数组 (aset java-array index-dim1 index-dim2 ... value)

aget 获取Java数组项值：
一维数组 (aget java-array index)
多维数组 (aget java-array index-dim1 index-dim2 ...)

alength获取数字长度：
(alength java-array)

示例：
user=> (defn painstakingly-create-array []
   (let [arr (make-array String 5)]
     (aset arr 0 "Painstaking")
     (aset arr 1 "to")
     (aset arr 2 "fill")
     (aset arr 3 "in")
     (aset arr 4 "arrays")
     arr))
#'user/painstakingly-create-array

user=> (aget (painstakingly-create-array) 0)
"Painstaking"

user=> (alength (painstakingly-create-array))
5

to-array函数直接将集合转化为数组：
(to-array sequence)

说明：转换的结果为Object数组。

user=> (to-array ["Easier" "array" "creation"])
#<Object[] [Ljava.lang.Object;@cf66b>

into-array函数也能将集合转换为数组，并且可以指定数组元素类型：
(into-array type? seq)，如：

user=> (into-array String ["Easier" "array" "creation"])
#<String[] [Ljava.lang.String;@110c31>

如果忽略类型参数，into-array则根据第一个元素猜测数组元素的类型，如：

user=> (into-array ["Easier" "array" "creation"])
#<String[] [Ljava.lang.String;@110c31>

----
amap函数转换Java数组的每个元素：
(amap a idx ret expr)

amap创建数组的克隆，并绑定到变量ret，
对数组a每一个元素执行expr表达式，idx绑定到数组元素索引，最后返回克隆的数组，如：

user=> (def strings (into-array ["some" "strings" "here"]))
#'user/strings

user=> (seq (amap strings idx _ (.toUpperCase (aget strings idx))))
("SOME" "STRINGS" "HERE")

----
areduce函数类似amap，但可以返回值任意：
(areduce a idx ret init expr)

areduce开始用init初始化ret，然后对每一个数组a元素计算表达式expr，将计算结果赋给ret返回。如：

user=> (areduce strings idx ret 0 (max ret (.length (aget strings idx))))
7

上面的代码计算数组strings中，最长字符串的长度。

=========
便利函数

1. memfn 创建匿名函数包装Java方法，使其在Clojure中能像Clojure函数那样使用，如

user=> (map (memfn toUpperCase) ["a" "short" "message"])
("A" "SHORT" "MESSAGE")

还可以写成如下形式：
user=> (map #(.toUpperCase %) ["a" "short" "message"])
("A" "SHORT" "MESSAGE")

2. instance? 类似Java的instanceof，检测一个对象是否是某个类的实例，如

user=> (instance? Integer 10)
true

3. format包装了Java的format方法，格式化字符串：

(format fmt-string & args)，如

user=> (format "%s ran %d miles today" "Stu" 8)
"Stu ran 8 miles today"

说明：占位符详细参考Java相关文档。

4. bean包装JavaBean将其转换为不可变的Clojure映射：
(bean java-bean)，如：

user=> (import '(java.security MessageDigest))
java.security.MessageDigest

user=> (bean (MessageDigest/getInstance "SHA"))
{:provider #<Sun SUN version 1.6>, :digestLength 20, :class java.security.Messag
eDigest$Delegate, :algorithm "SHA"}

user=> (:digestLength (bean (MessageDigest/getInstance "SHA")))
20

=========
3.2  性能优化

----
使用原始类型

示例：

第一种计算方法：
user=> (defn sum-to [n]
   (loop [i 1 sum 0]
     (if (<= i n)
       (recur (inc i) (+ i sum))
       sum)))
#'user/sum-to

user=> (dotimes [_ 5] (time (sum-to 10000)))
"Elapsed time: 9.112735 msecs"
"Elapsed time: 5.394529 msecs"
"Elapsed time: 2.786857 msecs"
"Elapsed time: 2.731407 msecs"
"Elapsed time: 2.598431 msecs"

第二种计算方法：
user=> (defn integer-sum-to [n]
(let [n (int n)]
  (loop [i (int 1) sum (int 0)]
    (if (<= i n)
      (recur (inc i) (+ i sum))
      sum))))
#'user/integer-sum-to

user=> (dotimes [_ 5] (time (integer-sum-to 10000)))
"Elapsed time: 2.126595 msecs"
"Elapsed time: 1.82419 msecs"
"Elapsed time: 0.105251 msecs"
"Elapsed time: 0.055963 msecs"
"Elapsed time: 0.086769 msecs"

说明：
1. 第二种计算方法将n, i, sum当作int类型处理。

2. dotimes是一个计时函数
(dotimes bindings & body)
; bindings => name n

重复执行body代码，循环将name绑定到0到n-1，n即为重复次数。

----
添加类型暗示

通过 #^宏 给参数添加类型元数据。

Clojure支持给函数参数，let绑定，变量名及表达式添加类型暗示。

类型暗示的作用：
1. 优化关键性能，
2. 说明需要的类型，
3. 运行时强制转换为需要的类型。

示例：
user=> (defn describe-class [#^Class c]
  {:name (.getName c)
    :final (java.lang.reflect.Modifier/isFinal (.getModifiers c))})

user=> (describe-class StringBuffer)
{:name "java.lang.StringBuffer", :final true}

说明：给函数参数c添加类型暗示。


=======
3.3  使用Clojure创建和编译Java类

Clojure的所有对象都实现了Java的特定接口：
1. Clojure数据结构实现了Java集合接口。
2. Clojure函数实现了Runnable和Callable接口。

Clojure可以在需要时很方便地在磁盘上生成一次性的代理或类，使用必要的一些Java代码片段。

----
创建Java代理

（hxzon：创建代理的作用是什么？）

在Clojure中，可以使用代理来扩展一个类：
(proxy class-and-interfaces super-cons-args & fns)

示例：
(def print-element-handler
    (proxy [DefaultHandler] []
        (startElement
        [uri local qname atts]
        (println (format "Saw element: %s" qname)))))

说明：
1. proxy创建了代理类的一个实例；

2. proxy机制是完全通用的，可以用在任意Java对象。
user=> (.start (Thread.
              (proxy [Runnable] [] (run [] (println "I ran!")))))
user=> I ran!

3. 在Java中必须实现接口的所有方法，但在Clojure中不必如此，如：
user=> (proxy [Callable] [])
#<Object$Callable clojure.proxy.java.lang.Object$Callable@11e0c13>

如果忽略方法实现，Clojure将提供一个默认实现，该实现抛出异常UnsupportedOperationException，如：
user=> (.call (proxy [Callable] []))
java.lang.UnsupportedOperationException: call (NO_SOURCE_FILE:0)

Clojure的函数都自动实现Runable和Callable接口，下面举例说明：

; 正常用法：调用匿名函数
user=> (#(println "foo"))

; 调用run方法通过Runnable接口
user=> (.run #(println "foo"))

; 调用call方法通过Callable接口
user=> (.call #(println "foo"))

三种调用方法都输出foo。

----
编译到硬盘

生成 reader.tasklist类 的Clojure源代码：

(ns reader.tasklist
    (:gen-class
    :extends org.xml.sax.helpers.DefaultHandler
    :state state
    :init init)
    (:use [clojure.contrib.duck-streams :only (reader)])
    (:import [java.io File]
             [org.xml.sax InputSource]
             [org.xml.sax.helpers DefaultHandler]
             [javax.xml.parsers SAXParserFactory]))
(defn -main [& args]
   (dosseq [arg args]
       (println (task-list arg))))
(defn task-list [arg]
   (let [handler (new examples.tasklist)]
      (.. SAXParserFactory newInstance newSAXParser
          (parse (InputSource. (reader (File. arg)))
              handler))
      @(.state handler)))
(defn -init[]
   [[] (atom [])])
(defn -startElement
  [this uri local qname atts]
  (when (= qname "target")
    (swap! (.state this) conj (.getValue atts "name"))))

说明：
(1) :gen-class 指示Clojure生成Java类reader.tasklist

(2) :extends 指示生成类继承DefaultHandler（实现接口用:implements语句）

(3) Clojure生成Java类将类状态隔离到一个单独的状态结构，:state语句指定状态结构变量

(4) :init语句指定类初始化函数，初始化函数返回Java需要的基类构造函数参数和Clojure使用的初始状态结构

(5) Clojure生成reader.tasklist类，并创建方法；
这些方法代理你提供的函数，每个方法代理一个相同名字的函数，方法名以连接符(-)为前缀

----
Clojure提供compile函数：
(compile lib)

compile函数对运行环境要求很苛刻：
(1) 要编译的lib必须从classpath可以访问；
(2) 类文件生成目录(*complile-path*)必须在classpath中，默认为Clojure的启动目录。

Clojure为类本身生成一个class文件，为类的每个函数或方法生成一个类，
名字包含__init的类很特殊，它在第一次加载时执行lib的顶级代码。
Clojure的这种模块性允许我们在运行时动态替换单个函数。

=======
3.4  异常处理

异常处理的目的:
(1) 包装检查异常；
(2) 使用finally块清理非内存资源如文件或网络句柄；
(3) 响应问题：忽略异常，重新操作，转换异常为非异常结果。

----
简化异常处理

在Clojure中，检查异常不是必须进行try..catch处理，如果不处理则直接忽略异常。

----
资源清理

如果需要释放的资源有close方法，则可以使用with-open宏：
(with-open [name init-form] & body)

Clojure内部，with-open创建一个try块，将init-form的结果赋给name，
然后运行body，最后在finally块中释放绑定到name的资源。如：

(defn spit [f content]
  (with-open [#^PrintWriter w (writer f)]
    (.print w content)))

(spit "hello.out" "hello, world")

将字符串"hello, world"写入文件hello.out

----
如果需要在finally块中做close以外事情，可以使用如下形式：

(try expr* catch-clause* finally-clause?)
; catch-clause -> (catch classname name expr*)
; finally-clause -> (finally expr*)

----
响应异常

最常见的情况是在catch块中响应异常。

示例：验证类是否可以
(defn class-available? [class-name]
   (try
      (Class/forName class-name) true
      (catch ClassNotFoundException _ false)))

如果类找不到，则抛出ClassNotFoundException异常，返回false。

