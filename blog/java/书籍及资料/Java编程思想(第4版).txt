Java编程思想(第4版)
出版社: 机械工业出版社; 第4版 (2007年6月1日)
外文书名: thinking in java
平装: 880页
ISBN: 7111213823
条形码: 9787111213826
=======================
作者简介
作者：(美)埃史尔 译者：陈昊鹏

Bruce Eckel是MindView公司（www.MindView.net）的总裁，该公司向客户提供软件咨询和培训。他是C++标准委员会拥有表决权的成员之一，拥有应用物理学学士和计算机工程硕士学位。除本书外，他还是《C++编程思想》的作者，并与人合著了《C++编程思想 第2卷》（这两本书的英文影印版及中文版均已由机械工业出版社引进出版）及其他著作。他已经发表了150多篇论文，还经常参加世界各地的研讨会并进行演讲。
================================
译者序
　　时隔两年多，《Java编程思想（第4版）》的中文版又要和广大Java程序员和爱好者们见面了。这是Java语言本身不断发展和完善的必然要求，也是本书作者Bruce Eckel孜孜不倦的创作激情和灵感所结出的硕果。

　　《Java编程思想（第4版）》以Java最新的版本JDK5.0为基础，在第3版的基础上，添加了最新的语言特性，并且对第3版的结构进行了调整，使得所有章节的安排更加遵照循序渐进的特点，同时每一章的内容在分量上也都更加均衡，这使读者能够更加容易地阅读本书并充分了解每章所讲述的内容。在这里我们再次向Bruce Eckel致敬，他不但向我们展示了什么样的书籍才是经典书籍，而且还展示了经典书籍怎样才能精益求精，长盛不衰。

　　Java已经成为了编程语言的骄子。我们可以看到，越来越多的大学在教授数据结构、程序设计和算法分析等课程时，选择以Java语言为载体。这说明Java语言已经是人们构建软件系统时主要使用的一种编程语言。但是，掌握好Java语言并不是一件可以轻松完成的任务，如何真正掌握Java语言，从而编写出健壮的、高效的以及灵活的程序是Java程序员们面临的重大挑战。

　　《Java编程思想（第4版）》就是一本能够让Java程序员轻松面对这一挑战，并最终取得胜利的经典书籍。本书深入浅出、循序渐进地把我们领入Java的世界，让我们在不知不觉中就学会了用Java的思想去考虑问题、解决问题。本书不仅适合Java的初学者，更适合于有经验的Java程序员，这正是本书的魅力所在。但是，书中并没有涵盖Java所有的类、接口和方法，因此，如果你希望将它当作Java的字典来使用，那么显然就要失望了。

　　我们在翻译本书的过程中力求忠于原著，为了保持连贯性，对原书第3版中仍然保持不变的部分，我们对译文除了个别地方之外，也没做修改。对于本书中出现的大量的专业术语尽量遵循标准的译法，并在有可能引起歧义之处注有英文原文，以方便读者对照与理解。

　　全书由陈昊鹏翻译，郭嘉也参与了部分翻译工作。由于水平有限，书中出现错误与不妥之处在所难免，恳请读者批评指正。
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　译 者
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　2007年5月

读者评价
· 每个Java程序员都应该反复研读《Think in Java》，并且随身携带以便随时参考。书中的练习颇具挑战性，而有关集合的章节已臻化境！本书不仅帮助我通过了Sun Certified Java Programmer考试，而且它还是我遇到Java问题时，求助的首选书籍。
　　　　　　　　　　　　　　　　　　 ——Jim Pleger, Loudoun郡（弗吉尼亚）政府

· 这本书比我见过的所有Java书都要好得多。循序渐进……非常完整，并搭配恰到好处的范例，睿智而不呆板的解说……这使本书的品质比别的书“超出了一个数量级”。与其他Java书相比，我发现本书考虑非常周全、前后一致、理性坦诚、文笔流畅、用词准确。恕我直言，这是一本学习Java的理想书籍。
　　　　　　　　　　　　　　　　　　 ——Anatoly Vorobey, 以色列海法Technion大学

· 在我所见过的程序设计指南中（无论何种语言），这绝对是最好的一本。
　　　　　　　　　　　　　　　　　　 ——Joakim Ziegler, FIX系统管理员

· 感谢您这本精彩的、令人愉快的Java书。
　　　　　　　　　　　　　　　　　　 ——Dr. Gavin Pillay, 登记员, 南非爱德华八世医院

· 再次感谢您这本杰出的书。作为一名不用C语言的程序员，我曾经感到（学习Java）步履维艰，但是您的书让我一目了然。能够一开始就理解底层的概念和原理，而不是通过反复试验来自己建立概念模型，真是太棒了。我希望能在不久的将来参加您的讨论课。
　　　　　　　　　　　　　　　　　　 ——Randall R. Hawley, 自动化工程师, Eli Lilly公司

· 我见过的计算机著作中，这是最好的一本。
　　　　　　　　　　　　　　　　　　 ——Tom Holland

· 这是我读过的编程语言书中最棒的一本……有关Java的书中最棒的一本。
　　　　　　　　　　　　　　　　　　 ——Ravindra Pai, Oracle 公司, SUNOS 产品线部门

· 我见过的最好的Java书！您做了一项了不起的工作。您的深度令人赞叹，出版的时候，我一定会购买一本。我从1996年10月就开始学习Java，其间也读过好几本这方面的书，但我觉得您这本才是“必读书”。最近几个月，我一直集中精力于一个完全用Java开发的产品。您的书帮我夯实了某些不牢固的知识点，并拓展了我的知识面。我甚至在面试签约者时引用书中的内容，作为参考的依据。通过问一些我从书中学到的知识，来判断他们对Java的理解程度（例如，数组与Vector的区别）。您的书真是伟大！
　　　　　　　　　　　　　　　　　　 ——Steve Wilkinson, 资深专家, MCI 电信公司

· 伟大的书。迄今为止我见过的最佳Java书籍。
　　　　　　　　　　　　　　　　　　 ——Jeff Sinclair, 软件工程师, Kestral 计算技术公司

? 感谢您的《Thinking in Java》。早就应该有人把仅仅介绍语言的教程编写成富有思想、分析透彻的入门指南，而不是局限于“某个公司”的语言。我阅读过许多这方面的书，但只有您和Patrick Winston的作品给我印象深刻。我已经向客户推荐这本书。再次谢谢您。
　　　　　　　　　　　　　　　　　　 ——Richard Brooks, Java 咨询顾问, 达拉斯Sun专业服务部门

· Bruce，您的书真是太棒了！您的讲解清晰明确。通过这本迷人的书，我获得了大量Java知识。练习题也同样令人着迷，它们对巩固各章阐述的知识起到了很好的效果。我期待您的更多作品。对您的这本著作致以谢意。阅读了《Thinking in Java》之后，我的代码质量大有改善。为此我要感激您，我相信，维护我的代码的程序员同样也会感激您。
　　　　　　　　　　　　　　　　　　 ——Yvonne Watkins, Discover 技术公司 
==========================
目录

第1章   对象导论     1
第2章   一切都是对象     21
第3章   操作符       38
第4章   控制执行流程     64
第5章   初始化与清理     76
第6章   访问权限控制     109
第7章   复用类       125
第8章   多态  148
第9章   接口  169
第10章   内部类     190
第11章   持有对象 216
第12章   通过异常处理错误    248
第13章   字符串     283
第14章   类型信息 313
第15章   泛型         352
第16章   数组         433
第17章   容器深入研究   459
第18章   Java I/O系统    525
第19章   枚举类型 590
第20章   注解         620
第21章   并发         650
第22章   图形化用户界面        768

附录A   补充材料    856
附录B   资源  859
索引 863
==========================
目录

第1章   对象导论     1
1.1   抽象过程 1
1.2   每个对象都有一个接口     2
1.3   每个对象都提供服务         4
1.4   被隐藏的具体实现    4
1.5   复用具体实现  5
1.6   继承         6
1.6.1   “是一个”与“像是一个”关系     8
1.7   伴随多态的可互换对象     8
1.8   单根继承结构  11
1.9   容器         11
1.9.1   参数化类型（范型）      12
1.10   对象的创建和生命期       13
1.11   异常处理：处理错误       14
1.12   并发编程        14
1.13   Java与Internet        15
1.13.1   Web是什么 15
1.13.2   客户端编程 16
1.13.3   服务器端编程       19
1.14   总结       20

第2章   一切都是对象     21
2.1   用引用操纵对象        21
2.2   必须由你创建所有对象     22
2.2.1   存储到什么地方     22
2.2.2   特例：基本类型     23
2.2.3   Java中的数组         24
2.3   永远不需要销毁对象         24
2.3.1   作用域  24
2.3.2   对象的作用域         25
2.4   创建新的数据类型：类     25
2.4.1   字段和方法   26
2.5   方法、参数和返回值         27
2.5.1   参数列表       27
2.6   构建一个Java程序   28
2.6.1   名字可见性   28
2.6.2   运用其他构件         28
2.6.3   static 关键字 29
2.7   你的第一个Java程序        30
2.7.1   编译和运行   31
2.8   注释和嵌入式文档    32
2.8.1   注释文档       32
2.8.2   语法      33
2.8.3   嵌入式HTML        33
2.8.4   一些标签示例         34
2.8.5   文档示例       35
2.9   编码风格 36
2.10   总结       36
2.11   练习       37

第3章   操作符       38
3.1   更简单的打印语句    38
3.2   使用Java操作符       39
3.3   优先级     39
3.4   赋值         39
3.4.1   方法调用中的别名问题  40
3.5   算术操作符      41
3.5.1   一元加、减操作符 43
3.6   自动递增和递减        43
3.7   关系操作符      44
3.7.1   测试对象的等价性 44
3.8   逻辑操作符      45
3.8.1  短路        46
3.9   直接常量 47
3.9.1   指数记数法   48
3.10   按位操作符    49
3.11   移位操作符    49
3.12   三元操作符 if-else  52
3.13   字符串操作符 + 和 +=  53
3.14  使用操作符时常犯的错误 54
3.15   类型转换操作符      54
3.15.1   截尾和舍入 55
3.15.2   提升    56
3.16   Java没有sizeof       56
3.17   操作符小结    56
3.18   总结       63

第4章   控制执行流程     64
4.1   true和false       64
4.2   if-else       64
4.3   迭代         65
4.3.1   do-while         65
4.3.2   for         66
4.3.3   逗号操作符   67
4.4   Foreach语法     67
4.5   return       69
4.6   break和 continue      69
4.7   臭名昭著的goto        70
4.8   switch      73
4.9   总结         75

第5章   初始化与清理     76
5.1   用构造器确保初始化         76
5.2   方法重载 77
5.2.1   区分重载方法         79
5.2.2   涉及基本类型的重载      79
5.2.3   以返回值区分重载方法  82
5.3   默认构造器      83
5.4   this关键字       84
5.4.1   在构造器中调用构造器  85
5.4.2   static的含义  86
5.5   清理：终结处理和垃圾回收      87
5.5.1   finalize()的用途何在        87
5.5.2   你必须实施清理     88
5.5.3   终结条件       88
5.5.4   垃圾回收器如何工作      89
5.6   成员初始化      91
5.6.1   指定初始化   93
5.7   构造器初始化  94
5.7.1   初始化顺序   94
5.7.2   静态数据的初始化 95
5.7.3   显式的静态初始化 96
5.7.4   非静态实例初始化 97
5.8   数组初始化      98
5.8.1   可变参数列表         102
5.9   枚举类型 105
5.10   总结       107

第6章   访问权限控制     109
6.1   包：库单元      110
6.1.1   代码组织       110
6.1.2   创建独一无二的包名      111
6.1.3   定制工具库   114
6.1.4   用 import改变行为        115
6.1.5   对使用包的忠告     115
6.2   Java访问权限修饰词         116
6.2.1   包访问权限   116
6.2.2   public:接口访问权限       116
6.2.3   private: 你无法访问        118
6.2.4   protected：继承访问权限        118
6.3   接口和实现      120
6.4   类的访问权限  121
6.5   总结         123

第7章   复用类       125
7.1   组合语法 125
7.2   继承语法 127
7.2.1   初始化基类   129
7.3   代理         130
7.4   结合使用组合和继承         132
7.4.1   确保正确清理         133
7.4.2   名称屏蔽       135
7.5   在组合与继承之间选择     137
7.6   protected关键字       138
7.7   向上转型 139
7.7.1   为什么称为向上转型      139
7.7.2   再论组合与继承     140
7.8   final关键字      140
7.8.1   final 数据      140
7.8.2   final 方法      143
7.8.3   final 类 144
7.8.4   有关final的忠告    145
7.9   初始化及类的加载    145
7.9.1   继承与初始化         146
7.10   总结       147

第8章   多态  148
8.1   再论向上转型  148
8.1.1   忘记对象类型         149
8.2   转机         150
8.2.1   方法调用绑定         150
8.2.2   产生正确的行为     151
8.2.3   可扩展性       153
8.2.4   缺陷：“覆盖”私有方法         156
8.2.5   缺陷：域与静态方法      156
8.3   构造器和多态  157
8.3.1   构造器的调用顺序 157
8.3.2   继承与清理   159
8.3.3   构造器内部的多态方法的行为         162
8.4   协变返回类型  164
8.5   用继承进行设计        165
8.5.1   纯继承与扩展         166
8.5.2   向下转型与运行时类型识别   167
8.6   总结         168

第9章   接口  169
9.1   抽象类和抽象方法    169
9.2   接口         172
9.3   完全解耦 174
9.4   Java中的多重继承    178
9.5   通过继承来扩展接口         180
9.5.1   组合接口时的名字冲突  181
9.6   适配接口 181
9.7   接口中的域      183
9.7.1   初始化接口中的域 184
9.8   嵌套接口 185
9.9   接口与工厂      186
9.10   总结       188

第10章   内部类     190
10.1   创建内部类    190
10.2   链接到外部类          191
10.3   使用.this与.new      193
10.4   内部类与向上转型  194
10.5   在方法和作用域内的内部类    195
10.6   匿名内部类    196
10.6.1   再访工厂方法       199
10.7   嵌套类   201
10.7.1   接口内部的类       202
10.7.2   从多层嵌套类中访问外部类的成员 203
10.8   为什么需要内部类  204
10.8.1   闭包与回调 205
10.8.2   内部类与控制框架        207
10.9   内部类的继承          212
10.10   内部类可以被覆盖吗     212
10.11   局部内部类  214
10.12   内部类标识符        215
10.13   总结     215

第11章   持有对象 216
11.1   泛型和类型安全的容器   216
11.2   基本概念        219
11.3   添加一组元素          220
11.4   容器的打印    221
11.5  List 223
11.6   迭代器   226
11.6.1   ListIterator   227
11.7   LinkedList       228
11.8   Stack      229
11.9   Set 231
11.10   Map     233
11.11   Queue   236
11.11.1   PriorityQueue      237
11.12   Collection和Iterator       238
11.13   Foreach与迭代器  241
11.13.1   适配器方法惯用法      243
11.14   总结     248

第12章   通过异常处理错误    248
12.1   概念       249
12.2   基本异常        249
12.2.1   异常参数     250
12.3   捕获异常        250
12.3.1   try块  250
12.3.2   异常处理程序       250
12.4   创建自定义异常      251
12.4.1 异常与记录日志       253
12.5   异常说明        256
12.6   捕获所有异常          256
12.6.1   栈轨迹         257
12.6.2   重新抛出异常       258
12.6.3   异常链         260
12.7   Java标准异常          263
12.7.1   特例：RuntimeException        263
12.8   使用finally进行清理       264
12.8.1   finally用来做什么         265
12.8.2   在return中使用finally 267
12.8.3   缺憾：异常丢失   268
12.9   异常的限制    269
12.10   构造器 271
12.11   异常匹配      275
12.12   其他可选方式        276
12.12.1   历史  277
12.12.2   观点  278
12.12.3   把异常传递给控制台  279
12.12.4   把“被检查的异常”转换为“不受检查的异常”    279
12.13   异常使用指南        281
12.14   总结     281

第13章   字符串     283
13.1   不可变String  283
13.2   重载“+”与StringBuilder        283
13.3   无意识的递归          287
13.4   String上的操作       288
13.5   格式化输出    289
13.5.1   printf()         289
13.5.2   System.out.format()       289
13.5.3   Formatter类          290
13.5.4   格式化说明符       291
13.5.5   Formatter转换      292
13.5.6   String.format()       294
13.6   正则表达式    295
13.6.1   基础    295
13.6.2   创建正则表达式   297
13.6.3   量词    299
13.6.4   Pattern和Matcher         300
13.6.5   split()  305
13.6.6   替换操作     306
13.6.7   reset()  307
13.6.8   正则表达式与Java I/O  307
13.7   扫描输入        309
13.7.1   Scanner定界符     310
13.7.2   用正则表达式扫描        311
13.8   StringTokenizer        312
13.9   总结       312

第14章   类型信息 313
14.1   为什么需要RTTI    313
14.2   Class对象       314
14.2.1   类字面常量 318
14.2.2   泛化的Class引用         320
14.2.3   新的转型语法       322
14.3   类型转换前先做检查       322
14.3.1   使用类字面常量   327
14.3.2   动态的instanceof 329
14.3.3   递归计数     330
14.4   注册工厂        331
14.5   instanceof 与 Class的等价性  333
14.6   反射：运行时的类信息   334
14.6.1   类方法提取器       335
14.7   动态代理        337
14.8   空对象   341
14.8.1   模拟对象与桩       346
14.9   接口与类型信息      346
14.10   总结     350

第15章   泛型         352
15.1   与C++的比较         352
15.2   简单泛型        353
15.2.1   一个元组类库       354
15.2.2   一个堆栈类 356
15.2.3   RandomList  357
15.3   泛型接口        358
15.4   泛型方法        361
15.4.1   杠杆利用类型参数推断         362
15.4.2   可变参数与泛型方法    363
15.4.3   用于Generator的泛型方法   364
15.4.4   一个通用的Generator   364
15.4.5   简化元组的使用   366
15.4.6   一个Set实用工具         367
15.5   匿名内部类    369
15.6   构建复杂模型          371
15.7   擦除的神秘之处      372
15.7.1   C++的方式  373
15.7.2   迁移兼容性 375
15.7.3   擦除的问题 376
15.7.4   边界处的动作       377
15.8   擦除的补偿    380
15.8.1   创建类型实例       381
15.8.2   泛型数组     383
15.9   边界       386
15.10   通配符 389
15.10.1   编译器有多聪明 391
15.10.2   逆变  393
15.10.3   无界通配符         395
15.10.4   捕获转换   399
15.11   问题     400
15.11.1   任何基本类型都不能作为类型参数 400
15.11.2   实现参数化接口 401
15.11.3   转型和警告         402
15.11.4   重载  403
15.11.5   基类劫持了接口 404
15.12   自限定的类型        404
15.12.1   古怪的循环泛型 404
15.12.2   自限定       405
15.12.3   参数协变   407
15.13   动态类型安全        409
15.14   异常     410
15.15   混型     412
15.15.1   C++中的混型     412
15.15.2   与接口混合         413
15.15.3   使用装饰器模式 414
15.15.4   与动态代理混合 415
15.16   潜在类型机制        416
15.17   对缺乏潜在类型机制的补偿  420
15.17.1   反射  420
15.17.2   将一个方法应用于序列       421
15.17.3   当你并未碰巧拥有正确的接口时 423
15.17.4   用适配器仿真潜在类型机制         424
15.18   将函数对象用作策略     426
15.19   总结：转型真的如此之糟吗？        430
15.19.1   进阶读物   432

第16章   数组         433
16.1   数组为什么特殊      433
16.2   数组是第一级对象  434
16.3   返回一个数组          436
16.4   多维数组        437
16.5   数组与泛型    440
16.6   创建测试数据          442
16.6.1   Arrays.fill()  442
16.6.2   数据生成器 443
16.6.3   从Generator中创建数组       447
16.7   Arrays实用功能     450
16.7.1   复制数组     450
16.7.2   数组的比较 451
16.7.3   数组元素的比较   452
16.7.4   数组排序     454
16.7.5   在已排序的数组中查找         455
16.8   总结       457

第17章   容器深入研究   459
17.1   完整的容器分类法  459
17.2   填充容器        460
17.2.1   一种Generator解决方案       460
17.2.2   Map生成器          462
17.2.3   使用Abstract类   464
17.3   Collection的功能方法      470
17.4   可选操作        472
17.4.1   未获支持的操作   473
17.5   List的功能方法      474
17.6   Set和存储顺序        477
17.6.1   SortedSet      479
17.7   队列       480
17.7.1   优先级队列 481
17.7.2   双向队列     482
17.8   理解Map       483
17.8.1   性能    484
17.8.2   SortedMap   486
17.8.3   LinkedHashMap   487
17.9   散列与散列码          488
17.9.1   理解hashCode()   490
17.9.2   为速度而散列       492
17.9.3   覆盖hashCode()   495
17.10   选择接口的不同实现     499
17.10.1   性能测试框架     499
17.10.2   对List的选择    502
17.10.3   微基准测试的危险      507
17.10.4   对Set的选择      508
17.10.5   对Map的选择   509
17.11   实用方法      512
17.11.1   List的排序和查询       514
17.11.2   设定Collection或Map为不可修改 515
17.11.3   Collection或Map的同步控制     516
17.12   持有引用      518
17.12.1   WeakHashMap    519
17.13   Java 1.0/1.1 的容器        520
17.13.1   Vector 和 Enumeration         520
17.13.2   Hashtable   521
17.13.3   Stack 521
17.13.4   BitSet         522
17.14   总结     524

第18章   Java I/O系统    525
18.1   File类    525
18.1.1   目录列表器 525
18.1.2   目录实用工具       528
18.1.3   目录的检查及创建        532
18.2   输入和输出    533
18.2.1   InputStream类型  534
18.2.2   OutputStream类型        535
18.3   添加属性和有用的接口   535
18.3.1   通过FilterInputStream从InputStream读取数据   535
18.3.2   通过FilterOutPutStream向OutputStream写入        536
18.4   Reader和Writer      537
18.4.1   数据的来源和去处        537
18.4.2   更改流的行为       538
18.4.3   未发生变化的类   539
18.5   自我独立的类：RandomAccessFile   539
18.6   I/O流的典型使用方式     539
18.6.1   缓冲输入文件       540
18.6.2   从内存输入 540
18.6.3   格式化的内存输入        541
18.6.4   基本的文件输出   542
18.6.5   存储和恢复数据   543
18.6.6   读写随机访问文件        544
18.6.7   管道流         545
18.7   文件读写的实用工具       545
18.7.1   读取二进制文件   548
18.8   标准I/O 548
18.8.1   从标准输入中读取        548
18.8.2   将System.out转换成PrintWriter   549
18.8.3   标准I/O重定向   549
18.9   进程控制        550
18.10   新I/O   551
18.10.1   转换数据   554
18.10.2   获取基本类型     556
18.10.3   视图缓冲器         557
18.10.4   用缓冲器操纵数据      560
18.10.5   缓冲器的细节     560
18.10.6   内存映射文件     563
18.10.7   文件加锁   566
18.11   压缩     568
18.11.1   用GZIP进行简单压缩        568
18.11.2   用Zip进行多文件保存       569
18.11.3   Java档案文件     570
18.12   对象序列化  571
18.12.1   寻找类       574
18.12.2   序列化的控制     575
18.12.3   使用“持久性” 581
18.13   XML    586
18.14   Preferences    588
18.15   总结     589

第19章   枚举类型 590
19.1   基本enum特性       590
19.1.1   将静态导入用于enum  591
19.2   向enum中添加新方法    591
19.2.1   覆盖enum的方法         592
19.3   switch语句中的enum      593
19.4   values()的神秘之处 594
19.5   实现，而非继承      596
19.6   随机选取        596
19.7   使用接口组织枚举  597
19.8   使用EnumSet替代标志   600
19.9   使用EnumMap       602
19.10   常量相关的方法    603
19.10.1   使用enum的职责链   606
19.10.2   使用enum的状态机   609
19.11   多路分发      613
19.11.1   使用enum分发  615
19.11.2   使用常量相关的方法  616
19.11.3   使用EnumMap分发   618
19.11.4   使用二维数组     618
19.12   总结     619

第20章   注解         620
20.1   基本语法        620
20.1.1   定义注解     621
20.1.2   元注解         622
20.2   编写注解处理器      622
20.2.1   注解元素     623
20.2.2   默认值限制 624
20.2.3   生成外部文件       624
20.2.4   注解不支持继承   627
20.2.5   实现处理器 627
20.3   使用apt处理注解  629
20.4   将观察者模式用于apt     632
20.5   基于注解的单元测试       634
20.5.1   将@Unit用于泛型        641
20.5.2   不需要任何“套件”    642
20.5.3   实现@Unit  642
20.5.4   移除测试代码       647
20.6   总结       649

第21章   并发         650
21.1   并发的多面性          651
21.1.1   更快的执行 651
21.1.2   改进代码设计       653
21.2   基本的线程机制      653
21.2.1   定义任务     654
21.2.2   Thread类     655
21.2.3   使用Executor        656
21.2.4   从任务中产生返回值    658
21.2.5   休眠    659
21.2.6   优先级         660
21.2.7   让步    661
21.2.8   后台线程     662
21.2.9   编码的变体 665
21.2.10   术语  669
21.2.11   加入一个线程     669
21.2.12   创建有响应的用户界面       671
21.2.13   线程组       672
21.2.14   捕获异常   672
21.3   共享受限资源          674
21.3.1   不正确地访问资源        674
21.3.2   解决共享资源竞争        676
21.3.3   原子性与易变性   680
21.3.4   原子类         684
21.3.5   临界区         685
21.3.6   在其他对象上同步        689
21.3.7   线程本地存储       690
21.4   终结任务        691
21.4.1   装饰性花园 691
21.4.2   在阻塞时终结       694
21.4.3   中断    695
21.4.4   检查中断     701
21.5   线程之间的协作      702
21.5.1   wait()与notifyAll()        703
21.5.2   notify()与notifyAll()     707
21.5.3   生产者与消费者   709
21.5.4   生产者-消费者与队列   713
21.5.5   任务间使用管道进行输入/输出      717
21.6   死锁       718
21.7   新类库中的构件      722
21.7.1   CountDownLatch  722
21.7.2   CyclicBarrier         724
21.7.3   DelayQueue 726
21.7.4   PriorityBlockingQueue   728
21.7.5   使用ScheduledExecutor的温室控制器 730
21.7.6   Semaphore    733
21.7.7   Exchanger     735
21.8   仿真       737
21.8.1   银行出纳员仿真   737
21.8.2   饭店仿真     741
21.8.3   分发工作     744
21.9   性能调优        748
21.9.1   比较各类互斥技术        748
21.9.2   免锁容器     754
21.9.3   乐观加锁     760
21.9.4   ReadWriteLock      761
21.10   活动对象      763
21.11   总结     766
21.12   进阶读物      767

第22章   图形化用户界面        768
22.1   applet    769
22.2   Swing基础      769
22.2.1   一个显示框架       771
22.3   创建按钮        772
22.4   捕获事件        773
22.5   文本区域        774
22.6   控制布局        776
22.6.1   BorderLayout        776
22.6.2   FlowLayout 776
22.6.3   GridLayout  777
22.6.4   GridBagLayout      777
22.6.5   绝对定位     778
22.6.6   BoxLayout   778
22.6.7   最好的方式是什么        778
22.7   Swing事件模型       778
22.7.1   事件与监听器的类型    779
22.7.2   跟踪多个事件       783
22.8   Swing组件一览       785
22.8.1   按钮    785
22.8.2   图标    787
22.8.3   工具提示     788
22.8.4   文本域         789
22.8.5   边框    790
22.8.6   一个迷你编辑器   791
22.8.7   复选框         792
22.8.8   单选按钮     793
22.8.9   组合框         793
22.8.10   列表框       794
22.8.11   页签面板   796
22.8.12   消息框       796
22.8.13   菜单  798
22.8.14   弹出式菜单         802
22.8.15   绘图  803
22.8.16   对话框       805
22.8.17   文件对话框         808
22.8.18   Swing组件上的HTML        809
22.8.19   滑块与进度条     810
22.8.20   选择外观   811
22.8.21   树、表格和剪贴板      812
22.9   JNLP与Java Web Start    812
22.10   Swing与并发         816
22.10.1   长期运行的任务 816
22.10.2   可视化线程机制 822
22.11   可视化编程与JavaBean 823
22.11.1   JavaBean是什么 824
22.11.2   使用Introspector抽取出BeanInfo        825
22.11.3   一个更复杂的Bean     829
22.11.4   JavaBean与同步 831
22.11.5   把Bean打包       834
22.11.6   对Bean更高级的支持         835
22.11.7   有关Bean的其他读物         836
22.12   Swing的可替代选择      836
22.13   用Flex构建Flash Web客户端        836
22.13.1   Hello, Flex  837
22.13.2   编译MXML      838
22.13.3   MXML与ActionScript       838
22.13.4   容器与控制         839
22.13.5   效果与样式         840
22.13.6   事件  841
22.13.7   连接到Java         841
22.13.8   数据模型与数据绑定  843
22.13.9   构建和部署         843
22.14   创建SWT应用     844
22.14.1   安装SWT  845
22.14.2   Hello, SWT          845
22.14.3   根除冗余代码     847
22.14.4   菜单  848
22.14.5   页签面板、按钮和事件       849
22.14.6   图形  852
22.14.7   SWT中的并发   853
22.14.8   SWT还是Swing 855
22.15   总结     855
22.15.1   资源  855

附录A   补充材料    856
可下载的补充材料
Thinking in C：Java的基础
Java编程思想 研讨课
Hands-on Java研讨课CD
Thinking in Objects研讨课
Thinking in Enterprise Java
Thinking in Patterns(with Java)
Thinking in Patterns研讨课
设计咨询与复审

附录B   资源  859
软件
编辑器与IDE
书籍
分析与设计
Python
我的著作列表

索引 863