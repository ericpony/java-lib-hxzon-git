ErlangOTP并发编程实战

洛根(Martin Logan) (作者), 梅里特(Eric Merritt) (作者), 卡尔森(Richard Carlsson) (作者), 连城 (译者)
=========
出版社: 人民邮电出版社; 第1版 (2012年8月1日)
外文书名: Erlang and OTP in Acrion
丛书名: 图灵程序设计丛书
平装: 333页
语种： 简体中文
开本: 16
ISBN: 9787115285591, 7115285594
==========
编辑推荐

《Erlang/OTP并发编程实战》讲述了如果将Erlang语言看成才华横溢的钢琴家，
那么OTP平台就是一架能让钢琴家把才能发挥得淋漓尽致的钢琴。
《Erlang/OTP并发编程实战》除了全面介绍Erlang语言和OTP平台的基础知识外，
还通过一系列实用案例引领你深入了解OTP的高级特性，一步步构建一个大型生产系统，并加以优化和完善。
三位作者在Erlang领域拥有极其丰富的实战经验，细致入微地剖析了OTP开发与部署的全过程。
要想真刀真枪地上战场。《Erlang/OTP并发编程实战》才是你明智的选择！

名人推荐

“惊艳！不管是对于初学者还是Erlang高手，本书绝对都是不容错过的好书。” 
——Amazon.com书评 

“多核处理器和并发编程是将来的重头戏。ErIang在下一代编程语言中可谓独领风骚！” 
——DZone书评 

“Erlang开发者必备两本书，一本是ErIang之父Joe Arrrlstrong的《Erlang程序设计》，
另一本就是本书——务实、高效又不失幽默风趣的好书啊！” 
——slashdot.org书评

----
作者简介

作者：（美国）洛根（Martin Logan）（美国）梅里特（Eric Merritt）（瑞典）卡尔森（Richard Carlsson） 译者：连城 

洛根（Martin Logan），从1999年开始活跃于Erlang社区。
后来全职从事Erlang研发。
目前任职于全球最大的在线旅游公司OrbitzWorldwide，为基于大规模分布式服务的基础设施开发解决方案。
Erlware联合创始人，核心开发人员。
Erlang／OTP软件包管理系统Faxien的主要开发者。 

梅里特（Eric Merritt），专注并发编程和分布式系统。
曾任职于Amazon.com，现为eCD Market软件工程师。
Erlware联合创始人，Erlang芝加哥用户组核心成员。
Erlware团队开源产品核心开发人员，Erlang／OTP构建系统Sinan的主要开发者。 

卡尔森（Richard Carlsson），瑞典乌普萨拉大学高性能Erlang计划（HiPE）早期成员。
研究Erlang技术达17年，曾为标准库、Erlang编译器、运行时系统和Erlang语言本身都作出过不少贡献。
此外。他还是ErIang文档系统Edoc和单元测试框架Eunit的创建者。
目前加入了Kreditor。致力于高可用性支付系统的Erlang开发。 

连城，百度资深软件工程师，《Erlang并发编程（第一部分）》社区翻译项目组织者及主要译者。
对分布式存储、分布式消息系统、程序语言设计实现抱有浓厚兴趣。

============
目录


第一部分 Erlang起步：OTP基础 

第1章 Erlang/OTP平台 
第2章 Erlang语言精要 
第3章 开发基于TCP的RPC服务 
第4章 OTP应用与监督机制 
第5章 主要图形化监测工具的使用 

第二部分 构建生产系统 

第6章 打造一套缓存系统 
第7章 Erlang/OTP中的日志与事件处理 
第8章 分布式Erlang/OTP简介 
第9章 用Mnesia为cache增加分布式支持 
第10章 打包、服务和部署 

第三部分 集成与完善 

第11章 为缓存添加HTTP接口 
第12章 用端口和NIF集成外围代码 
第13章 用Jinterface实现Erlang和Java间的通信 
第14章 优化与性能 

附录A 安装Erlang 
附录B 列表与引用透明性 （hxzon：即值不会被改变。）
=================
目录


第一部分 Erlang起步：OTP基础 


第1章 Erlang/OTP平台 

1.1 基于进程的并发编程 
1.1.1 理解并发 
1.1.2 Erlang的进程模型 
1.1.3 4种进程通信范式 
1.1.4 用Erlang进程编程 

1.2 Erlang的容错架构 
1.2.1 进程链接如何工作 
1.2.2 监督与退出信号捕捉 
1.2.3 进程的分层容错 

1.3 分布式Erlang 

1.4 Erlang运行时系统和虚拟机 
1.4.1 调度器 
1.4.2 I/O与调度 
1.4.3 进程隔离与垃圾回收器 

1.5 函数式编程：Erlang的处世之道 
1.6 小结 


第2章 Erlang语言精要 

2.1 Erlang shell 
2.1.1 启动shell 
2.1.2 输入表达式 
2.1.3 shell函数 
2.1.4 退出shell 
2.1.5 任务控制基础 

2.2 Erlang的数据类型 
2.2.1 数值与算术运算 
2.2.2 二进制串与位串 
2.2.3 原子 
2.2.4 元组 
2.2.5 列表 
2.2.6 字符串 
2.2.7 pid、端口和引用 
2.2.8 将函数视作数据：fun函数 
2.2.9 项式的比较 
2.2.10 解读列表 

2.3 模块和函数 
2.3.1 调用其他模块中的函数（远程调用） 
2.3.2 不同元数的函数 
2.3.3 内置函数和标准库模块 
2.3.4 创建模块 
2.3.5 模块的编译和加载 
2.3.6 独立编译器erlc 
2.3.7 已编译模块与在shell中求值 

2.4 变量与模式匹配 
2.4.1 变量的语法 
2.4.2 单次赋值 
2.4.3 模式匹配：加强版的赋值 
2.4.4 解读模式 

2.5 函数与子句 
2.5.1 带副作用的函数：文本打印 
2.5.2 用模式匹配在多个子句中进行选择 
2.5.3 保护式 
2.5.4 模式、子句和变量作用域 

2.6 Case和if表达式 
2.6.1 Erlang的布尔型if-then-else分支选择 
2.6.2 If表达式 

2.7 fun函数 
2.7.1 作为现有函数别名的fun函数 
2.7.2 匿名fun函数 

2.8 异常与try/catch 
2.8.1 抛出（触发）异常 
2.8.2 运用try...catch 
2.8.3 try...of...catch 
2.8.4 after 
2.8.5 获取栈轨迹 
2.8.6 重抛异常 
2.8.7 传统的catch 

2.9 列表速构 
2.9.1 列表速构记法 
2.9.2 映射、过滤和模式匹配 

2.10 比特位语法与位串速构 
2.10.1 构造位串 
2.10.2 比特位语法中的模式匹配 
2.10.3 位串速构 

2.11 记录语法 
2.11.1 记录声明 
2.11.2 创建记录 
2.11.3 记录的字段以及模式匹配 
2.11.4 更新记录字段 
2.11.5 记录声明应该放在哪儿 

2.12 预处理与文件包含 
2.12.1 宏的定义和使用 
2.12.2 文件包含 
2.12.3 条件编译 

2.13 进程 
2.13.1 操纵进程 
2.13.2 消息接收与选择性接收 
2.13.3 注册进程 
2.13.4 消息投递与信号 
2.13.5 进程字典 

2.14 ETS表 
2.14.1 为何ETS表被设计成这样 
2.14.2 ETS表的基本用法 

2.15 以递归代替循环 
2.15.1 从迭代到递归 
2.15.2 理解尾递归 
2.15.3 累加器参数 
2.15.4 谈谈效率 
2.15.5 编写递归函数的窍门 

2.16 Erlang编程资源 
2.16.1 图书 
2.16.2 在线资料 
2.17 小结 


第3章 开发基于TCP的RPC服务 

3.1 你所创建的是什么 
3.1.1 基础知识提醒 
3.1.2 行为模式基础 

3.2 实现RPC服务器 
3.2.1 行为模式实现模块的典型布局 
3.2.2 模块首部 
3.2.3 API段 
3.2.4 回调函数段 

3.3 运行RPC服务器 
3.4 浅谈测试 
3.5 小结 


第4章 OTP应用与监督机制 

4.1 OTP应用 
4.1.1 OTP应用的组织形式 
4.1.2 为应用添加元数据 
4.1.3 应用行为模式 
4.1.4 应用结构小结 

4.2 用监督者实现容错 
4.2.1 实现监督者 
4.2.2 监督者重启策略 
4.2.3 编写子进程规范 

4.3 启动应用 
4.4 生成EDoc文档 
4.5 小结 


第5章 主要图形化监测工具的使用 

5.1 Appmon 
5.1.1 Appmon GUI 
5.1.2 WebTool版Appmon 

5.2 Pman 
5.3 调试器 
5.4 表查看器TV 
5.5 工具栏 
5.6 小结 



第二部分 构建生产系统 


第6章 打造一套缓存系统 

6.1 故事背景 
6.2 缓存的设计 

6.3 创建OTP应用的基本骨架 
6.3.1 应用目录结构的布局 
6.3.2 创建应用元数据 
6.3.3 实现应用行为模式 
6.3.4 实现监督者 

6.4 从应用骨架到五脏俱全的缓存 
6.4.1 编写sc_element进程 
6.4.2 实现sc_store模块 
6.4.3 打造应用层API模块 

6.5 小结 


第7章 Erlang/OTP中的日志与事件处理 

7.1 Erlang/OTP中的日志 
7.1.1 日志概述 
7.1.2 Erlang/OTP内置的日志设施 
7.1.3 标准日志函数 
7.1.4 SASL与崩溃报告 

7.2 用gen_event编写自定义事件处理器 
7.2.1 gen_event行为模式简介 
7.2.2 事件处理器示例 
7.2.3 处理错误事件 

7.3 为Simple Cache添加自定义事件流 
7.3.1 事件流API 
7.3.2 将处理器整合进Simple Cache 
7.3.3 订阅自定义事件流 

7.4 小结 


第8章 分布式Erlang/OTP简介 

8.1 Erlang分布式基础 
8.1.1 复制式进程间通信 
8.1.2 位置透明性 

8.2 节点与集群 
8.2.1 节点的启动 
8.2.2 节点的互联 
8.2.3 Erlang节点如何定位其他节点并与之建立通信 
8.2.4 magic cookie安全系统 
8.2.5 互联节点间的消息传递 
8.2.6 使用远程shell 

8.3 资源探测攻略 
8.3.1 术语 
8.3.2 算法 
8.3.3 实现资源探测应用 

8.4 小结 


第9章 用Mnesia为cache增加分布式支持 

9.1 分布式缓存 
9.1.1 选取通信策略 
9.1.2 同步缓存和异步缓存 
9.1.3 分布式表 

9.2 用Mnesia实现分布式数据存储 
9.2.1 建立项目数据库 
9.2.2 初始化数据库 
9.2.3 建表 
9.2.4 向表中录入数据 
9.2.5 执行基本查询 

9.3 基于Mnesia的分布式缓存 
9.3.1 用Mnesia取代ETS 
9.3.2 让缓存识别出其他节点 
9.3.3 用资源探测定位其他缓存实例 
9.3.4 动态复制Mnesia表 

9.4 小结 


第10章 打包、服务和部署 

10.1 从系统的角度看应用 
10.1.1 结构 
10.1.2 元数据 
10.1.3 系统如何管理运行中的应用 

10.2 制作发布镜像 
10.2.1 发布镜像 
10.2.2 准备发布代码 
10.2.3 发布镜像的元数据文件 
10.2.4 脚本与启动文件 
10.2.5 系统配置 
10.2.6 启动目标系统 

10.3 发布镜像打包 
10.3.1 创建发布镜像包 
10.3.2 发布镜像包的内容 
10.3.3 定制发布镜像包 

10.4 安装发布镜像 
10.5 小结 



第三部分 集成与完善 


第11章 为缓存添加HTTP接口 

11.1 实现TCP服务器 
11.1.1 高效TCP服务器的设计模式 
11.1.2 搭建tcp_interface应用的骨架 
11.1.3 填充TCP服务器的实现逻辑 
11.1.4 简单文本协议 
11.1.5 文本接口实现 

11.2 打造一套全新的Web接口 
11.2.1 HTTP简介 
11.2.2 实现一套通用的Web服务器行为模式 
11.2.3 初识REST 
11.2.4 用gen_web_server实现REST式协议 

11.3 小结 


第12章 用端口和NIF集成外围代码 

12.1 端口和NIF 
12.1.1 普通端口 
12.1.2 链入式端口驱动 
12.1.3 原生函数（NIF） 

12.2 用端口来集成解析器 
12.2.1 Erlang方面的端口 
12.2.2 C方面的端口 
12.2.3 编译运行 

12.3 开发链入式驱动 
12.3.1 初识链入式驱动 
12.3.2 驱动的C语言部分 
12.3.3 编译驱动代码 
12.3.4 驱动的Erlang部分 

12.4 将解析器实现为NIF 
12.4.1 NIF的Erlang部分 
12.4.2 NIF的C代码部分 
12.4.3 编译与运行代码 

12.5 小结 


第13章 用Jinterface实现Erlang和Java间的通信 

13.1 利用Jinterface在Erlang中集成Java 
13.1.1 OtpNode类 
13.1.2 OtpMbox类 
13.1.3 Erlang数据结构的Java映射 
13.1.4 示例：Java中的消息处理 
13.1.5 在Erlang中与Java节点通信 

13.2 安装和配置HBase 
13.2.1 下载和安装 
13.2.2 配置HBase 

13.3 为Simple Cache和HBase牵线搭桥 
13.3.1 Erlang方面：sc_hbase.erl 
13.3.2 HBaseConnector类 
13.3.3 Java中的消息处理 
13.3.4 HBaseTask类 

13.4 在Simple Cache中整合HBase 
13.4.1 查询 
13.4.2 插入 
13.4.3 删除 

13.5 运行集成系统 
13.6 小结 


第14章 优化与性能 

14.1 如何进行性能调优 
14.1.1 设定性能目标 
14.1.2 设定基线 
14.1.3 系统性能分析 
14.1.4 确定需要解决的问题 
14.1.5 测定优化成果 

14.2 Erlang代码性能分析 
14.2.1 用cprof计算调用次数 
14.2.2 用fprof测定执行时间 

14.3 Erlang编程语言的缺陷  （hxzon：不是语法缺陷，而是实现细节缺陷。）
14.3.1 基本数据类型的性能特点 
14.3.2 内置函数和运算符的性能 
14.3.3 函数 
14.3.4 进程 
14.4 小结 


附录A 安装Erlang 
附录B 列表与引用透明性


