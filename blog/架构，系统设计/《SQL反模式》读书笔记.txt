《SQL反模式》读书笔记

by hxzon
2013.10.02

hxzon：收益匪浅。

闭包表。
=========
一，存储多值

--
第2章，乱穿马路：使用逗号隔开列表来存储多值。

缺陷：
1，查询困难（只能用like不能用等号）。
2，执行聚合查询困难。
3，约束困难。
4，需要考虑合适的分隔符。
5，字段长度影响值的个数。

解决方案：使用交叉表更优。
优点：
1，容易查询，容易执行聚合查询。
2，能使用约束。
3，不必考虑分隔符，字段长度不影响值的个数。
4，可以在交叉表中添加其他属性。

--
第8章，多列属性：在一个表中用多列来存储多值。

缺陷：
1，查询困难，需要检查多个列。
2，添加和删除值困难，需要检查多个列。
3，确保唯一性困难，需要检查多个列。
4，更改值的个数困难，需新增或删除列。

适用情况：多值的个数是少量，固定的，列的位置和顺序是固定的。

解决方案：使用从属表更优。

========
二，
第3章，单纯的树：如何存储树形结构。

--
解决方案1，使用邻接表（使用parentId）。

优点：
1，查询直接后代或直接父亲容易。
2，移动一个节点容易。

缺点：
1，查询所有后代或所有祖先困难。
2，删除一个节点困难，需从最低级别的节点开始删除。

适用情况：有些数据库支持with关键字加“公共表表达式”，或者有特殊语法。

--
解决方案2，使用路径枚举（xx/yy/zz/a）。

优点：
1，查询所有祖先容易，where 'xx/yy' like path||'%';
2，查询所有后代容易，where path like 'xx/yy'||'%';
3，使用聚合容易。

缺点：字段长度影响层级数。

--
解决方案3，使用嵌套集。
每个节点有两个值，nsleft的数值小于所有后代，nsright的数值大于所有后代，
即夹在这两个值中间的节点为该节点的后代。

优点：
1，删除一个非叶子节点，它的后代会自动代替被删除的节点。

缺点：
1，获取直接父亲或者直接后代困难。
2，插入或移动节点困难，需要重新计算左右值。

--
解决方案4，使用闭包表。
使用一张额外的表treepaths，所有祖孙关系都存成一行（包括节点到自身）。

优点：
1，查询直接后代，直接父亲，所有后代，所有祖先都很容易。
可通过增加一个pathLength字段更快的查找直接后代和直接父亲。
2，插入新节点容易。
3，删除一个叶节点容易。
4，删除子树容易。
5，删除treepaths的一行时，并不真正删除数据。
6，上述方案中，唯一此方案，允许一个节点属于多棵树。

参考书籍1：Jeo Celko《Trees and Hierarchies in SQL for Smarties》，介绍分层查询。
参考书籍2：Vadim Tropashko《SQL Design Patterns》，更加正规和理论化。

hxzon：闭包表最优。

========
--
第6章，实体-属性-值（EAV模式，泛型属性表）

缺陷：
1，查询属性啰嗦复杂。
2，不支持数据完整性，无法声明强制属性，无法使用SQL的数据类型，无法确保引用完整性，无法配置属性名。
3，取一行数据需要使用联接查询。

解决方案1，使用单表继承，所有相关类型都存储在一张表中，用一个列来区分子类型。


解决方案2，使用实体表继承，
缺点1：没有元数据来表明这些子类型之间的关系。
缺点2：在所有对象中（不考虑）进行过滤查找困难，需使用视图等。


解决方案3，使用类表继承，每个子类型表通过外键与基类表相连。


解决方案4，使用半结构化数据类型，使用json格式，存储成一个LOB列，缺点是sql没法处理其中的值。

========
--
第7章，多态关联：一个列连接到不同的父表。

缺陷：
1，不能使用外键约束。
2，查询困难，需要连接所有的父表。
3，

解决方案：

1，使用反向引用。
2，使用交叉表，为每个父表创建一个独立的交叉表。
3，设立交通灯？。
4，双向查找。
5，使用union查询。
6，使用类表继承。

========
--
第9章，元数据分裂。

反模式：
1，多个列来汇总数据。
2，多个表来存储不同范围的值。

解决方案：使用分区（水平分区，垂直分区）。

格言：别让数据衍生元数据。

========
--
第11章，每日新花样：如何使用枚举值。

反模式：使用数据库enum类型。
缺陷：
1，如何查询枚举值。
2，修改枚举值困难（重定义列）。
3，废弃一个选项困难。
4，多个数据库间移植困难。

解决方案：使用检查表（常量表）。
优点：
1，查询枚举值容易。
2，修改枚举值容易。
3，废弃一个选项容易，可增加一个status列，标记为弃用。
4，数据库间移植容易。

========
--
第14章，对未知的恐惧：null问题。

空字符串，空集合（空数组），未知，无意义的值（不能有值）。

null的缺陷：
1，不能在表达式中使用。
2，不能比较。
3，不能在查询参数中使用。

悬空值应该用null来表示。

反模式：将null作为一个普通值处理，或用一个普通值来取代null。

默认值：有些字段无法定义一个合理的默认值。


========
三，充分使用数据库的功能，避免用程序来完成。

--
第4章，需要ID。

1，尝试使用自然主键，组合键。
hxzon：避免使用易变的自然主键。

2，使用好的命名方式，不要总是使用id这个名字。

--
第5章，不用钥匙的入口。

使用外键（引用完整性，级联更新）。

============
第10章，取整错误。

二进制数计算是不精确的。

--
第12章，幽灵文件。

尝试使用BLOB来存储文件。

反模式：使用文件系统。
缺陷：
1，delete数据行并没有删除文件本身。
2，不支持事务隔离，不支持回滚操作，不支持数据库备份工具，不支持SQL访问权限设置。

--
第13章，乱用索引：如何优化索引。


--
第15章，模棱两可的分组。

分组结果不能引用非分组列，因为违背单值规则。

解决方案：使用join。

--
第16章，随机选择：如何高效的随机选中1行。

--
第17章，可怜人的搜索引擎。

使用专门的工具（搜索引擎）。

--
第18章，意大利面条式查询。

不要试图总用一条sql完成查询，分而治之。

用sql生成sql。

--
第19章，隐式的列。

select语句明确列出列名，不要使用*。

--
第20章，明文密码。

--
第21章，SQL注入。

--
第22章，伪键洁癖。

不要重用主键。
如果是为显示效果，使用自然主键，或者行号。

--
第23章，非礼勿视。

程序出错时，注意检查数据库api的返回值。打印拼出的sql语句。

--
第24章，外交豁免权。

要有文档，测试，要使用版本控制。

--
第25章，魔豆。

领域模型优于活动记录。

=======
附录A：规范化规则

第1范式：该表必须是一个范式（行，列都没有顺序，不允许重复行，每列都只有一种类型，每行都只有一个值，行没有隐藏组件），同时，该表没有重复组合。

第2范式：

第3范式：所有非关键字列，都必须直接依赖于关键字列。

博伊斯-科德范式：所有列，都必须直接依赖于关键字列。

第4范式：

第5范式：满足博伊斯-科德范式，且没有复合主键。

DK范式（domain-key范式）：

第6范式：消除所有的联接依赖，支持属性的变更历史。一些数据仓库会用到。

附录B：参考书目

1，Joe Celko，2004，Trees and Hierarchies in SQL for Smarties.
2，Joe Celko，2005，SQL Programming Style.
3，Craig Larman，2004，Applying UML and Patterns:an Introduction to Object-Oriented Analysis and Design and Iterative Development.

