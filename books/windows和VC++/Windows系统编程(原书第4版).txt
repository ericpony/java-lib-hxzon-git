Windows系统编程(原书第4版)

哈特(Johnson M.Hart) (作者), 戴锋 (译者), 陈征 (译者), 等 (译者) 

48.10(7.4折)

===========
出版社: 机械工业出版社; 第1版 (2010年10月1日)
外文书名: Windows System Programming (4th Edition)
丛书名: 开发人员专业技术丛书
平装: 381页
语种： 简体中文
开本: 16
ISBN: 9787111316688, 7111316681
条形码: 9787111316688

===========
编辑推荐

《Windows系统编程(原书第4版)》是Windows API编程的参考指南。内容针对Windows 7、Windows Server 2008和Windows Vista进行了更新。

《Windows系统编程(原书第4版)》广泛地讲解了64位编程、并行性、多核系统等新的关键主题，并更新和优化了全部代码示例
——分别在32位和64位的单处理器和多处理器系统以及Windows 7、Vista、Windows Server 2008和Windows XP下进行了调试和测试。
为了讲解程序的运行，《Windows系统编程(原书第4版)》使用数十个屏幕截图来演示示例程序的结果。

作者系统地讲解了API层面的Windows外部信息。展示了Windows程序员所需的所有知识，并且强调了Windows函数的实际行为以及与实际应用程序的交互。
作者从用于单处理器应用程序的特性开始，逐渐深入讲解更为复杂的函数以及多线程环境。

《Windows系统编程(原书第4版)》包含的主题有：文件系统、内存管理、异常、进程、线程、同步、进程间通信、Windows服务以及安全。

本版的更新内容：

在多核系统中利用并行性且最大化其性能。
促进Windows、Linux和LJNIX之间的源代码的可移植性以及应用程序的互操作性。
使用64位地址空间并确保64位或32位的可移植性。
使用线程、线程池和完成端口来改进性能和可伸缩性。
用于在所有系统中改进程序可靠性和性能的技术。
介绍从Windows Vista开始就具备的Windows性能增强API特性。比如轻量级读与写锁和条件变量。
经典Windows系统编程教科书
Windows API编程权威指南

针对Windows 7、Windows Server 2008和Windows Vista全面更新


媒体推荐

如果你正在编写本地Win32程序，或者只是想了解操作系统在底层到底做了些什么，那么你需要阅读John的书。他讲解了真正的系统程序员绝对必须知道的东西。我推荐他的书。” 
　　——Chris Sells，Microsoft公司 

“本书很好地集成了Vista、Windows 2008和Windows 7 API的新特性，当然，它也很好地讲解了构建以Windows操作系统为目标的应用程序的基本元素。” 
　　——Jason Beres，Infragistics产品管理

作者简介

作者：（美国）哈特（Johnson M.Hart） 译者：戴锋 陈征 等

Johnson M. Hart是一位Microsoft Windows和.NET应用程序开发、开放系统计算、技术培训和写作以及软件工程领域的顾问。
作为软件工程师、经理、工程主管和Cilk Arts公司、Sierra Atlantic、Hewlett-Packard和Apollo Computer的高级技术顾问，他已有超过25年的经验。
他曾在肯塔基大学担任9年的计算机科学教授，并且是本书四个版本的作者。


===============

目录

前言
作者简介


第1章 windows初步1
第2章 使用windows文件系统和字符i/o16

第3章 高级文件、目录处理与注册表38
第4章 异常处理64

第5章 内存管理、内存映射文件和dll84

第6章 进程管理117
第7章 线程和调度144
第8章 线程同步167
第9章 锁、性能以及nt6增强194
第10章 高级线程同步215
第11章 进程间通信244


第12章 使用windows套接字进行网络编程265

第13章 windows服务293
第14章 异步输入/输出与完成端口311
第15章 windows对象的安全337


附录a 使用示例程序355
附录b 源代码可移植性：windows、unix和linux357
附录c 性能结果370

参考文献379

=============
目录

前言
作者简介



第1章 windows初步1

1.1 操作系统必备功能1
1.2 windows的演化2
1.3 windows版本2
1.3.1 过时的windows先前版本2
1.3.2 windows nt5和nt63
1.3.3 处理器支持3
1.4 windows的市场角色3
1.5 windows、标准以及开放系统4
1.6 windows准则5
1.7 32位和64位源代码可移植性6
1.8 标准c库：何时用它来处理文件7

1.9 使用本书所需的条件7
1.9.1 为什么使用c而不是c++7
1.9.2 使用示例7

1.10 示例：一个简单的顺序文件复制程序8
1.10.1 使用c库的文件复制9
1.10.2 使用windows的文件复制11
1.10.3 使用windows便利函数的文件复制12

1.11 小结13
1.11.1 前瞻14
1.11.2 附加阅读14
1.12 习题15




第2章 使用windows文件系统和字符i/o16

2.1 windows文件系统16
2.2 文件命名17
2.3 文件的打开、读取、写入以及关闭17
2.3.1 文件的创建和打开17
2.3.2 关闭文件19
2.3.3 读文件20
2.3.4 写文件21
2.4 unicode和通用字符21
2.4.1 另一种通用字符串处理函数22
2.4.2 通用main函数23
2.4.3 函数定义23
2.5 unicode策略23
2.6 示例：错误处理23
2.7 标准设备25
2.8 示例：将多个文件复制到标准输出26
2.9 示例：简单的文件加密27
2.10 文件和目录管理29
2.10.1 文件管理29
2.10.2 目录管理31
2.11 控制台i/o32
2.12 示例：打印和提示33
2.13 示例：打印当前目录35
2.14 小结36
2.14.1 前瞻36
2.14.2 附加阅读36
2.15 习题36




第3章 高级文件、目录处理与注册表38

3.1 64位文件系统38
3.2 文件指针38
3.2.1 64位算术39
3.2.2 使用重叠结构来指定文件位置40
3.3 获得文件尺寸41
3.4 示例：随机记录更新41
3.5 文件属性和目录处理45
3.5.1 路径名46
3.5.2 其他用于获得文件和目录属性的方法46
3.5.3 临时文件名47
3.6 示例：列出文件属性47
3.7 示例：设置文件时间50
3.8 文件处理策略51
3.9 文件锁52
3.9.1 释放文件锁54
3.9.2 锁逻辑的后果54
3.10 注册表55
3.11 注册表管理56
3.11.1 项管理57
3.11.2 值和数据管理58
3.12 示例：列出注册表项及其内容59
3.13 小结62
3.13.1 前瞻62
3.13.2 附加阅读62
3.14 习题62




第4章 异常处理64

4.1 异常及其处理程序64
4.1.1 try和except块64
4.1.2 过滤表达式及其值66
4.1.3 异常代码67
4.1.4 小结：异常处理顺序68
4.2 浮点异常69
4.3 错误和异常70
4.4 示例：以异常方式处理错误71
4.5 终止处理程序72
4.5.1 离开try块72
4.5.2 非正常终止73
4.5.3 执行并离开终止处理程序73
4.5.4 组合finally和except块73
4.5.5 全局和局部解开74
4.5.6 终止处理程序：进程和线程终止74
4.5.7 seh和c++异常处理74
4.6 示例：使用终止处理程序来改进程序质量74
4.7 示例：使用过滤函数77
4.8 控制台控制处理程序79
4.9 示例：一个控制台控制处理程序80
4.10 向量化异常处理82
4.11 小结82
4.12 习题83




第5章 内存管理、内存映射文件和dll84

5.1 windows内存管理架构84
5.2 堆86
5.3 管理堆内存88
5.3.1 heapalloc88
5.3.2 heapfree89
5.3.3 heaprealloc89
5.3.4 heapsize89
5.3.5 更多关于序列化与异常标志的信息90
5.3.6 其他堆函数90
5.3.7 小结：堆管理91
5.4 示例：使用二叉搜索树对文件进行排序91
5.5 内存映射文件95
5.5.1 文件映射对象96
5.5.2 将对象映射到进程地址空间97
5.5.3 文件映射的限制99
5.5.4 小结：文件映射100
5.6 示例：使用映射文件进行顺序文件处理100
5.7 示例：对内存映射文件排序102
5.8 基指针104
5.9 示例：使用基指针104
5.10 动态链接库108
5.10.1 静态库和动态库108
5.10.2 隐式链接109
5.10.3 显式链接111
5.11 示例：显式链接文件转换函数112
5.12 dll进入点113
5.13 dll版本管理114
5.14 小结115
5.14.1 前瞻115
5.14.2 附加阅读115
5.15 习题115




第6章 进程管理117

6.1 windows进程和线程117
6.2 进程创建118
6.2.1 指定可执行映像和命令行120
6.2.2 可继承句柄121
6.3 进程标识122
6.4 复制句柄123
6.5 进程的退出与终止124
6.6 等待进程终止125
6.7 环境块和字符串125
6.8 示例：并行模式搜索126
6.9 多处理器环境中的进程129
6.10 进程执行时间130
6.11 示例：进程执行时间130
6.12 生成控制台控制事件131
6.13 示例：简单的作业管理132
6.13.1 创建一个后台作业132
6.13.2 获取作业号135
6.13.3 列出背景作业136
6.13.4 在作业清单文件中查找作业137
6.13.5 作业对象138
6.14 示例：使用作业对象139
6.15 小结142
6.16 习题142




第7章 线程和调度144

7.1 线程概述144
7.2 线程基础145
7.3 线程管理146
7.3.1 createthread146
7.3.2 exitthread147
7.3.3 getexitcodethread147
7.3.4 线程标识147
7.3.5 更多线程管理函数147
7.3.6 挂起以及恢复线程148
7.3.7 等待线程终止148
7.4 在线程中使用c库148
7.5 示例：多线程的模式搜索149
7.6 性能影响152
7.7 老板/工人和其他线程模型152
7.8 示例：合并排序——利用多处理器152
7.9 程序并行性简介157
7.10 线程本地存储158
7.11 进程和线程优先级以及调度159
7.12 线程状态160
7.13 陷阱和常见错误162
7.14 计时等待163
7.15 纤程163
7.16 小结165
7.16.1 前瞻165
7.16.2 附加阅读165
7.17 习题165




第8章 线程同步167

8.1 线程同步之需167
8.1.1 临界代码区域168
8.1.2 临界代码区域问题的有瑕疵的解决方案168
8.1.3 volatile存储169
8.1.4 内存架构和内存屏障169
8.1.5 互锁函数：介绍171
8.1.6 局部和全局存储171
8.1.7 小结：线程安全的代码172
8.2 线程同步对象173
8.3 critical_section对象173
8.4 用于保护共享变量的critical_section174
8.5 示例：一个简单的生产者/消费者系统176
8.6 互斥量180
8.6.1 被放弃的互斥量181
8.6.2 互斥量、critical_section以及死锁181
8.6.3 复习：互斥量与critical_section对比183
8.6.4 堆锁183
8.7 信号量183
8.7.1 使用信号量184
8.7.2 信号量的限制184
8.8 事件185
8.9 示例：一个生产者/消费者系统187
8.9.1 复习：windows同步对象189
8.9.2 消息和对象等待190
8.10 更多互斥量和critical_section的指导原则190
8.11 更多互锁函数191
8.12 内存管理性能的考虑192
8.13 小结192
8.13.1 前瞻192
8.13.2 附加阅读192
8.14 习题192




第9章 锁、性能以及nt6增强194

9.1 同步性能影响194
9.2 用于性能试验的模型程序197
9.3 使用cs自旋数来调整多处理器性能198
9.4 nt6轻量级读/写锁199
9.5 减少线程竞争的线程池200
9.6 i/o完成端口202
9.7 nt6线程池203
9.7.1 createthreadpoolwork 203
9.7.2 submitthreadpoolwork 204
9.7.3 waitforthreadpoolwork-callbacks 204
9.7.4 closethreadpoolwork 204
9.7.5 回调函数204
9.7.6 将回调提交给线程池207
9.7.7 线程池环境207
9.7.8 进程线程池207
9.7.9 其他线程池回调类型208
9.8 小结：锁性能208
9.9 再论并行性208
9.9.1 更好的基础以及扩展中的并行程序技术209
9.9.2 并行编程的可选方法209
9.9.3 并行性框架209
9.9.4 不要忘了挑战的存在210
9.10 处理器亲和性210
9.10.1 系统、进程与线程亲和性掩码211
9.10.2 查找处理器数量212
9.11 性能指导原则和陷阱212
9.12 小结213
9.12.1 前瞻213
9.12.2 附加阅读213
9.13 习题213




第10章 高级线程同步215

10.1 条件变量模型和安全性能215
10.1.1 一起使用事件和互斥量215
10.1.2 条件变量模型216
10.1.3 条件变量模型的使用218
10.2 使用signalobjectandwait219
10.3 示例：阀值屏障对象220
10.4 队列对象223
10.5 示例：在多阶段管线中使用队列226
10.6 windows nt6条件变量233
10.7 异步过程调用236
10.8 异步过程调用的排队236
10.9 可报警的等待状态237
10.10 安全的线程取消239
10.11 为了应用程序的可移植而使用pthreads239
10.12 线程堆栈和线程数239
10.13 关于设计、调试和测试的提示240
10.14 windows api之外241
10.15 小结241
10.15.1 前瞻242
10.15.2 附加阅读242
10.16 习题242




第11章 进程间通信244

11.1 匿名管道244
11.2 示例：使用匿名管道进行i/o重定向245
11.3 命名管道247
11.3.1 使用命名管道248
11.3.2 创建命名管道248
11.3.3 命名管道客户连接249
11.3.4 命名管道状态函数250
11.3.5 命名管道连接函数250
11.3.6 客户和服务器的命名管道连接250
11.4 命名管道事务函数251
11.5 示例：客户/服务器命令行处理程序253
11.6 关于客户/服务器命令行处理程序的注释258
11.7 邮槽259
11.7.1 使用邮槽260
11.7.2 创建和打开邮槽260
11.8 管道和邮槽的创建、连接和命名261
11.9 示例：客户可定位的服务器262
11.10 小结264
11.11 习题264




第12章 使用windows套接字进行网络编程265

第13章 windows服务293

第14章 异步输入/输出与完成端口311

第15章 windows对象的安全337



附录a 使用示例程序355
附录b 源代码可移植性：windows、unix和linux357
附录c 性能结果370


参考文献379




