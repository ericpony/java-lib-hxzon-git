面向模式的软件架构，卷4：分布式计算的模式语言

作者: Frank Buschmann / Douglas C.Schmidt / Keclin Henney 
出版社: 人民邮电出版社
译者: 肖鹏 / 陈立 
出版年: 201006
页数: 348
定价: 69.00元
装帧: 平装
丛书: 面向模式的软件架构
ISBN: 9787115227737

=============
第四卷虽然名为《分布式计算的模式语言》，但事实上可以看作是一本模式目录，因为本书涉及到的模式一共包含了114种模式，这其中还没有计算参考到的另外150多种模式。
形象地说，本书好像是模式大观园，其中的风景可以说是美不胜收。
然而，正是因为美丽的景点实在太多，就很容易导致风景的欣赏者开始走马观花，最后充斥在脑海中的不过是肤浅的一堆表面印象而已。
粗略看来，由于要介绍的模式太多，而书的容量有限，导致许多模式的介绍只能浅尝辄止。

我不否认这确乎是事实，但另一方面，本书对模式的这些描述言简意赅，背后包含的思想与意义，却又值得我们反复思索。
例如，本书将Domain Object模式描述为：
“将自我完备的连贯功能和基础性责任封装成定义良好的实体，通过一个或多个Explicit Interface提供功能，并隐藏内部结构和实现。”
在这个描述中，所谓的“自我完备”一词就值得我们反复玩味，
若能充分地体会到封装的意义与面向对象的本质，当阅读到这个词语时，定能会心微笑，犹如遇见知音一般的快乐。


面对这样一套浩如烟海的著作，我们该怎样阅读，才能攻克架构模式这座堡垒呢？
在阅读到第4卷时，通过回应前面几卷的内容，给了我一个很好的提示。
我认为，最好的阅读方法就是《如何阅读一本书》中提到的主题阅读（Syntopical Reading）方式，
即通过确定主题相关性，定位到相关章节，广泛查阅资料，汲取与主题相关的知识营养，进而深入地分析这个主题的方方面面。
本系列的第四卷就起到了很好地提纲挈领的作用。如果大家希望阅读这一系列，并能在阅读之后真正有所收获，

我建议的阅读顺序为：首先阅读本系列第一卷，其目的在于对模式（架构模式、设计模式与惯用法）与模式系统有一个初步的认识，可以算作是登堂入室的第一步。
没有踏出这第一步，就很难谈得上你能够很好地理解架构模式。这一步骤可以是一个快速浏览的过程。
正如陶渊明所言“好读书，不求甚解”，此次阅读完全可以遵循这七字法则，不必深入理解书中讲解的每个模式。
阅读时不能理解的，可以暂时搁置在一边。


有了第一遍的基础，就可以翻开第四卷，开始真正的模式之旅了。
本书有价值的内容全部都放在了《第二部分 模式故事》与《第三部分 模式语言》中。
当然，如果你希望了解什么是分布式系统，也可以快速阅读第2章的内容。

本书的第5章《基线架构》写得非常漂亮，极好地表现了作者非凡的写作功底与扎实的技术功底，
这是我读过的除了《企业应用集成模式》第一章《运用模式解决集成问题》与《设计模式》第二章《实例研究：设计一个文档编辑器》之外，
将理论与实际案例结合得最好的一章。
事实上，这个案例应该是从第四章开始，简略地介绍了整个案例的需求，
然后就从架构环境，层次分解，领域层，分布式通信，用户界面，功能分布，并发处理，数据持久化等诸多方面，
层层递进地勾勒出整个仓库管理流程控制系统的架构过程，且非常完美地嵌入了本书所要讲解的主要模式。
因此，用这个案例来开始你的模式之旅，就让自己现在走的一步站在了更高的起点上。


将如此众多的内容浓缩到这一章中，必然会产生阅读障碍。
没有关系，你可以默念“不求甚解”的真言进行你的阅读，它可以给你心灵上极大的安慰与自信，使得你不至于在面对困难与挫折时，直接缴械投降。
这确实需要足够的信心才能让自己不至于中途放弃，因为这样磕磕巴巴的阅读之旅，
会一直持续到第7章《仓库拓扑》，你才可以停下来喘一口气（事实上，从第4章一直到第7章，才算完整地介绍完整个项目案例的架构设计与分析）。


休息好了吗？收拾好心情，活动活动疲惫的双脚，做好继续迎面困难的准备吧。
因为前方还有无穷多的高峰和险峰在等着你去征服呢。

从本书的第三部分开始，你就进入了模式语言的世界中，希望你能保持足够的清醒，不要在模式语言中迷了路。
在这个环节中，我认为最好的阅读方式应该是一种“超链接阅读”方式，
简言之，就是以本书为纲，开展纵向和横向的阅读，就像浏览网页时不停地点击超链接了解相关知识一般。
你需要准备足够多的资料，包括本系列的前面三卷以及其他相关书籍。


举例说来，当我们阅读到第9章介绍的Domain Model模式时，你绝对不能仅满足于本书的内容，
而应该在阅读完本书对该模式的介绍后，再去翻阅Martin Fowler的著作《企业应用架构模式》，找找看Martin对Domain Model是怎样描述的。

又例如在阅读到第10章的Message Endpoint模式时，可以翻阅《企业应用架构模式》第3章中对该模式的介绍。

阅读到本书第15章的Leader/Followers模式时，应查阅《面向模式的软件架构》第二卷第5章的内容。

如果你仍然没有很好地理解，你还可以通过本书提供的参考文献获取相关知识，又或者通过互联网搜索相关的文档。
而这正是所谓“主题阅读”的阅读形式，严格地讲，它更像是一种学术研究，通过延伸与比较的阅读，彻底明白每一个知识主题。


当把这些模式（当然，你也可以只选取你感兴趣或认为重要的模式）全部吃透之后，或许光阴已经飞逝一年或者二载。
不管怎样，通过这种精读的形式，并结合自己项目中的经验与收获，你已经在架构模式之旅中行进到足够远的距离了。
此时的你可以再回过头来通读本系列的第一卷，以及第四卷，特别包括第四卷的第二部分，你一定会产生豁然开朗的感觉。


=============
内容简介

迄今为止，人们提出的软件开发模式有不少是关于分布式计算的，但人们始终无法以完整的视角了解分布式计算中各种模式是如何协同工作、取长补短的。构建复杂的分布式系统似乎成为了永远也无法精通的一门手艺。本书的出版改变了这一切。

本书是经典的POSA系列的第4卷，介绍了一种模式设计语言，将分布式系统开发中的114个模式联系起来。书中首先介绍了一些分布式系统和模式语言的概念，然后通过一个仓库管理流程控制系统的例子，介绍如何使用模式语言设计分布式系统，最后介绍模式语言本身。

使用这一模式语言，人们可以有效地解决许多与分布式系统开发相关的技术问题，如

★ 对象交互

★ 接口与组件划分

★ 应用控制

★ 资源管理

★ 并发与同步

本书从实用角度展示了如何从现有的主要模式中整合出一门全面的模式语言，用于开发分布式计算中间件及应用程序。作为该领域在市场上唯一统揽全局的书，它将给读者带来醍醐灌顶的感觉！

==============
目录


第一部分　概念 
第1章　模式与模式语言 2 
第2章　分布式系统 9 
第3章　模式语言 18 

第二部分　模式故事 
第4章　仓库管理流程控制 33 
第5章　基线架构 37 
第6章　通信中间件 54 
第7章　仓库拓扑 74 
第8章　模式故事背后的故事 91 

第三部分　模式语言 
第9章　从混沌到结构 97 
第10章　分布式基础设施 123 
第11章　事件分离和分发 147 
第12章　接口划分 157 
第13章　组件划分 177 
第14章　应用控制 191 
第15章　并发 206 
第16章　同步 216 
第17章　对象间的交互 233 
第18章　适配与扩展 247 
第19章　模态行为 272 
第20章　资源管理 278 
第21章　数据库访问 316 
第22章　最后的思考 326 

术语表 327 
参考书目 340

===============
目录


第一部分　概念 

第1章　模式与模式语言 2 
1.1　模式 2 

1.2　模式内幕 3 
1.2.1　问题的环境 3 
1.2.2　驱动因素：所有模式的核心 4 
1.2.3　解决方案与结果 4 
1.2.4　模式命名 4 
1.2.5　模式表现形式概述 5 

1.3　模式的关系 5 
1.3.1　模式的互补 5 
1.3.2　模式的组合 6 
1.3.3　模式故事 6 
1.3.4　模式序列 7 

1.4　模式语言 7 
1.4.1　从模式序列到模式语言 7 
1.4.2　展现和使用模式语言 7 

1.5　模式的连接 8 

第2章　分布式系统 9 

2.1　分布式的优点 9 
2.2　分布式的挑战 11 

2.3　用以支持分布式的技术 12 
2.3.1　分布式对象计算中间件 13 
2.3.2　组件中间件 14 
2.3.3　发布/订阅中间件和面向消息的中间件 15 
2.3.4　面向服务架构和Web服务 16 

2.4　中间件技术的局限性 17 

第3章　模式语言 18 

3.1　意图、范畴和对象 18 
3.2　起源 18 
3.3　结构和内容 19 
3.4　模式的表现 24 
3.5　实际应用 26 


第二部分　模式故事 

第4章　仓库管理流程控制 33 

4.1　系统范畴 33 
4.2　仓库管理流程控制 34 

第5章　基线架构 37 

5.1　架构环境 37 
5.2　划分大泥球 38 
5.3　层次分解 38 
5.4　访问领域对象功能 40 
5.5　网络桥接 41 
5.6　分离用户界面 43 
5.7　功能分布 45 
5.8　支持并发的领域对象访问 47 
5.9　获得可扩展的并发性 48 
5.10　将面向对象与关系型数据库连接起来 49 
5.11　领域对象的运行时配置 50 
5.12　基线架构总结 51 

第6章　通信中间件 54 

6.1　分布式系统的中间件架构 54 
6.2　对中间件的内部设计进行结构化 57 
6.3　封装底层系统机制 58 
6.4　分离ORB核心事件 59 
6.5　ORB连接管理 61 
6.6　提高ORB的可伸缩性 63 
6.7　实现同步请求队列 65 
6.8　可互换的内部ORB机制 66 
6.9　管理ORB策略 68 
6.10　ORB动态配置 69 
6.11　通信中间件总结 71 

第7章　仓库拓扑 74 

7.1　仓库拓扑基线 74 
7.2　表现层次化的存储结构 74 
7.3　存储结构导航 77 
7.4　存储属性建模 78 
7.5　不同的存储单元行为 79 
7.6　实现全局功能 81 
7.7　遍历仓库拓扑 81 
7.8　支持控制流扩展 83 
7.9　连接数据库 84 
7.10　维护内存中的存储单元数据 85 
7.11　配置仓库拓扑 86 
7.12　细述显式接口 88 
7.13　仓库拓扑总结 89 

第8章　模式故事背后的故事 91 


第三部分　模式语言 

第9章　从混沌到结构 97 

9.1　Domain Model     106 
9.2　Layers     108 
9.3　Model-View-Controller     109 
9.4　Presentation-Abstraction-Control 111 
9.5　Microkernel     113 
9.6　Reflection   114 
9.7　Pipes and Filters     116 
9.8　Shared Repository     117 
9.9　Blackboard 119 
9.10　Domain Object     121 

第10章　分布式基础设施 123 

10.1　Messaging     129 
10.2　Message Channel     130 
10.3　Message Endpoint     132 
10.4　Message Translator     133 
10.5　Message Router     134 
10.6　Publisher-Subscriber     135 
10.7　Broker     137 
10.8　Client Proxy     139 
10.9　Requestor     140 
10.10　Invoker     142 
10.11　Client Request Handler     143 
10.12　Server Request Handler     144 

第11章　事件分离和分发 147 

11.1　Reactor     150 
11.2　Proactor   152 
11.3　Acceptor-Connector     154 
11.4　Asynchronous Completion Token     155 

第12章　接口划分 157 

12.1　Explicit Interface     163 
12.2　Extension Interface     165 
12.3　Introspective Interface     166 
12.4　Dynamic Invocation Interface   167 
12.5　Proxy     169 
12.6　Business Delegate     170 
12.7　Facade     171 
12.8　Combined Method     172 
12.9　Iterator     173 
12.10　Enumeration Methond     174 
12.11　Batch Method     175 

第13章　组件划分 177 

13.1　Encapsulated Implementation     181 
13.2　Whole-Part     183 
13.3　Composite     185 
13.4　Master-Slave     186 
13.5　Half-Object plus Protocol     188 
13.6　Replicated Component Group     189 

第14章　应用控制 191 

14.1　Page Controller     196 
14.2　Front Controller     197 
14.3　Application Controller     198 
14.4　Command Processor     199 
14.5　Template View     200 
14.6　Transform View     201 
14.7　Firewall Proxy     202 
14.8　Authorization     204 

第15章　并发 206 

15.1　Half-Sync/Half-Async     209 
15.2　Leader/Followers     211 
15.3　Active Object     212 
15.4　Monitor Object     214 

第16章　同步 216 

16.1　Guarded Suspension     221 
16.2　Future     223 
16.3　Thread-Safe Interface   224 
16.4　Double-Checked Locking 225 
16.5　Strategized Locking     226 
16.6　Scoped Locking     227 
16.7　Thread-Specific Storage 228 
16.8　Copied Value     230 
16.9　Immutable Value     231 

第17章　对象间的交互 233 

17.1　Observer     237 
17.2　Double Dispatch      238 
17.3　Mediator   239 
17.4　Command     240 
17.5　Memento     242 
17.6　Context Object     243 
17.7　Data Transfer Object     244 
17.8　Message     245 

第18章　适配与扩展 247 

18.1　Bridge     255 
18.2　Object Adapter     256 
18.3　Chain of Responsibility   257 
18.4　Interpreter 258 
18.5　Interceptor     260 
18.6　Visitor     261 
18.7　Decorator 262 
18.8　Execute-Around Object     264 
18.9　Template Method   265 
18.10　Strategy     266 
18.11　Null Object     267 
18.12　Wrapper Facade     269 
18.13　Declarative Component Configuration   270 

第19章　模态行为 272 

19.1　Objects for States   274 
19.2　Methods for States   275 
19.3　Collections for States   276 

第20章　资源管理 278 

20.1　Container   288 
20.2　Component Configurator   289 
20.3　Object Manager     291 
20.4　Lookup     292 
20.5　Virtual Proxy     294 
20.6　Lifecycle Callback     295 
20.7　Task Coordinator   296 
20.8　Resource Pool     298 
20.9　Resource Cache     299 
20.10　Lazy Acquisition     300 
20.11　Eager Acquisition     301 
20.12　Partial Acquisition   303 
20.13　Activator     304 
20.14　Evictor     305 
20.15　Leasing     306 
20.16　Automated Garbage Collection     307 
20.17　Counting Handles     309 
20.18　Abstract Factory     311 
20.19　Builder   312 
20.20　Factory Method     313 
20.21　Disposal Method     314 

第21章　数据库访问 316 

21.1　Database Access Layer     318 
21.2　Data Mapper     320 
21.3　Row Data Gateway     321 
21.4　Table Data Gateway      323 
21.5　Active Record 324 

第22章　最后的思考 326 


术语表 327 
参考书目 340
