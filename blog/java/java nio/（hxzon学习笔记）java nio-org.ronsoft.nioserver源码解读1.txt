（hxzon学习笔记）java nio-org.ronsoft.nioserver源码解读1by hxzon========关注点：数据的读取和写入。1，主要类：NioDispatcher（入口，见2）StandardAcceptor（入口，见3）HandlerAdaper（处理器适配器，封装常用处理器功能，实现ChannelFacade接口，见4）InputHandler（接口，用户自定义的处理器，见5）InputQueueImpl（读取数据，见6.1）OutputQueueImpl（写入数据，见6.2）2，启动		NioDispatcher dispatcher = new NioDispatcher (executor, bufFactory);		StandardAcceptor acceptor = new StandardAcceptor (port, dispatcher, inputHandlerFactory);		dispatcher.start();		acceptor.newThread();2.1，NioDispatcher入口：	public void run()	{		try {			dispatch();		} catch (IOException e) {			logger.log (Level.WARNING, "Unexpected I/O Exception", e);		}		//退出，反注册处理器，关闭选择器		Set<SelectionKey> keys = selector.selectedKeys();		for (SelectionKey key : keys) {			HandlerAdapter adapter = (HandlerAdapter) key.attachment();			unregisterChannel (adapter);		}		try {			selector.close();		} catch (IOException e) {			logger.log (Level.WARNING, "Unexpected I/O Exception closing selector", e);		}	}2.2，主方法，处理请求	public void dispatch() throws IOException	{		while (dispatching) {			selectorGuardBarrier();			selector.select();			checkStatusChangeQueue();//检查“状态变更队列”中的处理器的状态。			Set<SelectionKey> keys = selector.selectedKeys();			for (SelectionKey key : keys) {				HandlerAdapter adapter = (HandlerAdapter) key.attachment();				invokeHandler (adapter);//处理请求			}			keys.clear();		}	}2.3，在选择器所在线程上运行的方法	// ------------------------------------------------	// private methods that always run in the selection	// thread, and hence do not need the selectorGuard.	private void invokeHandler (HandlerAdapter adapter)	{		adapter.prepareToRun();		adapter.key().interestOps (0);//暂时移除key关注的操作。为什么要（在处理过程中）这么做？		executor.execute (new HandlerFutureTask (adapter));//处理请求	}	//被dispatch()调用。从状态变更队列取出处理器，	//运行失败的处理器，反注册。	//运行成功的处理器，还原key关注的操作。	private void checkStatusChangeQueue()	{		HandlerAdapter adapter;		while ((adapter = statusChangeQueue.poll()) != null) {			if (adapter.isDead()) {				unregisterChannel (adapter);			} else {				resumeSelection (adapter);			}		}	}	//还原key关注的操作	private void resumeSelection (HandlerAdapter adapter)	{		SelectionKey key = adapter.key();		if (key.isValid()) key.interestOps (adapter.getInterestOps());	}	/**	 * Called to acquire and then immediately release a write lock	 * on the selectorGuard object. This method is only called by	 * the selection thread and it has the effect of making that	 * thread wait until all read locks have been released. 	 */	private void selectorGuardBarrier()	{		selectorGuard.writeLock().lock();		selectorGuard.writeLock().unlock();	}	2.3.1，	//被run()和checkStatusChangeQueue()调用。	public void unregisterChannel (ChannelFacade token)	{		if ( ! (token instanceof HandlerAdapter)) {			throw new IllegalArgumentException ("Not a valid registration token");		}		HandlerAdapter adapter = (HandlerAdapter) token;		SelectionKey selectionKey = adapter.key();		acquireSelectorGuard();		try {			adapter.unregistering();//通知处理器准备反注册。			selectionKey.cancel();//键取消		} finally {			releaseSelectorGuard();		}		adapter.unregistered();//通知处理器已反注册。	}2.4，	// --------------------------------------------------------	// Specialized FutureTask class that wraps a HandlerAdapter instance	// for execution by the thread pool Executor.  This class overrides	// the done() method to place the contained HandlerAdapter object	// onto a BlockingQueue for the selection thread to see.	private class HandlerFutureTask extends FutureTask<HandlerAdapter>	{		private final HandlerAdapter adapter;		public HandlerFutureTask (HandlerAdapter adapter)		{			super (adapter);			this.adapter = adapter;		}		protected void done()		{			enqueueStatusChange (adapter);//将处理器放入状态变更队列，使得选择器所在的线程可见。			try {				// Get result returned by call(), or cause				// deferred exception to be thrown.  We know				// the result will be the adapter instance				// stored above, so we ignore it.				get();//获取处理器，阻塞			// Extension point: You may choose to extend the			// InputHandler and HandlerAdapter classes to add			// methods for handling these exceptions.  This			// method is still running in the worker thread.			} catch (ExecutionException e) {				adapter.die();//处理器死亡				logger.log (Level.WARNING, "Handler died", e.getCause());			} catch (InterruptedException e) {				Thread.interrupted();				logger.log (Level.WARNING, "Handler interrupted", e);			}		}	}2.5，	// ------------------------------------------------	// package-local called from HandlerAdapter	// Place the given HandlerAdapter instance on the status change queue.	// The loop and nested try/catch blocks are to properly handle the	// InterruptedException that might be thrown when adding to the	// completion queue.  That exception is unlikely to ever happen here,	// but this is the proper code to handle the general case.	// 被HandlerAdapter.modifyInterestOps()和HandlerFutureTask.done()调用。	void enqueueStatusChange (HandlerAdapter adapter)	{		boolean interrupted = false;		try {			while (true) {				try {					statusChangeQueue.put (adapter);//将处理器放入“状态变更队列”					selector.wakeup();//唤醒选择器					return;				} catch (InterruptedException e) {					interrupted = true;				}			}		} finally {			if (interrupted) Thread.currentThread().interrupt();		}	}	3，	3.1，StandardAcceptor入口：	new StandardAcceptor (port, dispatcher, inputHandlerFactory);	public synchronized Thread newThread()	{		Thread thread = new Thread (listener);//listener在构造器中创建。		threads.add (thread);		thread.start();		return thread;	}	private class Listener implements Runnable	{		public void run ()		{			while (running) {				try {					SocketChannel client = listenSocket.accept();//ServerSocketChannel listenSocket在构造器中根据端口号创建。					if (client == null) {						continue;					}					dispatcher.registerChannel (client, inputHandlerFactory.newHandler());//注册处理器				} catch (ClosedByInterruptException e) {					logger.fine ("ServerSocketChannel closed by interrupt: " + e);					return;				} catch (ClosedChannelException e) {					logger.log (Level.SEVERE,						"Exiting, serverSocketChannel is closed: " + e, e);					return;				} catch (Throwable t) {					logger.log (Level.SEVERE,						"Exiting, Unexpected Throwable doing accept: " + t, t);					try {						listenSocket.close();					} catch (Throwable e1) { /* nothing */ }					return;				}			}		}	}3.2，	//在listener.run()中调用。	public ChannelFacade NioDispatcher.registerChannel (SelectableChannel channel, InputHandler handler)		throws IOException	{		channel.configureBlocking (false);		HandlerAdapter adapter = new HandlerAdapter (handler, this, bufferFactory);		adapter.registering();//通知处理器准备注册。		acquireSelectorGuard();		try {			SelectionKey key = channel.register (selector, SelectionKey.OP_READ, adapter);//注册读操作			adapter.setKey (key);			adapter.registered();//通知处理器已完成注册。			return adapter;		} finally {			releaseSelectorGuard();		}	}	4，4.1，HandlerAdapter ，实现 ChannelFacade接口。public interface ChannelFacade{	InputQueue inputQueue();	OutputQueue outputQueue();	void setHandler (InputHandler handler);	int getInterestOps();		//在OutputQueueImpl.enqueue()中调用，注册写操作。	//只是修改adapter自身的关注操作，等到nioDispatcher.resumeSelection()时才会回写到key。	void modifyInterestOps (int opsToSet, int opsToReset);}	// --------------------------------------------------	// package-local methods called by NioDispatcher	// 在nioDispatcher.invokeHandler()中调用。	void prepareToRun()	{		synchronized (stateChangeLock) {			interestOps = key.interestOps();			readyOps = key.readyOps();			running = true;		}	}	// --------------------------------------------------	// package-local life-cycle helper methods, called by NioDispatcher	// 下面两个方法在NioDispatcher.registerChannel()中调用。	// Called when registering, but before the handler is active	void registering()	{		clientHandler.starting (this);	}	// Called when the handler is registered, but before the first message	void registered()	{		clientHandler.started (this);	}	// 下面两个方法在NioDispatcher.unregisterChannel()中调用。	// Called when unregistration has been requested, but while the	// handler is still active and able to interact with the framework.	// Extension Point: This implementation simply calls through to	// the client handler, which may or may not be running.  Either	// the client code must take steps to protect its internal state,	// or logic could be added here to wait until the handler finishes.	void unregistering()	{		clientHandler.stopping (this);	}	// Called when the handler has been unregistered and is no longer active.	// If unregistering() waits for the handler to finish, then this	// one should be safe.  If not, then this function has the same	// concurrency concerns as does unregistering().	void unregistered()	{		clientHandler.stopped (this);	}4.2，	// 在HandlerFutureTask中隐式调用（FutureTask.run()->Callable.call()）。	public HandlerAdapter call() throws IOException	{		try {			drainOutput();			fillInput();			ByteBuffer message;			// must process all buffered messages because Selector will			// not fire again for input that's already read and buffered			while ((message = clientHandler.nextMessage (this)) != null) {				clientHandler.handleInput (message, this);			}		} finally {			synchronized (stateChangeLock) {				running = false;			}		}		return this;	}	// 下面两个方法在call()中调用。	// If there is output queued, and the channel is ready to	// accept data, send as much as it will take.	// 当channel可写，且有要发送的数据时，尽可能多的发送。	private void drainOutput() throws IOException	{		if (((readyOps & SelectionKey.OP_WRITE) != 0)		    && ( ! outputQueue.isEmpty()))		{			outputQueue.drainTo ((ByteChannel) channel); //循环写入所有数据。		}		// Write selection is turned on when output data in enqueued,		// turn it off when the queue becomes empty.		if (outputQueue.isEmpty()) {			disableWriteSelection();//反注册写操作			if (shuttingDown) {				channel.close();				clientHandler.stopped (this);			}		}	}	// Attempt to fill the input queue with as much data as the channel	// can provide right now.  If end-of-stream is reached, stop read	// selection and shutdown the input side of the channel.	// （原文注释：读取channel当前可读到的全部数据。）（但代码并未循环读取？）	// 如果没有读到数据，则key从读操作切换到写操作，且关闭channel。	private void fillInput() throws IOException	{		if (shuttingDown) return;		int rc = inputQueue.fillFrom ((ByteChannel) channel); //只是channel.read (buffer);并未读取全部数据。		if (rc == -1) {			disableReadSelection();//反注册读操作。			if (channel instanceof SocketChannel) {				SocketChannel sc = (SocketChannel) channel;				if (sc.socket().isConnected()) {					try {						sc.socket().shutdownInput();					} catch (SocketException e) {						// happens sometimes, ignore					}				}			}			shuttingDown = true;			clientHandler.stopping (this);			// cause drainOutput to run, which will close			// the socket if/when the output queue is empty			enableWriteSelection();//注册写操作		}	}4.3，	public void modifyInterestOps (int opsToSet, int opsToReset)	{		synchronized (stateChangeLock) {			interestOps = (interestOps | opsToSet) & (~opsToReset);			if ( ! running) {				dispatcher.enqueueStatusChange (this); //将处理器放入“状态变更队列”			}		}	}	// --------------------------------------------------	// Private helper methods	// These three methods manipulate the private copy of the selection	// interest flags.  Upon completion, this local copy will be copied	// back to the SelectionKey as the new interest set.	private void enableWriteSelection()	{		modifyInterestOps (SelectionKey.OP_WRITE, 0);	}	private void disableWriteSelection()	{		modifyInterestOps (0, SelectionKey.OP_WRITE);	}	private void disableReadSelection()	{		modifyInterestOps (0, SelectionKey.OP_READ);	}5，public interface InputHandler{	//在HandlerAdapter.call()中调用。	//尝试从channel中（通过InputQueue）读取数据（可先检查）。	ByteBuffer nextMessage (ChannelFacade channelFacade); 	//在HandlerAdapter.call()中调用。	//nextMessage()不断读取消息，然后调用此方法处理接收到的消息。见4.2。	void handleInput (ByteBuffer message, ChannelFacade channelFacade); 	void starting (ChannelFacade channelFacade);	void started (ChannelFacade channelFacade);		//在handlerAdapter.fillInput()和unregistering()中调用。	void stopping (ChannelFacade channelFacade); 	//在handlerAdapter.drainOutput()和unregistering()中调用。	void stopped (ChannelFacade channelFacade); }5.1，示例一：public class EchoHandler implements InputHandler{	public ByteBuffer nextMessage (ChannelFacade channelFacade)	{//检查是否有换行符，有则返回一行。		InputQueue inputQueue = channelFacade.inputQueue();		int nlPos = inputQueue.indexOf ((byte) '\n');		if (nlPos == -1) return (null);		return (inputQueue.dequeueBytes (nlPos + 1));	}	public void handleInput (ByteBuffer message, ChannelFacade channelFacade)	{//将收到的消息放入到输出队列，稍后发送。		channelFacade.outputQueue().enqueue (message);	}	public void starting (ChannelFacade channelFacade)	{		// nothing	}	public void started (ChannelFacade channelFacade)	{		// nothing	}	public void endOfInput (ChannelFacade channelFacade)	{		// nothing	}	public void stopping (ChannelFacade channelFacade)	{		// nothing	}	public void stopped (ChannelFacade channelFacade)	{		// nothing	}5.2，示例二：5.2.1，public class NadaHandler implements InputHandler{	private final NadaProtocol protocol;	public NadaHandler (NadaProtocol protocol)	{		this.protocol = protocol;	}	// --------------------------------------------------------	// Implementation of the InputHandler interface	public ByteBuffer nextMessage (ChannelFacade channelFacade)	{//检查是否有换行符，有则返回一行。		InputQueue inputQueue = channelFacade.inputQueue();		int nlPos = inputQueue.indexOf ((byte) '\n');		if (nlPos == -1) return null;		if ((nlPos == 1) && (inputQueue.indexOf ((byte) '\r') == 0)) { //去除空行			inputQueue.discardBytes (2);	// eat CR/NL by itself			return null;		}		return (inputQueue.dequeueBytes (nlPos + 1));	}	public void handleInput (ByteBuffer message, ChannelFacade channelFacade)	{		protocol.handleMessage (channelFacade, message);	}	public void starting (ChannelFacade channelFacade)	{//		System.out.println ("NadaHandler: starting");	}	public void started (ChannelFacade channelFacade)	{//用户加入		protocol.newUser (channelFacade);	}	public void stopping (ChannelFacade channelFacade)	{//		System.out.println ("NadaHandler: stopping");	}	public void stopped (ChannelFacade channelFacade)	{//用户退出		protocol.endUser (channelFacade);	}5.2.2，public class NadaProtocol implements InputHandlerFactory{	Map<ChannelFacade, NadaUser> users =		Collections.synchronizedMap (new HashMap<ChannelFacade, NadaUser>());	// --------------------------------------------------	// Implementation of InputHandlerFactory interface	public InputHandler newHandler() throws IllegalAccessException, InstantiationException	{		return new NadaHandler (this);	}	// --------------------------------------------------	void newUser (ChannelFacade facade)	{		NadaUser user = new NadaUser (facade);		users.put (facade, user);		user.send (ByteBuffer.wrap ((user.getNickName() + "\n").getBytes()));	}	void endUser (ChannelFacade facade)	{		users.remove (facade);	}	public void handleMessage (ChannelFacade facade, ByteBuffer message)	{		broadcast (users.get (facade), message);	}	private void broadcast (NadaUser sender, ByteBuffer message)	{		synchronized (users) {			for (NadaUser user : users.values()) {				if (user != sender) {					sender.sendTo (user, message);				}			}		}	}	// ----------------------------------------------------	private static class NadaUser	{		private final ChannelFacade facade;		private String nickName;		private ByteBuffer prefix = null;		private static int counter = 1;		public NadaUser (ChannelFacade facade)		{			this.facade = facade;			setNickName ("nick-" + counter++);		}		public void send (ByteBuffer message)		{			facade.outputQueue().enqueue (message.asReadOnlyBuffer());		}		public void sendTo (NadaUser recipient, ByteBuffer message)		{			recipient.send (prefix);			recipient.send (message);		}		public String getNickName ()		{			return nickName;		}		public void setNickName (String nickName)		{			this.nickName = nickName;			String prefixStr = "[" + nickName + "] ";			prefix = ByteBuffer.wrap (prefixStr.getBytes());		}	}}