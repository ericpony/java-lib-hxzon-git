领域特定语言
-----
作者: Martin Fowler 
出版社: 机械工业出版社华章公司
原作名: Domain-Specific Languages
译者: ThoughtWorks中国 
出版年: 2013-3-20
页数: 488
定价: 89.00元
装帧: 平装
ISBN: 9787111413059
===========
内容简介
本书是DSL领域的丰碑之作，由世界级软件开发大师和软件开发“教父”Martin Fowler历时多年写作而成，ThoughtWorks中国翻译。全面详尽地讲解了各种DSL及其构造方式，揭示了与编程语言无关的通用原则和模式，阐释了如何通过DSL有效提高开发人员的生产力以及增进与领域专家的有效沟通，能为开发人员选择和使用DSL提供有效的决策依据和指导方法。

全书共57章，分为六个部分：
第一部分介绍了什么是DSL，DSL的用途，如何实现外部DS和内部DSL，如何生成代码，语言工作台的使用方法；
第二部分介绍了各种DSL，分别讲述了语义模型、符号表、语境变量、构造型生成器、宏和通知的工作原理和使用场景；
第三部分分别揭示分隔符指导翻译、语法指导翻译、BNF、易于正则表达式表的词法分析器、递归下降法词法分析器、解析器组合子、解析器生成器、树的构建、嵌入式语法翻译、内嵌解释器、外加代码等；
第四部分介绍了表达式生成器、函数序列、嵌套函数、方法级联、对象范围、闭包、嵌套闭包、标注、解析数操作、类符号表、文本润色、字面量扩展的工作原理和使用场景；
第五部分介绍了适应性模型、决策表、依赖网络、产生式规则系统、状态机等计算模型的工作原理和使用场景；
第六部分介绍了基于转换器的代码生成、模板化的生成器、嵌入助手、基于模型的代码生成、无视模型的代码生成和代沟等内容。


作者简介
Martin Fowler，世界级软件开发大师，软件开发“教父”，敏捷开发方法的创始人之一，在面向对象分析与设计、UML、模式、极限编程、重构和DSL等领域都有非常深入的研究并为软件开发行业做出了卓越贡献。他乐于分享，撰写了《企业应用架构模式》（荣获第13届Jolt生产力大奖）、《重构：改善既有代码的设计》、《分析模式：可复用的对象模型》、《UML精粹：标准对象建模语言简明指南》等在软件开发领域颇负盛名的著作。
================
目录

译者序
前言

第一部分　叙　　述

第1章入门例子2
第2章　使用DSL21
第3章实现DSL34
第4章实现内部DSL54
第5章实现外部DSL72
第6章内部DSL vs 外部DSL84
第7章其他计算模型概述90
第8章代码生成96
第9章语言工作台102

第二部分　通 用 主 题

第10章各种DSL116
第11章语义模型125
第12章符号表129
第13章语境变量137
第14章构造型生成器141
第15章宏144
第16章通知153

第三部分　外部DSL主题

第17章分隔符指导翻译160
第18章语法指导翻译175
第19章BNF183
第20章基于正则表达式表的词法分析器192
第21章递归下降法语法解析器197
第22章解析器组合子205
第23章解析器生成器217
第24章树的构建227
第25章嵌入式语法翻译242
第26章内嵌解释器247
第27章外加代码250
第28章可变分词方式258
第29章嵌套的运算符表达式265
第30章以换行符作为分隔符269
第31章外部DSL拾遗272

第四部分　内部DSL主题

第32章表达式生成器276
第33章函数序列282
第34章嵌套函数286
第35章方法级联299
第36章对象范围309
第37章闭包319
第38章嵌套闭包324
第39章列表的字面构造335
第40章Literal Map336
第41章动态接收342
第42章标注357
第43章解析树操作365
第44章类符号表375
第45章文本润色383
第46章为字面量提供扩展386

第五部分　其他计算模型

第47章适应性模型390
第48章决策表395
第49章依赖网络403
第50章产生式规则系统409
第51章状态机421

第六部分　代 码 生 成

第52章基于转换器的代码生成426
第53章模板化的生成器431
第54章嵌入助手438
第55章基于模型的代码生成444
第56章无视模型的代码生成454
第57章代沟457

参考文献463

================
目录

译者序
前言

第一部分　叙　　述

第1章入门例子2

1.1　哥特式建筑安全系统2
1.2　状态机模型4
1.3　为格兰特小姐的控制器编写程序7
1.4　语言和语义模型13
1.5使用代码生成15
1.6　使用语言工作台17
1.7　可视化20

第2章　使用DSL21

2.1定义DSL21
2.1.1DSL的边界22
2.1.2片段DSL和独立DSL25
2.2为何需要DSL25
2.2.1　提高开发效率26
2.2.2与领域专家的沟通26
2.2.3执行环境的改变27
2.2.4其他计算模型28
2.3DSL的问题28
2.3.1语言噪音29
2.3.2构建成本29
2.3.3集中营语言30
2.3.4 “一叶障目”的抽象30
2.4广义的语言处理31
2.5DSL的生命周期31
2.6设计优良的DSL从何而来32

第3章实现DSL34

3.1DSL处理之架构34
3.2解析器的工作方式37
3.3文法、语法和语义39
3.4解析中的数据39
3.5宏41
3.6测试DSL42
3.6.1语义模型的测试42
3.6.2解析器的测试45
3.6.3脚本的测试49
3.7错误处理50
3.8DSL迁移51

第4章实现内部DSL54

4.1连贯API与命令–查询API54
4.2解析层的需求57
4.3使用函数58
4.4字面量集合61
4.5基于文法选择内部元素63
4.6闭包64
4.7解析树操作66
4.8标注67
4.9为字面量提供扩展69
4.10消除语法噪音69
4.11动态接收69
4.12提供类型检查70

第5章实现外部DSL72

5.1语法分析策略72
5.2输出生成策略74
5.3解析中的概念76
5.3.1单独的词法分析76
5.3.2文法和语言77
5.3.3正则文法、上下文无关文法和上下文相关文法77
5.3.4自顶向下解析和自底向上解析79
5.4混入另一种语言81
5.5XML DSL82

第6章内部DSL vs 外部DSL84

6.1学习曲线84
6.2创建成本85
6.3程序员的熟悉度85
6.4与领域专家沟通86
6.5与宿主语言混合86
6.6强边界87
6.7运行时配置87
6.8趋于平庸88
6.9组合多种DSL88
6.10总结89

第7章其他计算模型概述90

7.1几种计算模型92
7.1.1决策表92
7.1.2产生式规则系统93
7.1.3状态机94
7.1.4依赖网络95
7.1.5选择模型95

第8章代码生成96

8.1选择生成什么96
8.2如何生成99
8.3混合生成代码和手写代码100
8.4生成可读的代码101
8.5解析之前的代码生成101
8.6延伸阅读101
第9章语言工作台102
9.1语言工作台之要素102
9.2模式定义语言和元模型103
9.3源码编辑和投射编辑107
9.4说明性编程109
9.5工具之旅110
9.6语言工作台和CASE工具112
9.7我们该使用语言工作台吗112


第二部分　通 用 主 题

第10章各种DSL116

10.1Graphviz116
10.2JMock117
10.3CSS118
10.4HQL119
10.5XAML120
10.6FIT122
10.7Make等123

第11章语义模型125

11.1工作原理125
11.2使用场景127
11.3入门例子（Java）128

第12章符号表129

12.1工作原理129
12.2使用场景131
12.3参考文献131
12.4以外部DSL实现的依赖网络（Java和ANTLR）131
12.5在一个内部DSL中使用符号键（Ruby）133
12.6用枚举作为静态类型符号（Java）134

第13章语境变量137

13.1工作原理137
13.2使用场景137
13.3读取INI文件（C#）138

第14章构造型生成器141

14.1工作原理141
14.2使用场景142
14.3构建简单的航班信息（C#）142

第15章宏144

15.1工作原理144
15.1.1文本宏145
15.1.2语法宏148
15.2使用场景151

第16章通知153

16.1工作原理153
16.2使用场景154
16.3一个非常简单的通知（C#）154
16.4解析中的通知（Java）155


第三部分　外部DSL主题

第17章分隔符指导翻译160

17.1工作原理160
17.2使用场景162
17.3常客记分（C#）163
17.3.1　语义模型163
17.3.2解析器165
17.4使用格兰特小姐的控制器解析非自治语句(Java)168

第18章语法指导翻译175

18.1工作原理175
18.1.1词法分析器176
18.1.2语法分析器179
18.1.3产生输出181
18.1.4语义预测181
18.2使用场景182
18.3参考文献182

第19章BNF183

19.1工作原理183
19.1.1多重性符号（Kleene运算符）184
19.1.2其他一些有用的运算符186
19.1.3解析表达式文法186
19.1.4将EBNF转换为基础BNF187
19.1.5行为代码189
19.2使用场景191

第20章基于正则表达式表的词法分析器192

20.1工作原理192
20.2使用场景193
20.3格兰特小姐控制器的词法处理（Java）194

第21章递归下降法语法解析器197

21.1工作原理197
21.2使用场景200
21.3参考文献200
21.4递归下降和格兰特小姐的控制器（Java）201

第22章解析器组合子205

22.1工作原理206
22.1.1处理动作208
22.1.2函数式风格的组合子209
22.2使用场景209
22.3解析器组合子和格兰特小姐的控制器（Java）210

第23章解析器生成器217

23.1工作原理217
23.2使用场景219
23.3Hello World（Java和ANTLR）219
23.3.1编写基本的文法220
23.3.2构建语法分析器221
23.3.3为文法添加代码动作223
23.3.4使用代沟225

第24章树的构建227

24.1工作原理227
24.2使用场景229
24.3使用ANTLR的树构建语法（Java和ANTLR）230
24.3.1标记解释230
24.3.2解析231
24.3.3组装语义模型233
24.4使用代码动作进行树的构建（Java和ANTLR）236

第25章嵌入式语法翻译242

25.1工作原理242
25.2使用场景243
25.3格兰特小姐的控制器（Java和ANTLR）243

第26章内嵌解释器247

26.1工作原理247
26.2使用场景247
26.3计算器（ANTLR和Java）247

第27章外加代码250

27.1工作原理250
27.2使用场景251
27.3嵌入动态代码（ANTLR、Java和JavaScript）252
27.3.1语义模型252
27.3.2语法分析器254

第28章可变分词方式258

28.1工作原理258
28.1.1字符引用259
28.1.2词法状态261
28.1.3修改标记类型262
28.1.4忽略标记类型263
28.2使用场景264

第29章嵌套的运算符表达式265

29.1工作原理265
29.1.1使用自底向上的语法分析器265
29.1.2自顶向下的语法分析器266
29.2使用场景268

第30章以换行符作为分隔符269

30.1工作原理269
30.2使用场景271

第31章外部DSL拾遗272

31.1语法缩进272
31.2模块化文法274


第四部分　内部DSL主题

第32章表达式生成器276

32.1工作原理276
32.2使用场景277
32.3具有和没有生成器的连贯日历（Java）278
32.4对于日历使用多个生成器（Java）280

第33章函数序列282

33.1工作原理282
33.2使用场景283
33.3简单的计算机配置（Java）283

第34章嵌套函数286

34.1工作原理286
34.2使用场景287
34.3简单计算机配置范例（Java）288
34.4用标记处理多个不同的参数（C#）289
34.5针对IDE支持使用子类型标记（Java）291
34.6使用对象初始化器（C#）292
34.7周期性事件（C#）293
34.7.1语义模型294
34.7.2DSL296

第35章方法级联299

35.1工作原理299
35.1.1生成器还是值300
35.1.2收尾问题301
35.1.3分层结构301
35.1.4渐进式接口302
35.2使用场景303
35.3简单的计算机配置范例（Java）303
35.4带有属性的方法级联（C#）306
35.5渐进式接口（C#）307

第36章对象范围309

36.1工作原理309
36.2使用场景310
36.3安全代码（C#）310
36.3.1　语义模型311
36.3.2DSL313
36.4使用实例求值（Ruby）315
36.5使用实例初始化器（Java）317

第37章闭包319

37.1工作原理319
37.2使用场景323

第38章嵌套闭包324

38.1工作原理324
38.2使用场景325
38.3用嵌套闭包来包装函数序列（Ruby）326
38.4简单的C#示例（C#）327
38.5使用方法级联（Ruby）328
38.6带显式闭包参数的函数序列（Ruby）330
38.7采用实例级求值（Ruby）332

第39章列表的字面构造335

39.1工作原理335
39.2使用场景335

第40章Literal Map336

40.1工作原理336
40.2使用场景336
40.3使用List和Map表达计算机的配置信息（Ruby）337
40.4演化为Greenspun式（Ruby）338

第41章动态接收342

41.1工作原理342
41.2使用场景343
41.3积分——使用方法名解析（Ruby）344
41.3.1模型345
41.3.2生成器347
41.4积分——使用方法级联（Ruby）348
41.4.1模型349
41.4.2生成器349
41.5去掉安全仪表盘控制器中的引用（JRuby）351

第42章标注357

42.1工作原理357
42.1.1定义标注358
42.1.2处理标注359
42.2使用场景360
42.3用于运行时处理的特定语法（Java）360
42.4使用类方法（Ruby）362
42.5动态代码生成（Ruby）363

第43章解析树操作365

43.1工作原理365
43.2使用场景366
43.3由C#条件生成IMAP查询（C#）367
43.3.1语义模型367
43.3.2以C#构建369
43.3.3退后一步373

第44章类符号表375

44.1　工作原理375
44.2使用场景376
44.3在静态类型中实现类符号表（Java）377

第45章文本润色383

45.1工作原理383
45.2使用场景383
45.3使用润色的折扣规则（Ruby）384

第46章为字面量提供扩展386

46.1工作原理386
46.2使用场景387
46.3食谱配料（C#）387


第五部分　其他计算模型

第47章适应性模型390

47.1工作原理390
47.1.1在适应性模型中使用命令式代码391
47.1.2工具393
47.2使用场景394

第48章决策表395

48.1工作原理395
48.2使用场景396
48.3为一个订单计算费用（C#）396
48.3.1模型397
48.3.2解析器400

第49章依赖网络403

49.1工作原理403
49.2使用场景405
49.3分析饮料（C#）405
49.3.1语义模型406
49.3.2解析器407

第50章产生式规则系统409

50.1工作原理409
50.1.1链式操作410
50.1.2矛盾推导411
50.1.3规则结构里的模式412
50.2使用场景412
50.3俱乐部会员校验（C#）412
50.3.1模型413
50.3.2解析器414
50.3.3演进DSL414
50.4适任资格的规则：扩展俱乐部成员（C#）416
50.4.1模型417
50.4.2解析器419

第51章状态机421

51.1工作原理421
51.2使用场景423
51.3安全面板控制器（Java）423


第六部分　代 码 生 成

第52章基于转换器的代码生成426

52.1工作原理426
52.2使用场景427
52.3安全面板控制器（Java生成的C）427

第53章模板化的生成器431

53.1工作原理431
53.2使用场景432
53.3生成带有嵌套条件的安全控制面板状态机（Velocity和Java生成的C）432

第54章嵌入助手438

54.1工作原理438
54.2使用场景439
54.3安全控制面板的状态（Java和ANTLR）439
54.4助手类应该生成HTML吗（Java和Velocity）442

第55章基于模型的代码生成444

55.1工作原理444
55.2使用场景445
55.3安全控制面板的状态机（C）445
55.4动态载入状态机（C）451

第56章无视模型的代码生成454

56.1工作原理454
56.2使用场景455
56.3使用嵌套条件的安全面板状态机（C）455

第57章代沟457

57.1工作原理457
57.2使用场景458
57.3根据数据结构生成类（Java和一些Ruby）459


参考文献463