C#高级编程(第8版)
《Professional C# 2012 and .NET 4.5》
内格尔 (Christian Nagel) (作者), Bill Evjen (作者), Jay Glynn (作者), Karli Watson (作者)
黄静 (合著者), 李铭 (译者)
109.20(74折)，中文电子版只有前3章。
共47章。

有英文电子版。有中文第7版电子扫描版。

====
出版社: 清华大学出版社; 第1版 (2013年11月1日)
外文书名: Professional C# 2012 and .NET 4.5
丛书名: .NET开发经典名著
平装: 1517页
语种： 简体中文
开本: 16

====
编辑推荐
内格尔编著的《C#高级编程(第8版.NET开发经典名著)》旨在帮助有经验的程序员，
更新和提升他们使用C#和.NET 4.5编写Windows应用程序、Web app和Metro apps等方面的技能。
书中提供了丰富的有关中、高级功能的信息，包括了职业开发人员需要了解和应用C#进行工作的全部知识。

作者简介

作者：（美国）内格尔（Christian Nagel） （美国） Bill Evjen （美国）Jay Glynn （美国） Karli Watson 
译者：李铭 

Christian Nagel是微软技术代言人（Microsoft Rd）、软件架构师、开发人员、作者、培训师，他定期在国际会议上发言。 

Bill Evjen是Swank Pictures的CTO，微软技术代言人（Microsoft Rd）、国际.NET联合会的创始人。 

Jay Glynn是PureSafety的首席构架师，
PureSafety是一家为劳动力的安全和健康提供结果驱动的软件和信息解决方案的业界领先的提供商。 

Karli Watson是一位自由作家，是3form有限公司的技术顾问。

====
目录

第Ⅰ部分 C#语言 

第1章 .NET体系结构 
第2章 核心C# 
第3章 对象和类型 
第4章 继承 
第5章 泛型 
第6章 数组 
第7章 运算符和类型强制转换 
第8章 委托、Lambda表达式和事件 
第9章 字符串和正则表达式 
第10章 集合 

第11章 LINQ 

第12章 动态语言扩展 
第13章 异步编程 
第14章 内存管理和指针 
第15章 反射 
第16章 错误和异常 


第Ⅱ部分 VisualStudio 

第17章 VisualStudio2012 
第18章 部署 


第Ⅲ部分 基础 

第19章 程序集 
第20章 诊断 
第21章 任务、线程和同步 
第22章 安全性 

第23章 互操作 

23.1 .NET和COM技术 
23.2 在.NET客户端中使用COM组件 
23.3 在COM客户端中使用.NET组件 

第24章 文件和注册表操作 
第25章 事务处理 
第26章 网络 
第27章 Windows服务 
第28章 本地化 
第29章 核心XAML 
第30章 ManagedExtensibilityFramework 

第31章 Windows运行库 
31.6 摄像头功能 


第Ⅳ部分 数据 

第32章 核心ADO.NET 
第33章 ADO.NETEntityFramework 
第34章 处理XML 


第Ⅴ部分 显示 

第35章 核心WPF 
第36章 用WPF编写业务应用程序 
第37章 用WPF创建文档 

第38章 Windows8应用程序 

第39章 核心ASP.NET 
第40章 ASP.NET WebForms 
第41章 ASP.NET MVC 
第42章 ASP.NET动态数据 


第Ⅵ部分 通信 

第43章 WCF 
第44章 WCF数据服务 
第45章 WindowsWF4 
第46章 对等网络 
第47章 消息队列 

====
目录

第Ⅰ部分C#语言 

第1章.NET体系结构 

第2章核心C# 

2.1C#基础 
2.2第一个C#程序 
2.3变量 
2.4预定义数据类型 
2.5流控制 
2.6枚举 
2.7名称空间 
2.8Main（）方法 
2.9有关编译C#文件的更多内容 
2.10控制台I/O 
2.11使用注释 
2.12C#预处理器指令 
2.13C#编程规则 

第3章对象和类型 

3.1创建及使用类 
3.2类和结构 
3.3类 
3.4匿名类型 
3.5结构 
3.6弱引用 
3.7部分类 
3.8静态类 
3.9Object类 
3.10扩展方法 

第4章继承 

4.1继承 
4.2继承的类型 
4.3实现继承 
4.4修饰符 
4.5接口 

第5章泛型 

5.1泛型概述 
5.2创建泛型类 
5.3泛型类的功能 
5.4泛型接口 
5.5泛型结构 
5.6泛型方法 

第6章数组 

6.1同一类型和不同类型的多个对象 
6.2简单数组 
6.3多维数组 
6.4锯齿数组 
6.5Array类 
6.6数组作为参数 
6.7枚举 
6.8元组 
6.9结构比较 

第7章运算符和类型强制转换 

7.1运算符和类型转换 
7.2运算符 
7.3类型的安全性 
7.4比较对象的相等性 
7.5运算符重载 
7.6用户定义的类型强制转换 

第8章委托、Lambda表达式和事件 

8.1引用方法 
8.2委托 
8.3Lambda表达式 
8.4事件 

第9章字符串和正则表达式 

9.1System.String类 
9.2正则表达式 

第10章集合 

10.1概述 
10.2集合接口和类型 
10.3列表 
10.4队列 
10.5栈 
10.6链表 
10.7有序列表 
10.8字典 
10.9集 
10.10可观察的集合 
10.11位数组 
10.12并发集合 
10.13性能 

第11章LINQ 

11.1LINQ概述 
11.2标准的查询操作符 
11.3并行LINQ 
11.4表达式树 
11.5LINQ提供程序 

第12章动态语言扩展 

12.1DLR 
12.2dynamic类型 
12.3包含DLRScriptRuntime 
12.4DynamicObject和ExpandoObject 

第13章异步编程 

13.1异步编程的重要性 
13.2异步模式 
13.3异步编程的基础 
13.4错误处理 
13.5取消 

第14章内存管理和指针 

14.1内存管理 
14.2后台内存管理 
14.3释放非托管的资源 
14.4不安全的代码 

第15章反射 

15.1在运行期间处理和检查代码 
15.2自定义特性 
15.3反射 

第16章错误和异常 

16.1简介 
16.2异常类 
16.3捕获异常 
16.4用户定义的异常类 
16.5调用者信息 


第Ⅱ部分VisualStudio 

第17章VisualStudio2012 

17.1用VisualStudio2012进行工作 
17.2创建项目 
17.3浏览并编写项目 
17.4构建项目 
17.5调试代码 
17.6重构工具 
17.7体系结构工具 
17.8分析应用程序 
17.9单元测试 
17.10Windows8、WCF、WF等 

第18章部署 

18.1部署是应用程序生命周期的一部分 
18.2部署的规划 
18.3传统的部署选项 
18.4ClickOnce 
18.5Web部署 
18.6Windows8应用程序 


第Ⅲ部分基础 

第19章程序集 

19.1程序集的含义 
19.2构建程序集 
19.3应用程序域 
19.4共享程序集 
19.5配置.NET应用程序 
19.6版本问题 
19.7在不同的技术之间共享程序集 

第20章诊断 

20.1诊断概述 
20.2代码协定 
20.3跟踪 
20.4事件日志 
20.5性能监视 

第21章任务、线程和同步 

21.1概述 
21.2Parallel类 
21.3任务 
21.4取消架构 
21.5线程池 
21.6Thread类 
21.7线程问题 
21.8同步 
21.9Timer类 
21.10数据流 

第22章安全性 

22.1概述 
22.2身份验证和授权 
22.3加密 
22.4资源的访问控制 
22.5代码访问安全性 
22.6使用证书发布代码 

第23章互操作 

23.1.NET和COM技术 
23.2在.NET客户端中使用COM组件 
23.3在COM客户端中使用.NET组件 

第24章文件和注册表操作 

24.1文件和注册表 
24.2管理文件系统 
24.3移动、复制和删除文件 
24.4读写文件 
24.5映射内存的文件 
24.6读取驱动器信息 
24.7文件的安全性 
24.8读写注册表 
24.9读写独立存储器 

第25章事务处理 

25.1简介 
25.2概述 
25.3数据库和实体类 
25.4传统的事务 
25.5System.Transactions 
25.6隔离级别 
25.7自定义资源管理器 
25.8文件系统事务 

第26章网络 

26.1网络 
26.2WebClient类 
26.3WebRequest类和WebResponse类 
26.4把输出结果显示为HTML页面 
26.5实用工具类 
26.6较低层的协议 

第27章Windows服务 

27.1Windows服务 
27.2Windows服务的体系结构 
27.3创建Windows服务程序 
27.4Windows服务的监控和控制 
27.5故障排除和事件日志 

第28章本地化 

28.1全球市场 
28.2System.Globalization名称空间 
28.3资源 
28.4使用VisualStudio的WindowsForms本地化 
28.5ASP.NETWebForms的本地化 
28.6用WPF本地化 
28.7自定义资源读取器 
28.8创建自定义区域性 
28.9用WindowsStore应用程序进行本地化 

第29章核心XAML 

29.1XAML的作用 
29.2概述 
29.3依赖属性 
29.4附加属性 
29.5标记扩展 
29.6创建自定义标记扩展 
29.7XAML定义的标记扩展 
29.8读写XAML 

第30章ManagedExtensibilityFramework 

30.1概述 
30.2MEF的体系结构 
30.3定义协定 
30.4导出部件 
30.5导入部件 
30.6容器和出口提供程序 
30.7类别 

第31章Windows运行库 

31.1概述 
31.2Windows运行库组件 
31.2.1集合 
31.2.2流 
31.2.3委托与事件 
31.2.4异步操作 
31.3Windows8应用程序 
31.4Windows8应用程序的生命周期 
31.5Windows8应用程序的设置 
31.6摄像头功能 


第Ⅳ部分数据 

第32章核心ADO.NET 

32.1ADO.NET概述 
32.2使用数据库连接 
32.3命令 
32.4快速数据访问：数据读取器 
32.5异步数据访问：使用Task和await 
32.6管理数据和关系：DataSet类 
32.7XML架构：用XSD生成代码 
32.8填充DataSet类 
32.9持久化DataSet类的修改 
32.10使用ADO.NET 

第33章ADO.NETEntityFramework 

33.1用EntityFramework编程 
33.2EntityFramework映射 
33.3实体 
33.4对象上下文 
33.5关系 
33.6查询数据 
33.7把数据写入数据库 
33.8使用POCO对象 
33.9使用CodeFirst编程模型 

第34章处理XML 

34.1XML 
34.2.NET支持的XML标准 
34.3System.Xml名称空间 
34.4使用System.Xml类 
34.5读写流格式的XML 
34.6在.NET中使用DOM 
34.7使用XPathNavigator类 
34.8XML和ADO.NET 
34.9在XML中序列化对象 
34.10LINQtoXML和.NET 
34.11使用不同的XML对象 
34.12使用LINQ查询XML文档 
34.13XML文档的更多查询技术 


第Ⅴ部分显示 

第35章核心WPF 

35.1理解WPF 
35.2形状 
35.3几何图形 
35.4变换 
35.5画笔 
35.6控件 
35.7布局 
35.8样式和资源 
35.9触发器 
35.10模板 
35.11动画 
35.12可见状态管理器 
35.13 3—D 

第36章用WPF编写业务应用程序 

36.1概述 
36.2菜单和功能区控件 
36.3Commanding 
36.4数据绑定 
36.5TreeView 
36.6DataGrid 

第37章用WPF创建文档 

37.1简介 
37.2文本元素 
37.3流文档 
37.4固定文档 
37.5XPS文档 
37.6打印 

第38章Windows8应用程序 

38.1概述 
38.2Windows8的现代UI设计 
38.3示例应用程序的核心功能 
38.4应用程序工具栏 
38.5启动与导航 
38.6布局的变化 
38.7存储 
38.8选择器 
38.9共享协定 
38.10Tile 

第39章核心ASP.NET 

39.1用于Web应用程序的.NETFramework 
39.2Web技术 
39.3托管和配置 
39.4处理程序和模块 
39.5全局的应用程序类 
39.6请求和响应 
39.7状态管理 
39.8成员和角色 

第40章ASP.NET WebForms 

40.1概述 
40.2ASPX页面模型 
40.3母版页 
40.4导航 
40.5验证用户输入 
40.6访问数据 
40.7安全性 
40.8Ajax 

第41章ASP.NETMVC 

41.1ASP.NETMVC概述 
41.2定义路由 
41.3创建控制器 
41.4创建视图 
41.5从客户端提交数据 
41.6HTMLHelper 
41.7创建数据驱动的应用程序 
41.8动作过滤器 
41.9身份验证和授权 
41.10ASP.NETWebAPI 

第42章ASP.NET动态数据 

42.1概述 
42.2创建动态数据Web应用程序 
42.3定制动态数据网站 


第Ⅵ部分通信 

第43章WCF 

43.1WCF概述 
43.2创建简单的服务和客户端 
43.3协定 
43.4服务的行为 
43.5绑定 
43.6宿主 
43.7客户端 
43.8双工通信 
43.9路由 

第44章WCF数据服务 

44.1概述 
44.2包含CLR对象的自定义宿主 
44.3HTTP客户端应用程序 
44.4使用WCF数据服务和ADO.NETEntityFramework 

第45章WindowsWF4 

45.1工作流概述 
45.2HelloWorld示例 
45.3活动 
45.4自定义活动 
45.5工作流 

第46章对等网络 

46.1P2P网络概述 
46.2PNRP 
46.3构建P2P应用程序 

第47章消息队列 

47.1概述 
47.2MessageQueuing产品 
47.3消息队列体系结构 
47.4MessageQueuing管理工具 
47.5消息队列的编程实现 
47.6课程订单应用程序 
47.7接收结果 
47.8事务队列 
47.9消息队列和WCF 


====
目录


第Ⅰ部分C#语言 

第1章.NET体系结构 

1.1C#与.NET的关系 
1.2公共语言运行库 
1.2.1平台无关性 
1.2.2提高性能 
1.2.3语言的互操作性 
1.3中间语言 
1.3.1面向对象和接口的支持 
1.3.2不同的值类型和引用类型 
1.3.3强数据类型化 
1.3.4通过异常处理错误 
1.3.5特性的使用 
1.4程序集 
1.4.1私有程序集 
1.4.2共享程序集 
1.4.3反射 
1.4.4并行编程 
1.4.5异步编程 
1.5.NETFramework类 
1.6名称空间 
1.7用C#创建.NET应用程序 
1.7.1创建ASP.NET应用程序 
1.7.2使用WPF 
1.7.3Windows8应用程序 
1.7.4Windows服务 
1.7.5WCF 
1.7.6WindowsWF 
1.8C#在.NET企业体系结构中的作用 
1.9小结 

第2章核心C# 

2.1C#基础 
2.2第一个C#程序 
2.2.1代码 
2.2.2编译并运行程序 
2.2.3详细介绍 
2.3变量 
2.3.1变量的初始化 
2.3.2类型推断 
2.3.3变量的作用域 
2.3.4常量 
2.4预定义数据类型 
2.4.1值类型和引用类型 
2.4.2CTS类型 
2.4.3预定义的值类型 
2.4.4预定义的引用类型 
2.5流控制 
2.5.1条件语句 
2.5.2循环 
2.5.3跳转语句 
2.6枚举 
2.7名称空间 
2.7.1using语句 
2.7.2名称空间的别名 
2.8Main（）方法 
2.8.1多个Main（）方法 
2.8.2给Main（）方法传递参数 
2.9有关编译C#文件的更多内容 
2.10控制台I/O 
2.11使用注释 
2.11.1源文件中的内部注释 
2.11.2XML文档 
2.12C#预处理器指令 
2.12.1#define和#undef 
2.12.2#if、#elif、#else和#endif 
2.12.3#warning和#error 
2.12.4#region和#endregion 
2.12.5#line 
2.12.6#pragma 
2.13C#编程规则 
2.13.1关于标识符的规则 
2.13.2用法约定 
2.14小结 

第3章对象和类型 

3.1创建及使用类 
3.2类和结构 
3.3类 
3.3.1数据成员 
3.3.2函数成员 
3.3.3只读字段 
3.4匿名类型 
3.5结构 
3.5.1结构是值类型 
3.5.2结构和继承 
3.5.3结构的构造函数 
3.6弱引用 
3.7部分类 
3.8静态类 
3.9Object类 
3.9.1System.Object的方法 
3.9.2ToString()方法 
3.10扩展方法 
3.11小结 

第4章继承 

4.1继承 
4.2继承的类型 
4.2.1实现继承和接口继承 
4.2.2多重继承 
4.2.3结构和类 
4.3实现继承 
4.3.1虚方法 
4.3.2隐藏方法 
4.3.3调用函数的基类版本 
4.3.4抽象类和抽象函数 
4.3.5密封类和密封方法 
4.3.6派生类的构造函数 
4.4修饰符 
4.4.1可见性修饰符 
4.4.2其他修饰符 
4.5接口 
4.5.1定义和实现接口 
4.5.2派生的接口 
4.6小结 

第5章泛型 

5.1泛型概述 
5.1.1性能 
5.1.2类型安全 
5.1.3二进制代码的重用 
5.1.4代码的扩展 
5.1.5命名约定 
5.2创建泛型类 
5.3泛型类的功能 
5.3.1默认值 
5.3.2约束 
5.3.3继承 
5.3.4静态成员 
5.4泛型接口 
5.4.1协变和抗变 
5.4.2泛型接口的协变 
5.4.3泛型接口的抗变 
5.5泛型结构 
5.6泛型方法 
5.6.1泛型方法示例 
5.6.2带约束的泛型方法 
5.6.3带委托的泛型方法 
5.6.4泛型方法规范 
5.7小结 

第6章数组 

6.1同一类型和不同类型的多个对象 
6.2简单数组 
6.2.1数组的声明 
6.2.2数组的初始化 
6.2.3访问数组元素 
6.2.4使用引用类型 
6.3多维数组 
6.4锯齿数组 
6.5Array类 
6.5.1创建数组 
6.5.2复制数组 
6.5.3排序 
6.6数组作为参数 
6.6.1数组协变 
6.6.2ArraySegment 
6.7枚举 
6.7.1IEnumerator接口 
6.7.2foreach语句 
6.7.3yield语句 
6.8元组 
6.9结构比较 
6.10小结 

第7章运算符和类型强制转换 

7.1运算符和类型转换 
7.2运算符 
7.2.1运算符的简化操作 
7.2.2运算符的优先级 
7.3类型的安全性 
7.3.1类型转换 
7.3.2装箱和拆箱 
7.4比较对象的相等性 
7.4.1比较引用类型的相等性 
7.4.2比较值类型的相等性 
7.5运算符重载 
7.5.1运算符的工作方式 
7.5.2运算符重载的示例：Vector结构 
7.6用户定义的类型强制转换 
7.6.1实现用户定义的类型强制转换 
7.6.2多重类型强制转换 
7.7小结 

第8章委托、Lambda表达式和事件 

8.1引用方法 
8.2委托 
8.2.1声明委托 
8.2.2使用委托 
8.2.3简单的委托示例 
8.2.4Action和Func委托 
8.2.5BubbleSorter示例 
8.2.6多播委托 
8.2.7匿名方法 
8.3Lambda表达式 
8.3.1参数 
8.3.2多行代码 
8.3.3闭包 
8.3.4使用foreach语句的闭包 
8.4事件 
8.4.1事件发布程序 
8.4.2事件侦听器 
8.4.3弱事件 
8.5小结 

第9章字符串和正则表达式 

9.1System.String类 
9.1.1创建字符串 
9.1.2StringBuilder成员 
9.1.3格式字符串 
9.2正则表达式 
9.2.1正则表达式概述 
9.2.2RegularExpressionsPlayaround示例 
9.2.3显示结果 
9.2.4匹配、组合和捕获 
9.3小结 

第10章集合 

10.1概述 
10.2集合接口和类型 
10.3列表 
10.3.1创建列表 
10.3.2只读集合 
10.4队列 
10.5栈 
10.6链表 
10.7有序列表 
10.8字典 
10.8.1键的类型 
10.8.2字典示例 
10.8.3Lookup类 
10.8.4有序字典 
10.9集 
10.10可观察的集合 
10.11位数组 
10.11.1BitArray类 
10.11.2BitVector32结构 
10.12并发集合 
10.12.1创建管道 
10.12.2使用Blocking—Collection 
10.12.3使用Concurrent—Dictionary 
10.12.4完成管道 
10.13性能 
10.14小结 

第11章LINQ 

11.1LINQ概述 
11.1.1列表和实体 
11.1.2LINQ查询 
11.1.3扩展方法 
11.1.4推迟查询的执行 
11.2标准的查询操作符 
11.2.1筛选 
11.2.2用索引筛选 
11.2.3类型筛选 
11.2.4复合的from子句 
11.2.5排序 
11.2.6分组 
11.2.7对嵌套的对象分组 
11.2.8内连接 
11.2.9左外连接 
11.2.10组连接 
11.2.11集合操作 
11.2.12合并 
11.2.13分区 
11.2.14聚合操作符 
11.2.15转换操作符 
11.2.16生成操作符 
11.3并行LINQ 
11.3.1并行查询 
11.3.2分区器 
11.3.3取消 
11.4表达式树 
11.5LINQ提供程序 
11.6小结 

第12章动态语言扩展 

12.1DLR 
12.2dynamic类型 
12.3包含DLRScriptRuntime 
12.4DynamicObject和ExpandoObject 
12.4.1DynamicObject 
12.4.2ExpandoObject 
12.5小结 

第13章异步编程 

13.1异步编程的重要性 
13.2异步模式 
13.2.1同步调用 
13.2.2异步模式 
13.2.3基于事件的异步模式 
13.2.4基于任务的异步模式 
13.3异步编程的基础 
13.3.1创建任务 
13.3.2调用异步方法 
13.3.3延续任务 
13.3.4同步上下文 
13.3.5使用多个异步方法 
13.3.6转换异步模式 
13.4错误处理 
13.4.1异步方法的异常处理 
13.4.2多个异步方法的异常处理 
13.4.3AggregateException类 
13.5取消 
13.5.1开始取消任务 
13.5.2使用框架特性取消任务 
13.5.3取消自定义任务 
13.6小结 

第14章内存管理和指针 

14.1内存管理 
14.2后台内存管理 
14.2.1值数据类型 
14.2.2引用数据类型 
14.2.3垃圾回收 
14.3释放非托管的资源 
14.3.1析构函数 
14.3.2IDisposable接口 
14.3.3实现IDisposable接口和析构函数 
14.4不安全的代码 
14.4.1用指针直接访问内存 
14.4.2指针示例：PointerPlayground 
14.4.3使用指针优化性能 
14.5小结 

第15章反射 

15.1在运行期间处理和检查代码 
15.2自定义特性 
15.2.1编写自定义特性 
15.2.2自定义特性示例：WhatsNewAttributes 
15.3反射 
15.3.1System.Type类 
15.3.2TypeView示例 
15.3.3Assembly类 
15.3.4完成WhatsNewAttributes示例 
15.4小结 

第16章错误和异常 

16.1简介 
16.2异常类 
16.3捕获异常 
16.3.1实现多个catch块 
16.3.2在其他代码中捕获异常 
16.3.3System.Exception属性 
16.3.4没有处理异常时所发生的情况 
16.3.5嵌套的try块 
16.4用户定义的异常类 
16.4.1捕获用户定义的异常 
16.4.2抛出用户定义的异常 
16.4.3定义用户定义的异常类 
16.5调用者信息 
16.6小结 


第Ⅱ部分VisualStudio 

第17章VisualStudio2012 

17.1用VisualStudio2012进行工作 
17.1.1项目文件的改进 
17.1.2VisualStudio的版本 
17.1.3VisualStudio设置 
17.2创建项目 
17.2.1面向多个版本的.NETFramework 
17.2.2选择项目类型 
17.3浏览并编写项目 
17.3.1SolutionExplorer 
17.3.2用代码编辑器进行工作 
17.3.3学习和理解其他窗口 
17.3.4排列窗口 
17.4构建项目 
17.4.1构建、编译和生成 
17.4.2调试版本和发布版本 
17.4.3选择配置 
17.4.4编辑配置 
17.5调试代码 
17.5.1设置断点 
17.5.2使用数据提示和调试器可视化工具 
17.5.3监视和修改变量 
17.5.4异常 
17.5.5多线程 
17.5.6IntelliTrace 
17.6重构工具 
17.7体系结构工具 
17.7.1依赖项关系图 
17.7.2层关系图 
17.8分析应用程序 
17.8.1序列图 
17.8.2探查器 
17.8.3ConcurrencyVisualizer 
17.8.4CodeAnalysis 
17.8.5CodeMetrics 
17.9单元测试 
17.9.1创建单元测试 
17.9.2运行单元测试 
17.9.3预期异常 
17.9.4测试全部代码路径 
17.9.5外部依赖 
17.9.6FakesFramework 
17.10Windows8、WCF、WF等 
17.10.1使用VisualStudio2012生成WCF应用程序 
17.10.2使用VisualStudio2012生成WF应用程序 
17.10.3使用VisualStudio2012生成WindowsStore应用程序 
17.11小结 

第18章部署 

18.1部署是应用程序生命周期的一部分 
18.2部署的规划 
18.2.1部署选项 
18.2.2部署要求 
18.2.3部署.NET运行库 
18.3传统的部署选项 
18.3.1xcopy部署 
18.3.2xcopy和Web应用程序 
18.3.3WindowsInstaller 
18.4ClickOnce 
18.4.1ClickOnce操作 
18.4.2发布ClickOnce应用程序 
18.4.3ClickOnce设置 
18.4.4ClickOnce文件的应用程序缓存 
18.4.5应用程序的安装 
18.4.6ClickOnce部署API 
18.5Web部署 
18.5.1Web应用程序 
18.5.2配置文件 
18.5.3创建WebDeploy包 
18.6Windows8应用程序 
18.6.1创建应用程序包 
18.6.2WindowsAppCertificationKit 
18.6.3旁加载 
18.6.4Windows部署API 
18.7小结 


第Ⅲ部分基础 

第19章程序集 

19.1程序集的含义 
19.1.1程序集的功能 
19.1.2程序集的结构 
19.1.3程序集清单 
19.1.4名称空间、程序集和组件 
19.1.5私有程序集和共享程序集 
19.1.6附属程序集 
19.1.7查看程序集 
19.2构建程序集 
19.2.1创建模块和程序集 
19.2.2程序集的特性 
19.2.3创建和动态加载程序集 
19.3应用程序域 
19.4共享程序集 
19.4.1强名 
19.4.2使用强名获得完整性 
19.4.3全局程序集缓存 
19.4.4创建共享程序集 
19.4.5创建强名 
19.4.6安装共享程序集 
19.4.7使用共享程序集 
19.4.8程序集的延迟签名 
19.4.9引用 
19.4.10本机映像生成器 
19.5配置.NET应用程序 
19.5.1配置类别 
19.5.2绑定程序集 
19.6版本问题 
19.6.1版本号 
19.6.2通过编程方式获取版本 
19.6.3绑定到程序集版本 
19.6.4发行者策略文件 
19.6.5运行库的版本 
19.7在不同的技术之间共享程序集 
19.7.1共享源代码 
19.7.2可移植类库 
19.8小结 

第20章诊断 

20.1诊断概述 
20.2代码协定 
20.2.1前提条件 
20.2.2后置条件 
20.2.3不变量 
20.2.4纯粹性 
20.2.5接口的协定 
20.2.6简写 
20.2.7协定和遗留代码 
20.3跟踪 
20.3.1跟踪源 
20.3.2跟踪开关 
20.3.3跟踪侦听器 
20.3.4筛选器 
20.3.5相关性 
20.3.6使用ETW进行跟踪 
20.4事件日志 
20.4.1事件日志体系结构 
20.4.2事件日志类 
20.4.3创建事件源 
20.4.4写入事件日志 
20.4.5资源文件 
20.5性能监视 
20.5.1性能监视类 
20.5.2性能计数器生成器 
20.5.3添加PerformanceCounter组件 
20.5.4perfmon.exe 
20.6小结 

第21章任务、线程和同步 

21.1概述 
21.2Parallel类 
21.2.1用Parallel.For（）方法循环 
21.2.2使用Parallel.ForEach（）方法循环 
21.2.3通过Parallel.Invoke（）方法调用多个方法 
21.3任务 
21.3.1启动任务 
21.3.2Future——任务的结果 
21.3.3连续的任务 
21.3.4任务层次结构 
21.4取消架构 
21.4.1Parallel.For（）方法的取消 
21.4.2任务的取消 
21.5线程池 
21.6Thread类 
21.6.1给线程传递数据 
21.6.2后台线程 
21.6.3线程的优先级 
21.6.4控制线程 
21.7线程问题 
21.7.1争用条件 
21.7.2死锁 
21.8同步 
21.8.1lock语句和线程安全 
21.8.2Interlocked类 
21.8.3Monitor类 
21.8.4SpinLock结构 
21.8.5WaitHandle基类 
21.8.6Mutex类 
21.8.7Semaphore类 
21.8.8Events类 
21.8.9Barrier类 
21.8.10ReaderWriterLockSlim类 
21.9Timer类 
21.10数据流 
21.10.1使用动作块 
21.10.2源和目标数据块 
21.10.3连接块 
21.11小结 

第22章安全性 

22.1概述 
22.2身份验证和授权 
22.2.1标识和Principal 
22.2.2角色 
22.2.3声明基于角色的安全性 
22.2.4声称 
22.2.5客户端应用程序服务 
22.3加密 
22.3.1签名 
22.3.2交换密钥和安全传输 
22.4资源的访问控制 
22.5代码访问安全性 
22.5.1第2级安全透明性 
22.5.2权限 
22.6使用证书发布代码 
22.7小结 

第23章互操作 

23.1.NET和COM技术 
23.1.1元数据 
23.1.2释放内存 
23.1.3接口 
23.1.4方法绑定 
23.1.5数据类型 
23.1.6注册 
23.1.7线程 
23.1.8错误处理 
23.1.9事件 
23.1.10封送 
23.2在.NET客户端中使用COM组件 
23.2.1创建一个COM组件 
23.2.2创建运行库可调用包装 
23.2.3使用RCW 
23.2.4通过动态语言扩展使用COM服务 
23.2.5线程问题 
23.2.6添加连接点 
23.3在COM客户端中使用.NET组件 
23.3.1COM可调用包装 
23.3.2创建.NET组件 
23.3.3创建一个类型库 
23.3.4COM互操作特性 
23.3.5COM注册 
23.3.6创建COM客户端应用程序 
23.3.7添加连接点 
23.3.8使用sink对象创建客户端 
23.3.9平台调用 
23.4小结 

第24章文件和注册表操作 

24.1文件和注册表 
24.2管理文件系统 
24.2.1表示文件和文件夹的.NET类 
24.2.2Path类 
24.2.3FileProperties示例 
24.3移动、复制和删除文件 
24.3.1FilePropertiesAndMovement示例 
24.3.2FilePropertiesAndMovement示例的代码 
24.4读写文件 
24.4.1读取文件 
24.4.2写入文件 
24.4.3流 
24.4.4缓存的流 
24.4.5使用FileStream类读写二进制文件 
24.4.6读写文本文件 
24.5映射内存的文件 
24.6读取驱动器信息 
24.7文件的安全性 
24.7.1从文件中读取ACL 
24.7.2从目录中读取ACL 
24.7.3添加和删除文件中的ACL项 
24.8读写注册表 
24.8.1注册表 
24.8.2.NET注册表类 
24.9读写独立存储器 
24.10小结 

第25章事务处理 

25.1简介 
25.2概述 
25.2.1事务处理阶段 
25.2.2ACID属性 
25.3数据库和实体类 
25.4传统的事务 
25.4.1ADO.NET事务 
25.4.2System.Enterprise—Services 
25.5System.Transactions 
25.5.1可提交的事务 
25.5.2事务处理的升级 
25.5.3依赖事务 
25.5.4环境事务 
25.6隔离级别 
25.7自定义资源管理器 
25.8文件系统事务 
25.9小结 

第26章网络 

26.1网络 
26.2WebClient类 
26.2.1下载文件 
26.2.2基本的WebClient示例 
26.2.3上传文件 
26.3WebRequest类和WebResponse类 
26.3.1身份验证 
26.3.2使用代理 
26.3.3异步页面请求 
26.4把输出结果显示为HTML页面 
26.4.1从应用程序中进行简单的Web浏览 
26.4.2启动InternetExplorer实例 
26.4.3给应用程序提供更多IE类型的功能 
26.4.4使用WebBrowser控件打印 
26.4.5显示所请求页面的代码 
26.4.6WebRequest类和WebResponse类的层次结构 
26.5实用工具类 
26.5.1URI 
26.5.2IP地址和DNS名称 
26.6较低层的协议 
26.6.1使用SmtpClient 
26.6.2使用TCP类 
26.6.3TcpSend和TcpReceive示例 
26.6.4TCP和UDP 
26.6.5UDP类 
26.6.6Socket类 
26.6.7WebSocket 
26.7小结 
第27章Windows服务 
27.1Windows服务 
27.2Windows服务的体系结构 
27.2.1服务程序 
27.2.2服务控制程序 
27.2.3服务配置程序 
27.2.4Windows服务的类 
27.3创建Windows服务程序 
27.3.1创建服务的核心功能 
27.3.2QuoteClient示例 
27.3.3Windows服务程序 
27.3.4线程化和服务 
27.3.5服务的安装 
27.3.6安装程序 
27.4Windows服务的监控和控制 
27.4.1MMC管理单元 
27.4.2net.exe实用程序 
27.4.3sc.exe实用程序 
27.4.4VisualStudioServerExplorer 
27.4.5编写自定义ServiceController类 
27.5故障排除和事件日志 
27.6小结 
第28章本地化 
28.1全球市场 
28.2System.Globalization名称空间 
28.2.1Unicode问题 
28.2.2区域性和区域 
28.2.3使用区域性 
28.2.4排序 
28.3资源 
28.3.1创建资源文件 
28.3.2资源文件生成器 
28.3.3ResourceWriter 
28.3.4使用资源文件 
28.3.5System.Resources名称空间 
28.4使用VisualStudio的WindowsForms本地化 
28.4.1通过编程方式修改区域性 
28.4.2使用自定义资源消息 
28.4.3资源的自动回退 
28.4.4外包翻译 
28.5ASP.NETWebForms的本地化 
28.6用WPF本地化 
28.6.1用于WPF的.NET资源 
28.6.2XAML资源字典 
28.7自定义资源读取器 
28.7.1创建DatabaseResource—Reader类 
28.7.2创建DatabaseResource—Set类 
28.7.3创建DatabaseResource—Manager类 
28.7.4DatabaseResourceReader的客户端应用程序 
28.8创建自定义区域性 
28.9用WindowsStore应用程序进行本地化 
28.9.1使用资源 
28.9.2使用多语言应用程序工具集进行本地化 
28.10小结 
第29章核心XAML 
29.1XAML的作用 
29.2概述 
29.2.1元素如何映射到.NET对象上 
29.2.2使用自定义.NET类 
29.2.3把属性用作特性 
29.2.4把属性用作元素 
29.2.5基本的.NET类型 
29.2.6使用集合和XAML 
29.2.7用XAML代码调用构造函数 
29.3依赖属性 
29.3.1创建依赖属性 
29.3.2强制值回调 
29.3.3值变更回调和事件 
29.3.4事件的冒泡和隧道 
29.4附加属性 
29.5标记扩展 
29.6创建自定义标记扩展 
29.7XAML定义的标记扩展 
29.8读写XAML 
29.9小结 
第30章ManagedExtensibilityFramework 
30.1概述 
30.2MEF的体系结构 
30.2.1使用属性的MEF 
30.2.2基于约定的部件注册 
30.3定义协定 
30.4导出部件 
30.4.1创建部件 
30.4.2导出属性和方法 
30.4.3导出元数据 
30.4.4使用元数据进行惰性加载 
30.5导入部件 
30.5.1导入连接 
30.5.2部件的惰性加载 
30.5.3用惰性实例化的部件读取元数据 
30.6容器和出口提供程序 
30.7类别 
30.8小结 

第31章Windows运行库 

31.1概述 
31.1.1.NET与Windows运行库的比较 
31.1.2名称空间 
31.1.3元数据 
31.1.4语言投射 
31.1.5Windows运行库中的类型 

31.2Windows运行库组件 
31.2.1集合 
31.2.2流 
31.2.3委托与事件 
31.2.4异步操作 

31.3Windows8应用程序 

31.4Windows8应用程序的生命周期 
31.4.1Windows8应用程序的执行状态 
31.4.2SuspensionManager 
31.4.3导航状态 
31.4.4测试暂停 
31.4.5页面状态 

31.5Windows8应用程序的设置 

31.6摄像头功能 
31.7小结 


第Ⅳ部分数据 

第32章核心ADO.NET 
32.1ADO.NET概述 
32.1.1名称空间 
32.1.2共享类 
32.1.3数据库专用类 
32.2使用数据库连接 
32.2.1管理连接字符串 
32.2.2高效地使用连接 
32.2.3事务 
32.3命令 
32.3.1执行命令 
32.3.2调用存储过程 
32.4快速数据访问：数据读取器 
32.5异步数据访问：使用Task和await 
32.6管理数据和关系：DataSet类 
32.6.1数据表 
32.6.2数据列 
32.6.3数据关系 
32.6.4数据约束 
32.7XML架构：用XSD生成代码 
32.8填充DataSet类 
32.8.1用数据适配器填充DataSet 
32.8.2从XML中填充DataSet类 
32.9持久化DataSet类的修改 
32.9.1通过数据适配器进行更新 
32.9.2写入XML输出结果 
32.10使用ADO.NET 
32.10.1分层开发 
32.10.2生成SQLServer的键 
32.10.3命名约定 
32.11小结 

第33章ADO.NETEntityFramework 
33.1用EntityFramework编程 
33.2EntityFramework映射 
33.2.1逻辑层 
33.2.2概念层 
33.2.3映射层 
33.2.4连接字符串 
33.3实体 
33.4对象上下文 
33.5关系 
33.5.1一个层次结构一个表 
33.5.2一种类型一个表 
33.5.3懒惰加载、延迟加载和预先加载 
33.6查询数据 
33.6.1EntitySQL 
33.6.2对象查询 
33.6.3LINQtoEntities 
33.7把数据写入数据库 
33.7.1对象跟踪 
33.7.2改变信息 
33.7.3附加和分离实体 
33.7.4存储实体的变化 
33.8使用POCO对象 
33.8.1定义实体类型 
33.8.2创建数据上下文 
33.8.3查询和更新 
33.9使用CodeFirst编程模型 
33.9.1定义实体类型 
33.9.2创建数据上下文 
33.9.3创建数据库，存储实体 
33.9.4数据库 
33.9.5查询数据 
33.9.6定制数据库的生成 
33.10小结 

第34章处理XML 
34.1XML 
34.2.NET支持的XML标准 
34.3System.Xml名称空间 
34.4使用System.Xml类 
34.5读写流格式的XML 
34.5.1使用XmlReader类 
34.5.2使用XmlReader类进行验证 
34.5.3使用XmlWriter类 
34.6在.NET中使用DOM 
34.7使用XPathNavigator类 
34.7.1System.Xml.XPath名称空间 
34.7.2System.Xml.Xsl名称空间 
34.7.3调试XSLT 
34.8XML和ADO.NET 
34.8.1将ADO.NET数据转换为XML文档 
34.8.2把XML文档转换为ADO.NET数据 
34.9在XML中序列化对象 
34.10LINQtoXML和.NET 
34.11使用不同的XML对象 
34.11.1XDocument对象 
34.11.2XElement对象 
34.11.3XNamespace对象 
34.11.4XComment对象 
34.11.5XAttribute对象 
34.12使用LINQ查询XML文档 
34.12.1查询静态的XML文档 
34.12.2查询动态的XML文档 
34.13XML文档的更多查询技术 
34.13.1读取XML文档 
34.13.2写入XML文档 
34.14小结 


第Ⅴ部分显示 

第35章核心WPF 
35.1理解WPF 
35.1.1名称空间 
35.1.2类层次结构 
35.2形状 
35.3几何图形 
35.4变换 
35.5画笔 
35.5.1SolidColorBrush 
35.5.2LinearGradientBrush 
35.5.3RadialGradientBrush 
35.5.4DrawingBrush 
35.5.5ImageBrush 
35.5.6VisualBrush 
35.6控件 
35.6.1简单控件 
35.6.2内容控件 
35.6.3带标题的内容控件 
35.6.4项控件 
35.6.5带标题的项控件 
35.6.6修饰 
35.7布局 
35.7.1StackPanel 
35.7.2WrapPanel 
35.7.3Canvas 
35.7.4DockPanel 
35.7.5Grid 
35.8样式和资源 
35.8.1样式 
35.8.2资源 
35.8.3系统资源 
35.8.4从代码中访问资源 
35.8.5动态资源 
35.8.6资源字典 
35.9触发器 
35.9.1属性触发器 
35.9.2多触发器 
35.9.3数据触发器 
35.10模板 
35.10.1控件模板 
35.10.2数据模板 
35.10.3样式化列表框 
35.10.4ItemTemplate 
35.10.5列表框元素的控件模板 
35.11动画 
35.11.1时间轴 
35.11.2非线性动画 
35.11.3事件触发器 
35.11.4关键帧动画 
35.12可见状态管理器 
35.12.1可见的状态 
35.12.2变换 
35.133—D 
35.13.1模型 
35.13.2照相机 
35.13.3光线 
35.13.4旋转 
35.14小结 

第36章用WPF编写业务 
应用程序 
36.1概述 
36.2菜单和功能区控件 
36.2.1菜单控件 
36.2.2功能区控件 
36.3Commanding 
36.3.1定义命令 
36.3.2定义命令源 
36.3.3命令绑定 
36.4数据绑定 
36.4.1BooksDemo应用程序内容 
36.4.2用XAML绑定 
36.4.3简单对象的绑定 
36.4.4更改通知 
36.4.5对象数据提供程序 
36.4.6列表绑定 
36.4.7主从绑定 
36.4.8多绑定 
36.4.9优先绑定 
36.4.10值的转换 
36.4.11动态添加列表项 
36.4.12动态添加选项卡中的项 
36.4.13数据模板选择器 
36.4.14绑定到XML上 
36.4.15绑定的验证 
36.5TreeView 
36.6DataGrid 
36.6.1自定义列 
36.6.2行的细节 
36.6.3用DataGrid进行分组 
36.6.4实时成型 
36.7小结 

第37章用WPF创建文档 
37.1简介 
37.2文本元素 
37.2.1字体 
37.2.2TextEffect 
37.2.3内联 
37.2.4块 
37.2.5列表 
37.2.6表 
37.2.7块的锚定 
37.3流文档 
37.4固定文档 
37.5XPS文档 
37.6打印 
37.6.1用PrintDialog打印 
37.6.2打印可见元素 
37.7小结 

第38章Windows8应用程序 
38.1概述 
38.2Windows8的现代UI设计 
38.2.1内容，不是chrome设计 
38.2.2快速流畅 
38.2.3可读性 
38.3示例应用程序的核心功能 
38.3.1文件和目录 
38.3.2应用程序数据 
38.3.3应用程序页面 
38.4应用程序工具栏 
38.5启动与导航 
38.6布局的变化 
38.7存储 
38.7.1定义数据协定 
38.7.2写入移动数据 
38.7.3读取数据 
38.7.4写入图像 
38.7.5读取图像 
38.8选择器 
38.9共享协定 
38.9.1共享源 
38.9.2共享目标 
38.10Tile 
38.11小结 

第39章核心ASP.NET 
39.1用于Web应用程序的.NETFramework 
39.1.1ASP.NETWebForms 
39.1.2ASP.NETWebPages 
39.1.3ASP.NETMVC 
39.2Web技术 
39.2.1HTML 
39.2.2CSS 
39.2.3JavaScript和jQuery 
39.3托管和配置 
39.4处理程序和模块 
39.4.1创建自定义处理程序 
39.4.2ASP.NET处理程序 
39.4.3创建自定义模块 
39.4.4通用模块 
39.5全局的应用程序类 
39.6请求和响应 
39.6.1使用HttpRequest对象 
39.6.2使用HttpResponse对象 
39.7状态管理 
39.7.1视图状态 
39.7.2cookie 
39.7.3会话 
39.7.4应用程序状态 
39.7.5缓存 
39.7.6配置文件 
39.8成员和角色 
39.8.1配置成员 
39.8.2使用成员API 
39.8.3启用角色API 
39.9小结 

第40章ASP.NETWebForms 
40.1概述 
40.2ASPX页面模型 
40.2.1添加控件 
40.2.2使用事件 
40.2.3使用回送 
40.2.4使用自动回送 
40.2.5回送到其他页面 
40.2.6定义强类型化的跨页面回送 
40.2.7使用页面事件 
40.2.8ASPX代码 
40.2.9服务器端控件 
40.3母版页 
40.3.1创建母版页 
40.3.2使用母版页 
40.3.3在内容页中定义母版页内容 
40.4导航 
40.4.1站点地图 
40.4.2Menu控件 
40.4.3菜单路径 
40.5验证用户输入 
40.5.1使用验证控件 
40.5.2使用验证摘要 
40.5.3验证组 
40.6访问数据 
40.6.1使用EntityFramework 
40.6.2使用EntityDataSource 
40.6.3排序和编辑 
40.6.4定制列 
40.6.5在网格中使用模板 
40.6.6定制对象上下文的创建过程 
40.6.7对象数据源 
40.7安全性 
40.7.1启用表单身份验证 
40.7.2登录控件 
40.8Ajax 
40.8.1ASP.NETAJAX的概念 
40.8.2ASP.NETAJAX网站示例 
40.8.3支持ASP.NETAJAX的网站配置 
40.8.4添加ASP.NETAJAX功能 
40.9小结 

第41章ASP.NETMVC 
41.1ASP.NETMVC概述 
41.2定义路由 
41.2.1添加路由 
41.2.2路由约束 
41.3创建控制器 
41.3.1动作方法 
41.3.2参数 
41.3.3返回数据 
41.4创建视图 
41.4.1向视图传递数据 
41.4.2Razor语法 
41.4.3强类型视图 
41.4.4布局 
41.4.5部分视图 
41.5从客户端提交数据 
41.5.1模型绑定器 
41.5.2注释和验证 
41.6HTMLHelper 
41.6.1简单的Helper 
41.6.2使用模型数据 
41.6.3定义HTML特性 
41.6.4创建列表 
41.6.5强类型化的Helper 
41.6.6编辑器扩展 
41.6.7创建自定义Helper 
41.6.8模板 
41.7创建数据驱动的应用程序 
41.7.1定义模型 
41.7.2创建控制器和视图 
41.8动作过滤器 
41.9身份验证和授权 
41.9.1登录模型 
41.9.2登录控制器 
41.9.3登录视图 
41.10ASP.NETWebAPI 
41.10.1使用EntityFrameworkCode—First进行数据访问 
41.10.2为ASP.NETWebAPI定义路由 
41.10.3控制器实现 
41.10.4使用jQuery的客户端应用程序 
41.11小结 

第42章ASP.NET动态数据 
42.1概述 
42.2创建动态数据Web应用程序 
42.2.1配置Scaffolding 
42.2.2查看结果 
42.3定制动态数据网站 
42.3.1控制框架 
42.3.2定制模板 
42.3.3配置路由 
42.4小结 


第Ⅵ部分通信 

第43章WCF 
43.1WCF概述 
43.1.1SOAP 
43.1.2WSDL 
43.1.3REST 
43.1.4JSON 
43.2创建简单的服务和客户端 
43.2.1定义服务和数据协定 
43.2.2数据访问 
43.2.3服务的实现 
43.2.4WCF服务宿主和WCF测试客户端 
43.2.5自定义服务宿主 
43.2.6WCF客户端 
43.2.7诊断 
43.2.8与客户端共享协定程序集 
43.3协定 
43.3.1数据协定 
43.3.2版本问题 
43.3.3服务协定 
43.3.4消息协定 
43.3.5错误协定 
43.4服务的行为 
43.5绑定 
43.5.1标准的绑定 
43.5.2标准绑定的特性 
43.5.3Web套接字 
43.6宿主 
43.6.1自定义宿主 
43.6.2WAS宿主 
43.6.3预配置的宿主类 
43.7客户端 
43.7.1使用元数据 
43.7.2共享类型 
43.8双工通信 
43.8.1双工通信的协定 
43.8.2双工通信的服务 
43.8.3双工通信的客户端应用程序 
43.9路由 
43.9.1示例应用程序 
43.9.2路由接口 
43.9.3WCF路由服务 
43.9.4为失败使用路由器 
43.9.5改变协定的桥梁 
43.9.6过滤器的类型 
43.10小结 

第44章WCF数据服务 
44.1概述 
44.2包含CLR对象的自定义宿主 
44.2.1CLR对象 
44.2.2数据模型 
44.2.3数据服务 
44.2.4驻留服务 
44.2.5其他服务操作 
44.3HTTP客户端应用程序 
44.4使用WCF数据服务和ADO.NETEntityFramework 
44.4.1ASP.NET宿主和EDM 
44.4.2使用WCF数据服务客户库 
44.5小结 

第45章WindowsWF4 
45.1工作流概述 
45.2HelloWorld示例 
45.3活动 
45.3.1If活动 
45.3.2InvokeMethod活动 
45.3.3Parallel活动 
45.3.4Delay活动 
45.3.5Pick活动 
45.4自定义活动 
45.4.1活动的验证 
45.4.2设计器 
45.4.3自定义复合活动 
45.5工作流 
45.5.1实参和变量 
45.5.2WorkflowApplication 
45.5.3存放WCF工作流 
45.5.4工作流的版本 
45.5.5驻留设计器 
45.6小结 

第46章对等网络 
46.1P2P网络概述 
46.1.1客户端—服务器体系结构 
46.1.2P2P体系结构 
46.1.3P2P体系结构的挑战 
46.1.4P2P术语 
46.1.5P2P解决方案 
46.2PNRP 
46.3构建P2P应用程序 
46.4小结 

第47章消息队列 
47.1概述 
47.1.1使用消息队列的场合 
47.1.2消息队列功能 
47.2MessageQueuing产品 
47.3消息队列体系结构 
47.3.1消息 
47.3.2消息队列 
47.4MessageQueuing管理工具 
47.4.1创建消息队列 
47.4.2消息队列属性 
47.5消息队列的编程实现 
47.5.1创建消息队列 
47.5.2查找队列 
47.5.3打开已知队列 
47.5.4发送消息 
47.5.5接收消息 
47.6课程订单应用程序 
47.6.1课程订单类库 
47.6.2课程订单消息发送程序 
47.6.3发送优先级和可恢复的消息 
47.6.4课程订单消息接收应用程序 
47.7接收结果 
47.7.1确认队列 
47.7.2响应队列 
47.8事务队列 
47.9消息队列和WCF 
47.9.1带数据协定的实体类 
47.9.2WCF服务协定 
47.9.3WCF消息接收应用程序 
47.9.4WCF消息发送应用程序 
47.10消息队列的安装 
47.11小结



