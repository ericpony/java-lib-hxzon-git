C++ Primer中文版(第5版)

96.00 (7.5折)

=======
~ 斯坦利·李普曼 (Stanley B. Lippman) (作者), 约瑟·拉乔伊 (Josee Lajoie) (作者), 芭芭拉·默 (Barbara E. Moo) (作者), 王刚 (译者), 杨巨峰 (译者) 

出版社: 电子工业出版社; 第5版 (2013年9月1日)
平装: 848页
语种： 简体中文
开本: 16
ISBN: 9787121155352
条形码: 9787121155352

=========
编辑推荐

C++领域权威 潘爱民|孟岩作序，代表技术圈鼎力推荐
一线C++工程师腾讯Milo、微软刘未鹏|陈梓瀚、阿里李云|侯凤林高水准技术审校
如果只读一本C++书籍，相信所有读过的人都会毫不犹豫选择本书，无论初学或老手
既可用来理解C++11规则背后的原理，也可用其新语言特性与标准库来快速构建健壮程序
采用中文版页码全面呈现原书大量交叉引用及详尽索引，新式辅学设置与课后操练用于避开陷阱、巩固良法


媒体推荐

这本CP5完全可以当做参考书或者字典来用，在语法上遇到什么问题或者编译有问题都可以再这本书里找答案，
CP4是非常权威的，毕竟Lippman大大是第一个C++编译器的实现者之一。

这本书的写作方式实在适合国人。
他没有中国作家普遍的“讲概念”式的写作手法，而是从因到果，由浅入深，由表及里娓娓道来，从语言的简单用法，
到为什么这样设计语言，你不仅能从一个语言使用者的角度看问题，更能站在一个语言设计者的角度思考这种语言的设计优劣。

这是本非常经典的C++书籍，系统全面地介绍了C++语言。
本书近一千页，可以看成是学习C++的百科全书。
市面上没有哪本其他书籍比本书论述得更广泛，几乎所有的C++知识点本书都有论述而且写得还不错。
因为这点，这本书值得每一位C++程序员拥有。

针对C++11而新添加到书中的内容恰到好处地定义了这个新版本。
作者在新版本中给出了清晰的阐述，如自动类型、decltype、列表初始化器、右值引用、move操作符、lambda表达式、智能指针等。
仅针对C++11的延展，正是这本书的价值所在。

C++是一门强大、难学、令人痛苦，但又是如此美妙的编程语言，在工业界和学术界都可以使用，
《C++ Primer（第5版）》即针对初学者，也同样适用于有一定编程经验的读者，
最新版本配备了C++11最新标准，是C++粉丝们书架上必备的一本经典著作。


作者简介

Stanley B. Lippman目前是微软公司 Visual C++ 团队的架构师。
他从1984年开始在贝尔实验室与C++的设计者Bjarne Stroustrup一起从事C++的设计与开发。
他在迪士尼和梦工厂从事动画制作，还担任过JPL的高级顾问。

Josée Lajoie曾经是IBM加拿大研究中心C/C++编译器开发团队的成员，在ISO C++标准委员会工作了7年，担任过ISO核心语言工作组的主席和C++ Report杂志的专栏作家。

Barbara E. Moo是拥有25年软件经验的独立咨询顾问。
在AT&T，她与Stroustrup、Lippman一起管理过复杂的C++开发项目。

=========
目录

第1章 开始 1

第Ⅰ部分 C++基础 27
第2章 变量和基本类型 29
第3章 字符串、向量和数组 73
第4章 表达式 119
第5章 语句 153
第6章 函数 181
第7章 类 227

第Ⅱ部 C++标准库 275
第8章 IO库 277
第9章 顺序容器 291
第10章 泛型算法 335
第11章 关联容器 373
第12章 动态内存 399

第Ⅲ部分 类设计者的工具 437
第13章 拷贝控制 439
第14章 操作重载与类型转换 489
第15章 面向对象程序设计 525
第16章 模板与泛型编程 577

第Ⅳ部分 高级主题 633
第17章 标准库特殊设施 635
第18章 用于大型程序的工具 683
第19章 特殊工具与技术 725

附录A 标准库 765


========
目录


第1章 开始 1

1.1 编写一个简单的C++程序 2
1.1.1 编译、运行程序 3
1.2 初识输入输出 5
1.3 注释简介 8
1.4 控制流 10
1.4.1 while语句 10
1.4.2 for语句 11
1.4.3 读取数量不定的输入数据 13
1.4.4 if语句 15
1.5 类简介 17
1.5.1 Sales_item类 17
1.5.2 初识成员函数 20
1.6 书店程序 21
小结 23
术语表 23



第Ⅰ部分 C++基础 27

第2章 变量和基本类型 29

2.1 基本内置类型 30
2.1.1 算术类型 30
2.1.2 类型转换 32
2.1.3 字面值常量 35

2.2 变量 38
2.2.1 变量定义 38
2.2.2 变量声明和定义的关系 41
2.2.3 标识符 42
2.2.4 名字的作用域 43

2.3 复合类型 45
2.3.1 引用 45
2.3.2 指针 47
2.3.3 理解复合类型的声明 51

2.4 const限定符 53
2.4.1 const的引用 54
2.4.2 指针和const 56
2.4.3 顶层const 57
2.4.4 constexpr和常量表达式 58

2.5 处理类型 60
2.5.1 类型别名 60
2.5.2 auto类型说明符 61
2.5.3 decltype类型指示符 62

2.6 自定义数据结构 64
2.6.1 定义Sales_data类型 64
2.6.2 使用Sales_data类 66
2.6.3 编写自己的头文件 67
小结 69
术语表 69

第3章 字符串、向量和数组 73

3.1 命名空间的using声明 74

3.2 标准库类型string 75
3.2.1 定义和初始化string对象 76
3.2.2 string对象上的操作 77
3.2.3 处理string对象中的字符 81

3.3 标准库类型vector 86
3.3.1 定义和初始化vector对象 87
3.3.2 向vector对象中添加元素 90
3.3.3 其他vector操作 91

3.4 迭代器介绍 95
3.4.1 使用迭代器 95
3.4.2 迭代器运算 99

3.5 数组 101
3.5.1 定义和初始化内置数组 101
3.5.2 访问数组元素 103
3.5.3 指针和数组 105
3.5.4 C风格字符串 109
3.5.5 与旧代码的接口 111

3.6 多维数组 112
小结 117
术语表 117

第4章 表达式 119

4.1 基础 120
4.1.1 基本概念 120
4.1.2 优先级与结合律 121
4.1.3 求值顺序 123

4.2 算术运算符 124
4.3 逻辑和关系运算符 126
4.4 赋值运算符 129
4.5 递增和递减运算符 131
4.6 成员访问运算符 133
4.7 条件运算符 134
4.8 位运算符 135
4.9 sizeof运算符 139
4.10 逗号运算符 140

4.11 类型转换 141
4.11.1 算术转换 142
4.11.2 其他隐式类型转换 143
4.11.3 显式转换 144
4.12 运算符优先级表 147
小结 149
术语表 149

第5章 语句 153

5.1 简单语句 154
5.2 语句作用域 155

5.3 条件语句 156
5.3.1 if语句 156
5.3.2 switch语句 159

5.4 迭代语句 165
5.4.1 while语句 165
5.4.2 传统的for语句 166
5.4.3 范围for语句 168
5.4.4 do while语句 169

5.5 跳转语句 170
5.5.1 break语句 170
5.5.2 continue语句 171
5.5.3 goto语句 172

5.6 TRY语句块和异常处理 172
5.6.1 throw表达式 173
5.6.2 try语句块 174
5.6.3 标准异常 176
小结 178
术语表 178

第6章 函数 181

6.1 函数基础 182
6.1.1 局部对象 184
6.1.2 函数声明 186
6.1.3 分离式编译 186

6.2 参数传递 187
6.2.1 传值参数 187
6.2.2 传引用参数 188
6.2.3 const形参和实参 190
6.2.4 数组形参 193
6.2.5 main：处理命令行选项 196
6.2.6 含有可变形参的函数 197

6.3 返回类型和return语句 199
6.3.1 无返回值函数 200
6.3.2 有返回值函数 200
6.3.3 返回数组指针 205

6.4 函数重载 206
6.4.1 重载与作用域 210

6.5 特殊用途语言特性 211
6.5.1 默认实参 211
6.5.2 内联函数和constexpr函数 213
6.5.3 调试帮助 215

6.6 函数匹配 217
6.6.1 实参类型转换 219
6.7 函数指针 221
小结 225
术语表 225

第7章 类 227

7.1 定义抽象数据类型 228
7.1.1 设计Sales_data类 228
7.1.2 定义改进的Sales_data类 230
7.1.3 定义类相关的非成员函数 234
7.1.4 构造函数 235
7.1.5 拷贝、赋值和析构 239

7.2 访问控制与封装 240
7.2.1 友元 241

7.3 类的其他特性 243
7.3.1 类成员再探 243
7.3.2 返回*this的成员函数 246
7.3.3 类类型 249
7.3.4 友元再探 250

7.4 类的作用域 253
7.4.1 名字查找与类的作用域 254

7.5 构造函数再探 257
7.5.1 构造函数初始值列表 258
7.5.2 委托构造函数 261
7.5.3 默认构造函数的作用 262
7.5.4 隐式的类类型转换 263
7.5.5 聚合类 266
7.5.6 字面值常量类 267

7.6 类的静态成员 268
小结 273
术语表 273



第Ⅱ部 C++标准库 275

第8章 IO库 277

8.1 IO类 278
8.1.1 IO对象无拷贝或赋值 279
8.1.2 条件状态 279
8.1.3 管理输出缓冲 281

8.2 文件输入输出 283
8.2.1 使用文件流对象 284
8.2.2 文件模式 286

8.3 string流 287
8.3.1 使用istringstream 287
8.3.2 使用ostringstream 289
小结 290
术语表 290

第9章 顺序容器 291

9.1 顺序容器概述 292

9.2 容器库概览 294
9.2.1 迭代器 296
9.2.2 容器类型成员 297
9.2.3 begin和end成员 298
9.2.4 容器定义和初始化 299
9.2.5 赋值和swap 302
9.2.6 容器大小操作 304
9.2.7 关系运算符 304

9.3 顺序容器操作 305
9.3.1 向顺序容器添加元素 305
9.3.2 访问元素 309
9.3.3 删除元素 311
9.3.4 特殊的forward_list操作 312
9.3.5 改变容器大小 314
9.3.6 容器操作可能使迭代器失效 315

9.4 vector对象是如何增长的 317

9.5 额外的string操作 320
9.5.1 构造string的其他方法 321
9.5.2 改变string的其他方法 322
9.5.3 string搜索操作 325
9.5.4 compare函数 327
9.5.5 数值转换 327

9.6 容器适配器 329
小结 332
术语表 332

第10章 泛型算法 335

10.1 概述 336

10.2 初识泛型算法 338
10.2.1 只读算法 338
10.2.2 写容器元素的算法 339
10.2.3 重排容器元素的算法 342

10.3 定制操作 344
10.3.1 向算法传递函数 344
10.3.2 lambda表达式 345
10.3.3 lambda捕获和返回 349
10.3.4 参数绑定 354

10.4 再探迭代器 357
10.4.1 插入迭代器 358
10.4.2 iostream迭代器 359
10.4.3 反向迭代器 363

10.5 泛型算法结构 365
10.5.1 5类迭代器 365
10.5.2 算法形参模式 367
10.5.3 算法命名规范 368

10.6 特定容器算法 369
小结 371
术语表 371

第11章 关联容器 373

11.1 使用关联容器 374

11.2 关联容器概述 376
11.2.1 定义关联容器 376
11.2.2 关键字类型的要求 378
11.2.3 pair类型 379

11.3 关联容器操作 381
11.3.1 关联容器迭代器 382
11.3.2 添加元素 383
11.3.3 删除元素 386
11.3.4 map的下标操作 387
11.3.5 访问元素 388
11.3.6 一个单词转换的map 391

11.4 无序容器 394
小结 397
术语表 397

第12章 动态内存 399

12.1 动态内存与智能指针 400
12.1.1 shared_ptr类 400
12.1.2 直接管理内存 407
12.1.3 shared_ptr和new结合使用 412
12.1.4 智能指针和异常 415
12.1.5 unique_ptr 417
12.1.6 weak_ptr 420

12.2 动态数组 423
12.2.1 new和数组 423
12.2.2 allocator类 427

12.3 使用标准库：文本查询程序 430
12.3.1 文本查询程序设计 430
12.3.2 文本查询程序类的定义 432
小结 436
术语表 436



第Ⅲ部分 类设计者的工具 437

第13章 拷贝控制 439

13.1 拷贝、赋值与销毁 440
13.1.1 拷贝构造函数 440
13.1.2 拷贝赋值运算符 443
13.1.3 析构函数 444
13.1.4 三/五法则 447
13.1.5 使用=default 449
13.1.6 阻止拷贝 449

13.2 拷贝控制和资源管理 452
13.2.1 行为像值的类 453
13.2.2 定义行为像指针的类 455

13.3 交换操作 457
13.4 拷贝控制示例 460
13.5 动态内存管理类 464

13.6 对象移动 470
13.6.1 右值引用 471
13.6.2 移动构造函数和移动赋值运算符 473
13.6.3 右值引用和成员函数 481
小结 486
术语表 486

第14章 操作重载与类型转换 489

14.1 基本概念 490

14.2 输入和输出运算符 494
14.2.1 重载输出运算符<< 494
14.2.2 重载输入运算符>> 495

14.3 算术和关系运算符 497
14.3.1 相等运算符 497
14.3.2 关系运算符 498

14.4 赋值运算符 499
14.5 下标运算符 501
14.6 递增和递减运算符 502
14.7 成员访问运算符 504

14.8 函数调用运算符 506
14.8.1 lambda是函数对象 507
14.8.2 标准库定义的函数对象 509
14.8.3 可调用对象与function 511

14.9 重载、类型转换与运算符 514
14.9.1 类型转换运算符 514
14.9.2 避免有二义性的类型转换 517
14.9.3 函数匹配与重载运算符 521
小结 523
术语表 523

第15章 面向对象程序设计 525

15.1 OOP：概述 526

15.2 定义基类和派生类 527
15.2.1 定义基类 528
15.2.2 定义派生类 529
15.2.3 类型转换与继承 534

15.3 虚函数 536
15.4 抽象基类 540
15.5 访问控制与继承 542
15.6 继承中的类作用域 547

15.7 构造函数与拷贝控制 551
15.7.1 虚析构函数 552
15.7.2 合成拷贝控制与继承 552
15.7.3 派生类的拷贝控制成员 554
15.7.4 继承的构造函数 557

15.8 容器与继承 558
15.8.1 编写Basket类 559

15.9 文本查询程序再探 562
15.9.1 面向对象的解决方案 563
15.9.2 Query_base类和Query类 567
15.9.3 派生类 568
15.9.4 eval函数 571
小结 575
术语表 575

第16章 模板与泛型编程 577

16.1 定义模板 578
16.1.1 函数模板 578
16.1.2 类模板 583
16.1.3 模板参数 592
16.1.4 成员模板 595
16.1.5 控制实例化 597
16.1.6 效率与灵活性 599

16.2 模板实参推断 600
16.2.1 类型转换与模板类型参数 601
16.2.2 函数模板显式实参 603
16.2.3 尾置返回类型与类型转换 604
16.2.4 函数指针和实参推断 607
16.2.5 模板实参推断和引用 608
16.2.6 理解std::move 610
16.2.7 转发 612

16.3 重载与模板 614

16.4 可变参数模板 618
16.4.1 编写可变参数函数模板 620
16.4.2 包扩展 621
16.4.3 转发参数包 622

16.5 模板特例化 624
小结 630
术语表 630



第Ⅳ部分 高级主题 633

第17章 标准库特殊设施 635

17.1 tuple类型 636
17.1.1 定义和初始化tuple 637
17.1.2 使用tuple返回多个值 638

17.2 BITSET类型 640
17.2.1 定义和初始化bitset 641
17.2.2 bitset操作 643

17.3 正则表达式 645
17.3.1 使用正则表达式库 646
17.3.2 匹配与Regex迭代器类型 650
17.3.3 使用子表达式 653
17.3.4 使用regex_replace 657

17.4 随机数 659
17.4.2 其他随机数分布 663
bernoulli_distribution类 665

17.5 IO库再探 666
17.5.1 格式化输入与输出 666
17.5.2 未格式化的输入/输出操作 673
17.5.3 流随机访问 676
小结 680
术语表 680

第18章 用于大型程序的工具 683

18.1 异常处理 684
18.1.1 抛出异常 684
18.1.2 捕获异常 687
18.1.3 函数try语句块与构造函数 689
18.1.4 noexcept异常说明 690
18.1.5 异常类层次 693

18.2 命名空间 695
18.2.1 命名空间定义 695
18.2.2 使用命名空间成员 701
18.2.3 类、命名空间与作用域 705
18.2.4 重载与命名空间 708

18.3 多重继承与虚继承 710
18.3.1 多重继承 711
18.3.2 类型转换与多个基类 713
18.3.3 多重继承下的类作用域 715
18.3.4 虚继承 717
18.3.5 构造函数与虚继承 720
小结 722
术语表 722

第19章 特殊工具与技术 725

19.1 控制内存分配 726
19.1.1 重载new和delete 726
19.1.2 定位new表达式 729

19.2 运行时类型识别 730
19.2.1 dynamic_cast运算符 730
19.2.2 typeid运算符 732
19.2.3 使用RTTI 733
19.2.4 type_info类 735

19.3 枚举类型 736

19.4 类成员指针 739
19.4.1 数据成员指针 740
19.4.2 成员函数指针 741
19.4.3 将成员函数用作可调用对象 744

19.5 嵌套类 746
19.6 union：一种节省空间的类 749
19.7 局部类 754

19.8 固有的不可移植的特性 755
19.8.1 位域 756
19.8.2 volatile限定符 757
19.8.3 链接指示：extern "C" 758
小结 762
术语表 762



附录A 标准库 765

A.1 标准库名字和头文件 766

A.2 算法概览 770
A.2.1 查找对象的算法 771
A.2.2 其他只读算法 772
A.2.3 二分搜索算法 772
A.2.4 写容器元素的算法 773
A.2.5 划分与排序算法 775
A.2.6 通用重排操作 776
A.2.7 排列算法 778
A.2.8 有序序列的集合算法 778
A.2.9 最小值和最大值 779
A.2.10 数值算法 780

A.3 随机数 781
A.3.1 随机数分布 781
A.3.2 随机数引擎 783


C++11的新特性

2.1.1 long long类型 31
2.2.1 列表初始化 39
2.3.2 nullptr常量 48
2.4.4 constexpr变量 59
2.5.1 类型别名声明 60
2.5.2 auto类型指示符 61
2.5.3 decltype类型指示符 62
2.6.1 类内初始化 65

3.2.2 使用auto或decltype缩写类型 79
3.2.3 范围for语句 82
3.3 定义vector对象的vector（向量的向量） 87
3.3.1 vector对象的列表初始化 88
3.4.1 容器的cbegin和cend函数 98
3.5.3 标准库begin和end函数 106
3.6 使用auto和decltype简化声明 115

4.2 除法的舍入规则 125
4.4 用大括号包围的值列表赋值 129
4.9 将sizeof用于类成员 139

5.4.3 范围for语句 168

6.2.6 标准库initializer_list类 197
6.3.2 列表初始化返回值 203
6.3.3 定义尾置返回类型 206
6.3.3 使用decltype简化返回类型定义 
6.5.2 constexpr函数 214

7.1.4 使用=default生成默认构造函数 237
7.3.1 类对象成员的类内初始化 246
7.5.2 委托构造函数 261
7.5.6 constexpr构造函数 268

8.2.1 用string对象处理文件名 284

9.1 array和forward_list容器 293
9.2.3 容器的cbegin和cend函数 298
9.2.4 容器的列表初始化 300
9.2.5 容器的非成员函数swap 303
9.3.1 容器insert成员的返回类型 308
9.3.1 容器的emplace成员的返回类型 308
9.4 shrink_to_fit 318
9.5.5 string的数值转换函数 327

10.3.2 Lambda表达式 346
10.3.3 Lambda表达式中的尾置返回类型 353
10.3.4 标准库bind函数 354

11.2.1 关联容器的列表初始化 377
11.2.3 列表初始化pair的返回类型 380
11.3.2 pair的列表初始化 384
11.4 无序容器 394

12.1 智能指针 400
12.1.1 shared_ptr类 
12.1.2 动态分配对象的列表初始化 407
12.1.2 auto和动态分配 408
12.1.5 unique_ptr类 417
12.1.6 weak_ptr类 420
12.2.1 范围for语句不能应用于动态分配数组 424
12.2.1 动态分配数组的列表初始化 424
12.2.1 auto不能用于分配数组 424
12.2.2 allocator::construct可使用任意构造函数 428

13.1.5 将=default用于拷贝控制成员 449
13.1.6 使用=default阻止拷贝类对象 449
13.5 用移动类对象代替拷贝类对象 469
13.6.1 右值引用 471
13.6.1 标准库move函数 472
13.6.2 移动构造函数和移动赋值 473
13.6.2 移动构造函数通常应该是noexcept 473
13.6.2 移动迭代器 480
13.6.3 引用限定成员函数 483

14.8.3 function类模板 512
14.9.1 explicit类型转换运算符 516

15.2.2 虚函数的override指示符 530
15.2.2 通过定义类为final来阻止继承 533
15.3 虚函数的override和final指示符 538
15.7.2 删除的拷贝控制和继承 553
15.7.4 继承的构造函数 557

16.1.2 声明模板类型形参为友元 590
16.1.2 模板类型别名 590
16.1.3 模板函数的默认模板参数 594
16.1.5 实例化的显式控制 597
16.2.3 模板函数与尾置返回类型 605
16.2.5 引用折叠规则 609
16.2.6 用static_cast将左值转换为右值 612
16.2.7 标准库forward函数 614
16.4 可变参数模板 618
16.4 sizeof...运算符 619
16.4.3 可变参数模板与转发 622

17.1 标准库Tuple类模板 636
17.2.2 新的bitset运算 643
17.3 正则表达式库 645
17.4 随机数库 659
17.5.1 浮点数格式控制 670

18.1.4 noexcept异常指示符 690
18.1.4 noexcept运算符 691
18.2.1 内联名字空间 699
18.3.1 继承的构造函数和多重继承 712

19.3 有作用域的enum 736
19.3 说明类型用于保存enum对象 738
19.3 enum的提前声明 738
19.4.3 标准库mem_fn类模板 746
19.6 类类型的联合成员 751

==========
序言

难以计数的程序员已经通过旧版的《C++ Primer》学会了C++语言。
而在这段时间中，C++本身又已成熟了许多：
语言本身的关注点和程序设计社区的关注点都已大大开阔，已经从主要关注机器效率转变为更多地关注编程效率。

2011年，C++标准委员会发布了ISO C++标准的一个重要修订版。
此修订版是C++进化过程中的最新一步，延续了前几个版本对编程效率的强调。

新标准的主要目标是：
使语言更为统一，更易于教学
使标准库更简单、安全、使用更高效
使编写高效率的抽象和库变得更简单

因此，在这个版本的《C++ Primer》中，我们进行了彻底的修改，使用了最新的C++标准，即C++11。
为了了解新标准是如何全面影响C++语言的，你可以看一下xxiii页至xxv页的新特性列表，其中列出了哪些章节涉及了C++的新特性。

新标准增加的一些特性是具有普适性的，例如用于类型推断的auto。
这些新特性使本书中的代码更易于阅读和理解。
程序（以及程序员！）可以忽略类型的细节，从而更容易集中精力于程序逻辑上来。
其他一些新特性，例如智能指针和允许移动的容器，允许我们编写更为复杂的类，而又不必与错综复杂的资源管理做斗争。
因此，在本书中开始讲授如何编写自己的类，会比第4版简单得多。
旧标准中阻挡在我们前进路上的很多细节，你我都不必再担心了。

对于本书中涉及新标准定义的新特性的那些部分，我们都已用一个特殊的图标标记出来了。
我们希望这些提示标记对那些已经熟悉C++语言核心内容的读者是有帮助的，可以帮助他们决定将注意力投向哪里。
对于那些可能尚不支持所有新特性的编译器，我们还希望这些图标能有助于解释这类编译器所给出的编译错误信息。
这是因为虽然本书中几乎所有例子都已经用最新版本的GNU编译器编译通过，但我们知道一些读者可能尚未将编译器更新到最新版本。
虽然新标准增加了大量新功能，但核心C++语言并未变化，这构成了本书的大部分内容。
读者可以借助这些图标来判断哪些功能可能还没有被自己的编译器所支持。


为什么选择这本书？

现代C++语言可以看作是三部分组成的：

低级语言，大部分继承自C语言。
现代高级语言特性，允许我们定义自己的类型以及组织大规模程序和系统。
标准库，它利用高级特性来提供有用的数据结构和算法。


大多数C++教材按照语言进化的顺序来组织其内容。
首先讲授C++的C子集，然后将C++的更为抽象的一些特性作为高级话题在书的最后进行介绍。
这种方式存在两个问题：
读者会陷入那些继承自低级程序设计的细节，从而由于挫折感而放弃；
读者被强加学习一些坏习惯，随后又需要忘记这些内容。

我们采用一种相反的方法：
从一开始就介绍一些语言特性，能让程序员忽略那些继承自低级程序设计的细节。
例如，在介绍和使用内置的算术和数组类型时，我们还连同介绍和使用标准库中的类型string和vector。
使用这些类型的程序更易写、易理解且更少出错。

太多时候，标准库被当作一种“高级”话题来讲授。
很多教材不使用标准库，而是使用基于字符数组指针和动态内存管理的低级程序设计技术。
让使用这种低级技术的程序正确运行，要比编写相应的使用标准库的C++代码困难得多。

贯穿全书，我们都在强调好的风格：
我们想帮助读者直接养成好的习惯，而不是在获得很多很复杂的知识后再去忘掉那些坏习惯。
我们特别强调那些棘手的问题，并对常见的错误想法和陷阱提出警告。

我们还注意解释规则背后的基本原理——使读者不仅知其然，还能知其所以然。
我们相信，通过体会程序的工作原理，读者会更快地巩固对语言的理解。

虽然你不必为了学习本书而掌握C语言，但我们还是假定你了解足够多的程序设计知识，了解至少一门现代分程序结构语言，
知道如何用这门语言编写、编译以及运行程序。
特别是，我们假定你已经使用过变量，编写、调用过函数，也使用过编译器。


第5版变化的内容

这一版《C++ Primer》的新特点是用边栏图标来帮助引导读者。
C++是一种庞大的编程语言，它提供了一些为特定程序设计问题定制的功能。
其中一些功能对大型项目团队有很重要的意义，但对于小型项目开发可能并无必要。
因此，并非每个程序员都需要了解每个语言特性的所有细节。
我们加入这些边栏图标来帮助读者弄清哪些内容可以随后再学习，而哪些主题是更为重要的。

对于包含C++语言基础内容的章节，我们用一个小人正在读书的图标加以标记。
用这个图标标记的那些章节，涵盖了构成语言核心部分的主题。
每个人都应该阅读并理解这些章节的内容。

对于那些涉及高级主题或特殊目的主题的章节，我们也进行了标记。
在首次阅读时，这些章节可以跳过或快速浏览。
我们用一叠书的图标标记这些章节，指出在这些地方，你可以放心地放下书本。
快速浏览这些章节可能是一个好主意，这样你就可以知道有这些特性存在。
但在真正需要在自己的程序中使用这些特性之前，没有必要花费时间仔细学习这些主题。

为了进一步引导读者的注意力，我们还用放大镜图标标记了特别复杂的概念。
我们希望读者对有这种标记的章节能多花费一些时间彻底理解其中的内容。
在这些章节中，至少有一些，其主题的重要性可能不是那么明显；
但我们认为，你会发现这些章节涉及的主题对理解C++语言原来至关重要。

交叉引用的广泛使用，是本书采用的另外一种阅读帮助。
我们希望这些引用能帮助读者容易地翻阅书中的内容，同时还能在后面的例子涉及到前面的内容时容易地跳回到前面。

没有改变的是，《C++ Primer》仍是一本清晰、正确、全面的C++入门教材。
我们通过给出一系列复杂度逐步增加的例子来讲授这门语言，这些例子说明了语言特性，展示了如何充分用好C++语言。

本书的结构

我们首先在第I部分和第II部分中介绍了C++语言和标准库的基础内容。
这两部分包含的内容足够你编写出有意义的程序，而不是只能写一些玩具程序。
大部分程序员基本上都需要掌握本书这两部分所包含的所有内容。

除了讲授C++的基础内容，第I部分和第II部分还有另外一个重要目的：
通过使用标准库中定义的抽象设施，使你更加适应高级程序设计技术。
标准库设施本身是一组抽象数据类型，通常用C++编写。
用来设计标准库的，就是任何C++程序员都可以使用的用来构造类的那些语言特性。

我们讲授C++语言的一个经验是，在先学习了使用设计良好的抽象类型后，读者会发现理解如何构造自己的类型更容易了。

只有在经过全面的标准库使用训练，并编写了各种标准库所支持的抽象程序后，我们才真正进入到那些允许你编写自己的抽象类型的C++特性中去。

本书的第III部分和第IV部分介绍了如何编写类的形式的抽象类型。
第III部分包含基础内容，第IV部分介绍更专门的语言特性。

在第III部分中，我们将介绍拷贝控制问题，以及其他一些使类能像内置类型一样容易使用的技术。
类是面向对象编程和泛型编程的基础，第III部分也会介绍这些内容。
第IV部分是《C++ Primer》的结束部分，它介绍了一些在组织大型复杂系统时非常有用的语言特性。
此外，我们将在附录A中总结标准库算法。


读者帮助

本书的每一章均以一个总结和一个术语表结束，两者一起扼要回顾了这一章的大部分学习重点。
读者应该将这些部分作为个人备忘录：如果你不理解某个术语，可以重新学习这一章的相应部分。

在本书中我们还使用了其他一些学习辅助：
重要的术语用黑体显示；我们假定读者已经熟悉的重要术语用楷体显示。每个术语都会列在章末尾的术语表中。
贯穿全书，我们用高亮显示来提醒读者注意语言的重要部分，对常见的陷阱提出警告，建议好的程序设计习惯，以及提供一般性的使用提示。
为了更好地理解语言特性间和概念间的联系，我们提供大量向前的和向后的交叉引用。
对重要的概念和C++新程序员常常觉得最困难的主题，我们提供边栏讨论。
学习任何程序设计语言都需要编写程序。为此，贯穿全书我们提供大量程序示例。扩展示例的源码可从下面的网址获得：http://www.informit.com/title/0321714113
正文中切口处以“ ”形式标注的页码为英文原书页码，便于读者与英文原版书进行对照阅读。


关于编译器的注意事项

在撰写本书时（2012年7月），编译器提供商正在努力工作，升级编译器以匹配最新的ISO标准。
我们使用最多的编译器是GNU编译器4.7.0。
本书中只有一小部分特性在此编译器中尚未实现：继承构造函数、成员函数的引用限定符以及正则表达式库。

致谢

我们要特别感谢标准委员会几位现任和前任委员：Dave Abrahams、Andy Koenig、Stephan T. Lavavej、Jason Merrill、John Spicer和Herb Sutter
在准备本书的过程中提供的帮助。在理解新标准的一些更微妙之处，他们为我们提供了宝贵的帮助。
我们还要感谢很多致力于升级GNU编译器以实现新标准的人们。

与旧版《C++ Primer》中一样，我们要感谢Bjarne Stroustrup不知疲倦地为C++工作以及他和作者长时间的友谊。
我们还要感谢Alex Stepanov的非凡洞察力，催生了标准库核心的容器和算法。
最后，我们要感谢C++标准委员会的所有委员，感谢他们这么多年来在净化、精炼和改进C++语言方面的辛苦工作。
我们衷心感谢审稿人：Marshall Clow、Jon Kalb、Nevin Liber、Dr. C. L. Tondo、Daveed Vandevoorde和Steve Vinoski，
他们建设性的意见帮助我们对全书做出了大大小小的改进。

本书是用Latex及其发行版本中的很多包来进行排版的，我们应该感谢Latex社区成员创造出如此强大的排版工具。

最后，我们要感谢Addison-Wesley公司的优秀员工，他们指导了本书的整个出版过程：
Peter Gordon，我们的编辑，他给了我们动力再次修改C++ Primer；Kim Boedigheimer，保证了一切按计划进行；
Barbara Wood，她在编辑过程中找到了大量编辑错误；还有Elizabeth Ryan，很高兴再次和她共同工作，她指导我们完成了整个设计和生产流程。



=========
文摘

推荐序

C++11标准公布之后，C++社群出现了久违的热情，有人甚至叫出“C++的复兴”。
指望C++回到20世纪90年代中期那样的地位显然是昧于大势的奢望，但是C++经历了这么多年的打磨与起伏，
其在工业界的地位已经非常稳固，在很多领域里已经是不可取代也没必要被取代的统治者。

新标准的出现能够大大提升C++开发的效率和质量，因此赢得欢呼也是情理之中。
在这种氛围之下，编译器实现的速度也令人惊喜。
短短两年时间，从开源的GCC、LLVM到专有的Visual C++和Intel C++，对于新标准的追踪之快，覆盖之全，
与当年C++ 98标准颁布之后迟迟不能落地的窘境相比，可谓对比强烈。

当年是热情的开发者反复敦促厂商实现完整标准而不得，为此沮丧无奈，那种心情，至今记忆犹新。
时过境迁，今天是编译器实现远远冲在前面，开发者倒是大大地落在了后面。
时至今日，能够基本了解C++11标准的程序员恐怕不多，而能够以新的C++风格开发实践的人更是凤毛麟角。
因此，今天的C++开发者面临的一个重要任务就是快速掌握新的C++风格和工具。

而说到教授“正宗的”C++11编程风格，《C++ Primer（第5版）》如同它之前的版本一样，扮演着法定教科书的角色。

一种优秀的编程语言，一定要对于计算这件事情实现一个完整和自洽的抽象。
十几年来编程语言领域的竞争，除却实现质量之外，基本上是在比拼抽象的设计。
而C语言之所以四十年长盛不衰，根本在于它对于现代计算机提供了一个最底层的高级抽象：

凡是比它低的抽象都过于简陋，凡是比它高的抽象都可以用C语言构造出来。

C++成功的根本原因，恰恰是因为它虽然试图提供一些高级的抽象机制，但是其根基与C在同一层面。
正因为如此，每当你需要走下去直接与硬件对话时，C++成为C之外唯一有效率的选择。
我的一个朋友在进行了多年的大型系统软件开发之后，不无感慨地说，C++最大的力量不在于其抽象，恰恰在于其不抽象。

话虽然如此，但是C++之所以脱离C而存在，毕竟还是因为其强大的抽象能力。
Bjarne Stroustrup曾经总结说，C++同时支持4种不同的编程风格：C风格、基于对象、面向对象和泛型。

事实上，把微软的COM也算进来的话，还可以加上一种“基于组件”的风格。
这么多的风格共存于一种语言，就是其强大抽象机制的证明。
但是，在C++11以前，C++的抽象可以说存在若干缺陷，其中最严重的是缺少自动内存管理和对象级别的消息发送机制。

今天看来，C++ 98只能说是特定历史条件造成的半成品，无论是从语言机制，还是标准库完备程度来说，可以说都存在明显的、不容忽略的缺陷。
其直接后果，就是优雅性的缺失和效率的降低。

我本人在十年前曾经与当时中国C++社群中不少杰出的人物交流探讨，试图从C++ 98中剪裁出一个小巧、优雅的、自成一体的子集，
希望至少在日常编程中，能够在这个子集之内可以写出与当时的Java和C#同样干净明晰的代码。
为此我们尝试了各种古怪的模板技巧，并且到处寻找有启发的代码和经验来构造这个语言子集，结果并不理想，甚至可以说是令人非常失望。
后来我在我的博客中发表过好几篇文章，探讨所谓的C++风格问题，
其实就是说，C++不支持简洁明快的面向对象风格，大家还不如回到基于对象甚至C语言的风格，最多加点模板，省一点代码量。
非要面向对象的话，就必须依赖像Qt或者MFC那样的基础设施才可以。

C++11出来之后，增强的语言机制和大为完善的标准库，为C++语言的编程风格带来了革命性的变化。
如果能够纯熟地运用C++11的新特征、新机制，那么就能够形成一种简洁优雅的C++编程风格，以比从前更高的效率、更好的质量进行软件开发。
对于这种新的风格，我认为“直觉、自然”是最佳的描述。
也就是说，解决任何问题不必拘泥于什么笼盖一切的编程思想，也不再沉溺于各种古怪的模板技巧中无法自拔，
而是能够根据那个问题本身采用最自然、最符合直觉的方式。

C++有自己的一套思维方式，比如容器、算法、作为概念抽象的对象等，很大程度上这套思维方式确实是合乎直觉的。
只有到了C++11这一代，C++语言的高级抽象才基本完备，这样一种风格才可能真正落实。
因此可以说C++11对于C++ 98而言，不是一次简单的升级，而是一次本质的跃升。

学习新的C++风格，并不是轻而易举的事情。
即便对于以前已经精通C++的人来说，熟练掌握rvalue reference、move语义，了解unique_ptr、shared_ptr和weak_ptr的完整用法，
明智地使用function/bind和lambda机制，学习C++ Concurrency的新技术，都绝非一朝一夕之功。
对于那些初学者来说，这件事情更不简单。

本书无论对于初学者还是提高者，都是最经典的教科全书。
一直以来，它的特点就是完整而详细，基本上关于语言本身的问题，都可以在这本书里得到解决。
而本书的另一个重要优点，就是其完全基于新的编程风格编写，所有的例子和讲解都遵循C++11标准所体现出来的思路和风格进行，
如果能够踏下心来认真学习和练习，那么就能“一次到位”地掌握C++11，尽管可能会比较慢。
有经验的C++开发者阅读这本书当然不用从头到尾，选择自己关心的内容学习C++11的新特性就可以，是快速升级自身能力的捷径。

差不多十年前，我提出一个观点，每一个具体的技术领域，只需要读四五本书就够了。
以前的C++是个例外，因为语言设计有缺陷，所以要读很多书才知道如何绕过缺陷。
现在的C++11完全可以了，大家读四五本书就可以达到合格的水平，这恰恰是语言进步的体现。

本书是这四五本中的一本，而且是“教程+参考书”，扛梁之作，初学者的不二法门。
另一本是《C++标准程序库（第2版）》，对于C++熟手来说更为快捷。
Scott Meyers的Effective C++永远是学习C++者必读的，只不过这本书的第4版不知道什么时候出来。
Anthony Williams的C++ Concurrency in Action是学习用标准C++开发并发程序的最佳选择。
国内的作品，我则高度推荐陈硕的《Linux多线程服务端编程》。
这本书的名字赶跑了不少潜在的读者，所以我要特别说明一下。这本书是C++开发的高水平作品，与其说是教你怎么用C++写服务端开发，
不如说是教你如何以服务端开发为例子提升C++开发水平。

前面几本书都是谈标准C++自己的事情，碰到像iostream这样失败的标准组件也不得不硬着头皮介绍。
而这本书是接地气的实践结晶，告诉你面对具体问题时应怎样权衡，C++里什么好用，什么不好用，为什么，等等。

今天的C++学习者是非常幸运的，可以在C++11这个基础上大步向前，不必再因为那些语言的缺陷和过度的技巧而烦恼。
大家静下心来认真读几本书，可以打下很好的基础。

孟岩
2013年8月 北京

