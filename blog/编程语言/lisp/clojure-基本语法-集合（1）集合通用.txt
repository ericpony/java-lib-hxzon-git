clojure-基本语法-集合（1）集合通用

clojure-基本语法-集合（三）集合通用

http://dead-knight.iteye.com/blog/1831446

========
操作集合的通用语句 

1、count： 
count函数返回集合中元素的个数，如果count参数为nil，则返回0 。

user=> (count nil)  
0  
user=> (count [])  
0  
user=> (count [1 2 3])  
3  
user=> (count '(1 "a"))  
2  
user=> (count {:one 1 :two 2})  
2  
user=> (count "string")  
6  


2、empty： 
返回一个空的集合，集合类型不变，如果empty参数为nil，则返回nil 。

user=> (empty [1 2 3])  
[]  

user=> (empty (list 1 2 3))  
()  

user=> (empty {:key1 1})  
{}  

user=> (empty nil)  
nil  


3、not-empty： 
如果集合为空，返回nil，否则直接返回参数指向的集合 。

user=> (not-empty [])  
nil  

user=> (not-empty '(1 2 3))  
(1 2 3)  


4、into： 
into接受两个集合参数，并且将第二个集合参数的元素全部插入到第一个集合参数中，再返回。 

user=> (into {} [[1 2] [3 4]])  
{1 2, 3 4}  

user=> (into [] {:a 1 :b 2})  
[[:a 1] [:b 2]]  

user=> (into () '(1 2 3))  
(3 2 1)  

user=> (into ["a" "b"] '(1 2 3))  
["a" "b" 1 2 3]  


5、contains?： 
如果当前给定的集合（第一个参数）存在key（第二个参数），则返回true，否则返回false。
特别指出，对于数组、vector以索引标识的集合，如果key在索引范围内，则返回true，否则返回false，
对于列表类型，总是返回false。 

user=> (contains? {:a 1} :a)  
true  
user=> (contains? {:a nil} :a)  
true  
user=> (contains? {:a 1} :b)  
false  
user=> (contains? [:a :b :c] :b)  
false  
user=> (contains? [:a :b :c] 2)  
true  
user=> (contains? "f" 0)  
true  
user=> (contains? "f" 2)  
false  

user=> (contains? '(1 2 3) 1)  
false  

user=> (contains? #{"a" "b" "v"} "a")  
true  
user=> (contains? #{"a" "b" "c"} "z")  
false  


6、distinct?： 
如果传递的参数列表中有值相同的（即出现重复），返回false，否则返回true。 

user=> (distinct? 1 2 3)  
true  

user=> (distinct? 1 1 2 3)  
false  

user=> (distinct? "a" "b" "a")  
false  


7、empty?： 
接受一个集合参数，如果该集合没有元素，则返回true，否则返回false。 

user=> (empty? ())  
true  
user=> (empty? '(1 2 3))  
false  
user=> (empty? [])  
true  
user=> (empty? {})  
true  
user=> (empty? #{})  
true  


8、every?： 
every?接受两个参数，第一个参数为检查函数，第二个参数为集合。
如果该检查函数对集合所有元素都通过，则返回true，否则返回false。 

user=> (every? even? '(2 4 6))  
true  

user=> (every? odd? '(1 3 9))  
true  

user=> (every? true? '())  
true  

user=> (every? false? '())  
true  


9、not-every?： 
not-every?与every作用相反。参照every介绍。 
如果有元素不通过的，返回true，否则返回false。

user=> (not-every? odd? '(1 2 3))  
true  

user=> (not-every? odd? '(1 3))  
false  


10、some： 
只要有一个元素检查为true，则返回true。所有检查都不通过，则返回nil。 

user=> (some even? '(1 2 3 4))  
true  

user=> (some even? '(1 3 5 7))  
nil  

user=> (some true? [false false false])  
nil  

user=> (some true? [false true false])  
true  


11、not-any?： 
not-any?与some函数作用也相反（定义为comp not some），可参考some描述。 

user=> (not-any? odd? '(2 4 6))  
true  

user=> (not-any? odd? '(1 2 3))  
false  


12、sequential?： 
sequential?检查集合是否实现Sequential接口（不是排序，而是顺序存储），是则返回true，否则返回false。 

user=> (sequential? '(2 1 3))  
true  

user=> (sequential? {:a 1 :d 2 :b 3})  
false  

user=> (sequential? 1)  
false  


13、associative?： 
associative?检查集合是否实现Associative接口（关系型），是则返回true，否则返回false。 

user=> (associative? [1 2 3])  
true  

user=> (associative? '(1 2 3))  
false  


14、sorted?： 
sorted?检查集合是否实现Sorted接口，是则返回true，否则返回false。 

user=> (sorted? (sorted-set 5 3 1 2 4))  
true  

user=> (sorted? (sorted-map :a 1 :c 3 :b 2))  
true  

user=> (sorted? [1 2 3 4 5])  
false  


15、counted?： 
如果集合参数以常量时间内返回元素个数总和时，返回true，否则返回false。 

user=> (counted? [:a :b :c])  
true  

user=> (counted? '(:a :b :c))  
true  

user=> (counted? {:a 1 :b 2 :c 3})  
true  

user=> (counted? "asdf")  
false  


16、reversible?： 
reversible?检查集合参数是否实现Reversible接口，是则返回true，否则返回false。 

user=> (reversible? [])  
true  

user=> (reversible? '())  
false  

user=> (reversible? #{})  
false  

=========
类型检查 

1、coll?： 
如果给定的参数实现IPersistentCollection接口（集合都会实现该接口），则返回true，否则返回false。 

user=> (coll? {})   
true   

user=> (coll? #{})   
true   

user=> (coll? [])   
true   

user=> (coll? ())   
true   

user=> (coll? 4)   
false  

user=> (coll? "fred")   
false  

user=> (coll? true)   
false  

user=> (coll? nil)   
false  


2、seq?： 
如果给定的参数实现ISeq接口（序列实现该接口），则返回true，否则返回false 。

user> (seq? 1)   
false   
user> (seq? [1])   
false   
user> (seq? (seq [1]))   
true   


3、vector?： 
如果给定的参数实现IPersistentVector接口（向量Vector实现该接口），则返回true，否则返回false 。

user=> (vector? [1 2 3])   
true   

user=> (vector? '(1 2 3))   
false   

user=> (vector? (vec '(1 2 3)))   
true   


4、list?： 
如果给定的参数实现IPersistentList接口（列表List实现该接口），则返回true，否则返回false 。

user=> (list? '(1 2 3))   
true   
user=> (list? (list 1 2))   
true   
user=> (list? 0)   
false   
user=> (list? {})   
false   
user=> (list? [])   
false    


5、map?： 
如果给定的参数实现IPersistentMap接口（映射Map实现该接口），则返回true，否则返回false 。

user=> (map? {:a 1 :b 2 :c 3})   
true   
user=> (map? '(1 2 3))   
false    


6、set?： 
如果给定的参数实现IPersistentSet接口（set集合实现该接口），则返回true，否则返回false 。

user> (set? #{1 2 3})   
true   

user> (set? [1 2 3])   
false   

user> (set? {:a 1 :b 2})   
false   

实际上本篇介绍的各种检查语句，都是检查底层实现类所实现的接口（具有对应接口的功能），比如说列表List的实现类定义为： 

public class PersistentList extends ASeq  
  implements IPersistentList, IReduce, List, Counted  

=======
hxzon补充：

向量看成以索引为键的映射。
set看成元素到自身的映射。

列表是以单向链接列表的形式来实现的。
读取列表的第一个元素或者在列表头添加一个元素的操作都可以在常量时间内完成，然而访问列表的第N个元素却需要N次操作。 
向量支持高效地根据索引来访问元素，与数组类似。

----
cons，(cons x seq)，返回一个新的序列， 序列的第一个元素是 x ， 而 seq 则是序列的其余部分。

----
conj，如果是列表，在列表头部插入元素。
如果是向量，在尾部插入元素。
也支持映射，set。
(conj coll x)
(conj coll x & xs)

当 coll 等于 nil ， 也即是，执行 (conj nil item) 时， 结果为 (item) 。
--
; 处理多个元素的 conj
; 注意向量和列表的结果之间的不同

user=> (conj [0 1 2] 3 4 5)
[0 1 2 3 4 5]

user=> (conj (list 0 1 2) 3 4 5)
(5 4 3 0 1 2)

----
assoc，如果是映射，更新（或添加）指定的键的值。
如果是向量，更新指定索引的值，注意，索引不能超出范围，否则抛出异常。

----
assoc-in，
function
Usage: (assoc-in m [k & ks] v)

Associates a value in a nested associative structure, 
where ks is a sequence of keys and v is the new value and returns a new nested structure.
If any levels do not exist, hash-maps will be created.
用来更新嵌套的关系型结构，ks是一个键的序列。
如果某一层级不存在，将创建一个hash-map。

----
get，如果是映射，返回指定键的值。
如果是向量，返回指定索引的值。
如果是set，返回键本身（集合看成元素到元素自身的映射）。
(get map key)
(get map key not-found)
如果key不存在，返回not-found，如果不指定not-found，返回nil。

----
get-in，
function
Usage: (get-in m ks)
       (get-in m ks not-found)

Returns the value in a nested associative structure,where ks is a sequence of keys. 
Returns nil if the key is not present, or the not-found value if supplied.
根据指定的键序列，获取嵌套的关系型结构中的值。
如果键不存在，且没指定not-found，返回nil。

----
dissoc
function
Usage: (dissoc map)
       (dissoc map key)
       (dissoc map key & ks)

dissoc[iate]. Returns a new map of the same (hashed/sorted) type,that does not contain a mapping for key(s).
从映射中去除指定的键。

----
disj
function
Usage: (disj set)
       (disj set key)
       (disj set key & ks)

disj[oin]. Returns a new set of the same (hashed/sorted) type, that does not contain key(s).
从set中去除指定的键。

user=> (disj #{1 3 5 7} 3 7)  
#{1 5}  

----
find，(find map key)，
如果是映射，返回指定的键值对（用向量表示）。
如果是向量，返回指定的索引和值（用向量表示）。
如果键不存在，返回nil。

Returns the map entry for key, or nil if key not present.

----
first，返回第一个元素（传入的coll会被seq处理）。
如果 coll 为 nil ，返回 nil 。
支持向量，列表，映射，set。

----
last，Return the last item in coll, in linear time。
在线性时间内返回集合的最后一个元素。

----
pop，如果是列表，返回去除了头部元素的新列表。
如果是向量，返回去除尾部元素的新向量。
如果列表或向量是空的，抛出异常。

peek，如果是列表或队列，类似于first。
如果是向量，类似last，但更高效。
如果列表或向量是空的，返回nil。

next，
Returns a seq of the items after the first. 
Calls seq on its argument.  
If there are no more items, returns nil.
返回除去第一个元素后的序列。
内部对参数调用seq。
如果没有更多元素，返回nil。

rest，
Returns a possibly empty seq of the items after the first. Calls seq on its argument.
返回除去第一个元素后的序列，内部对参数调用seq。
如果没有更多元素，返回空序列。

----
rseq，在常数时间内，返回 rev 的逆序序列。
rev 只能是向量或者 sorted-map 。
rev 为空时，返回 nil 。

----
subseq，
(subseq sc test key)
(subseq sc start-test start-key end-test end-key)
过滤 sc 并返回一个序列，序列里的所有实体(entry)的键 ek 都必须符合条件 (true? (test (.. sc comparator (compare ek key)) 0)) 。

如果没有任何实体符合条件，则返回 nil 。
参数 sc 必须是一个 sorted collection ，测试条件 test 可以是 < 、 <= 、 > 或者 >= 。

user=> (def numbers (sorted-map 1 "one" 2 "two" 3 "three" 4 "four" 5 "five"))
#'user/numbers

user=> numbers
{1 "one", 2 "two", 3 "three", 4 "four", 5 "five"}


; 过滤所有键小于 3 的键-值对
user=> (subseq numbers >= 3)
([3 "three"] [4 "four"] [5 "five"])


; 过滤所有键小于 1 大于 4 的键-值对
user=> (subseq numbers >= 2 <= 4)
([2 "two"] [3 "three"] [4 "four"])


; 过滤所有键小于 10 的键-值对，返回 nil
user=> (subseq numbers >= 10)
nil

----
rsubseq，
(rsubseq sc test key)
(rsubseq sc start-test start-key end-test end-key)
用法和 `subseq`_ 一样，但是返回的序列是逆序排序的。

