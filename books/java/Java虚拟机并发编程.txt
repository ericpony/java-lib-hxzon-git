Java虚拟机并发编程

出版社: 机械工业出版社; 第1版 (2013年5月6日)
外文书名: Programming Concurrency on the JVM Mastering Synchronization, STM, and Actors
丛书名: 华章程序员书库
平装: 216页
语种： 简体中文
开本: 16
ISBN: 9787111418931
===========

苏布拉马尼亚姆所著的《Java虚拟机并发编程》是Java并发编程领域的里程碑之作，
由资深Java技术专家、并发编程专家、敏捷开发专家和Jolt大奖得主撰写，Amazon五星级畅销书。
它系统深入地讲解在JVM平台上如何利用JDK同步模型、软件事务内存模型和基于角色的并发模型更好地进行并发编程。
全书以示例驱动，通俗易懂，包含大量编程技巧、注意事项和最佳实践。
要重点强调的是，本书并不仅仅只适合于Java语言的并发编程，
它还适用于clojure、Groovy、JRuby和Scala等所有运行在JVM平台上的编程语言。

《Java虚拟机并发编程》共10章，分为五个部分。
第一部分：并发策略，阐释了影响并发性的因素、如何有效实现并发，以及并发的设计方法等；
第二部分：现代Java／JDK并发，讨论了现代Java API的线程安全和效率，以及如何处理已有应用程序中的现实问题和重构遗留代码时的原则；
第三部分：软件事务内存，深入讨论了STM并就如何在各种主要的JVM语言里使用STM给出了指导意见；
第四部分：基于角色的并发，详细讲解了如何在基于角色的模型下消除并发问题以及如何在自己的首选语言中使用角色模型；
第五部分：后记，回顾了本书讨论的解决方案并总结了并发编程中的注意事项和最佳实践。

==============
目录

译者序
前言


第1章 并发的威力与风险/1


第一部分 并发策略

第2章 分工原则/11
第3章 设计方法/28


第二部分 现代Java/JDK并发模型

第4章 可扩展性和线程安全/37
第5章 驯服共享可变性/59


第三部分 软件事务内存

第6章 软件事务内存导论/71
第7章 在Clojure、Groovy、Java、JRuby和Scala中使用STM/117


第四部分 基于角色的并发模型

第8章 讨喜的隔离可变性/135
第9章 在Groovy、Java、JRuby和Scala中使用角色/186


第五部分 后记

第10章 并发编程之禅/205


附录1 Clojure agent/210
附录2 一些网络资源/214

参考文献/216
==============
目录
译者序

前言

第1章 并发的威力与风险/1

1.1 线程：程序的执行流程/1
1.2 并发的威力/1
1.3 并发的风险/4
1.4 小结/9


第一部分 并发策略

第2章 分工原则/11

2.1 从顺序到并发/11
2.2 在IO密集型应用程序中使用并发技术/13
2.3 并发方法对IO密集型应用程序的加速效果/19
2.4 在计算密集型应用程序中使用并发技术/20
2.5 并发方法对于计算密集型应用程序的加速效果/25
2.6 有效的并发策略/26
2.7 小结/27

第3章 设计方法/28

3.1 处理状态/28
3.2 探寻设计选项/29
3.3 共享可变性设计/29
3.4 隔离可变性设计/30
3.5 纯粹不可变性设计/30
3.6 持久的/不可变的数据结构/31
3.7 选择一种设计方法/34
3.8 小结/34


第二部分 现代Java/JDK并发模型

第4章 可扩展性和线程安全/37

4.1 用ExecutorService管理线程/37
4.2 使线程协作/38
4.3 数据交换/47
4.4 Java 7 Fork-Join API/49
4.5 可扩展集合类/51
4.6 Lock和Synchronized/54
4.7 小结/58

第5章 驯服共享可变性/59

5.1 共享可变性 != Public/59
5.2 定位并发问题/59
5.3 保持不变式/61
5.4 管理好资源/62
5.5 保证可见性/64
5.6 增强并发性/65
5.7 保证原子性/67
5.8 小结/70


第三部分 软件事务内存

第6章 软件事务内存导论/71

6.1 同步与并发水火不容/71
6.2 对象模型的缺陷/72
6.3 将实体与状态分离/73
6.4 软件事务内存/74
6.5 STM中的事务/77
6.6 用STM实现并发/77
6.7 用Akka/Multiverse STM实现并发/82
6.8 创建事务/84
6.9 创建嵌套事务/90
6.10 配置Akka事务/97
6.11 阻塞事务―有意识地等待/100
6.12 提交和回滚事件/103
6.13 集合与事务/106
6.14 处理写偏斜异常/110
6.15 STM的局限性/112
6.16 小结/116

第7章 在Clojure、Groovy、Java、JRuby和Scala中使用STM/117

7.1 Clojure STM/117
7.2 Groovy集成/118
7.3 Java集成/122
7.4 JRuby集成/124
7.5 Scala中的可选方案/130
7.6 小结/133


第四部分 基于角色的并发模型

第8章 讨喜的隔离可变性/135

8.1 用角色实现隔离可变性/136
8.2 角色的特性/137
8.3 创建角色/138
8.4 收发消息/144
8.5 同时使用多个角色/148
8.6 多角色协作/152
8.7 使用类型化角色/159
8.8 类型化角色和murmurs/163
8.9 混合使用角色和STM/169
8.10 使用transactor/169
8.11 调和类型化角色/176
8.12 远程角色/182
8.13 基于角色模型的局限性/184
8.14 小结/184

第9章 在Groovy、Java、JRuby和Scala中使用角色/186

9.1 在Groovy中使用GPars提供的角色实现/186
9.2 在Java中使用Akka提供的角色实现/199
9.3 在JRuby中使用Akka提供的Actor实现/199
9.4 在Scala中使用角色/202
9.5 小结/202


第五部分 后记

第10章 并发编程之禅/205

10.1 慎重选择/205
10.2 并发：程序员指南/206
10.3 并发：架构师指南/207
10.4 明智地进行选择/208


附录1 Clojure agent/210
附录2 一些网络资源/214

参考文献/216
