On Lisp 中文版
Common Lisp 高级编程技术
Paul Graham
Copyright  2007 Paul Graham
原书站点: http://www.paulgraham.com/onlisp.html

==============
目 录

第 1 章 可扩展语言 . . . . . . 1
第 2 章 函数. . . . . . . . . . . . . 7
第 3 章 函数式编程 . . . . . . 19
第 4 章 实用函数 . . . . . . . . 27
第 5 章 函数作为返回值 . . . . . . . . . . . . . 41
第 6 章 函数作为表达方式 . . . . . . . . . . . 51

第 7 章 宏. . . . . . . . . . . . . . . 55
第 8 章 何时使用宏 . . . . . . 71
第 9 章 变量捕捉 . . . . . . . . 79
第 10 章 其他的宏陷阱 . . . . . . . . . . . . . . 89
第 11 章 经典宏. . . . . . . . . . 97
第 12 章 广义变量 . . . . . . . 111
第 13 章 编译期计算 . . . . . . . . . . . . . . . . 123
第 14 章 指代宏. . . . . . . . . . 129
第 15 章 返回函数的宏 . . . . . . . . . . . . . . 137
第 16 章 定义宏的宏 . . . . . . . . . . . . . . . . 145
第 17 章 读取宏 (read-macro) . . . . . . . . . 153
第 18 章 解构. . . . . . . . . . . . 157
第 19 章 一个查询编译器 . . . . . . . . . . . . 169
第 20 章 续延 (continuation) . . . . . . . . . . 177
第 21 章 多进程. . . . . . . . . . 189
第 22 章 非确定性 . . . . . . . 197
第 23 章 使用 ATN 分析句子 . . . . . . . . . 211
第 24 章 Prolog . . . . . . . . . . 223
第 25 章 面向对象的 Lisp . . . . . . . . . . . . 241

附录: 包 (packages) . . . . . . . . 263
附注 . . . . . . . . . . 267
索 引 . . . . . . . . 277
==============
目 录

第 1 章 可扩展语言 . . . . . . 1

1.1 渐进式设计 . . . . . . . 1
1.2 自底向上程序设计 . . . . . . . . . . . . . 2
1.3 可扩展软件 . . . . . . . 3
1.4 扩展 Lisp . . . . . . . . . 4
1.5 为什么 (或说何时) 用 Lisp . . . . . . . 4

第 2 章 函数. . . . . . . . . . . . . 7

2.1 作为数据的函数. . . . . . . . . . . . . . . 7
2.2 定义函数 . . . . . . . . . 7
2.3 函数型参数 . . . . . . . 9
2.4 作为属性的函数. . . . . . . . . . . . . . . 10
2.5 作用域 . . . . . . . . . . . 11
2.6 闭包 . . . . . . . . . . . . . 12
2.7 局部函数 . . . . . . . . . 14
2.8 尾递归 . . . . . . . . . . . 15
2.9 编译 . . . . . . . . . . . . . 16
2.10 来自列表的函数. . . . . . . . . . . . . . . 18

第 3 章 函数式编程 . . . . . . 19

3.1 函数式设计 . . . . . . . 19
3.2 内外颠倒的命令式 . . . . . . . . . . . . . 22
3.3 函数式接口 . . . . . . . 23
3.4 交互式编程 . . . . . . . 24

第 4 章 实用函数 . . . . . . . . 27

4.1 实用工具的诞生. . . . . . . . . . . . . . . 27
4.2 投资抽象 . . . . . . . . . 28
4.3 列表上的操作 . . . . . . . . . . . . . . . . 29
4.4 搜索 . . . . . . . . . . . . . 32
4.5 映射 . . . . . . . . . . . . . 35
4.6 I/O . . . . . . . . . . . . . . 37
4.7 符号和字符串 . . . . . . . . . . . . . . . . 38
4.8 紧凑性 . . . . . . . . . . . 39

第 5 章 函数作为返回值 . . . . . . . . . . . . . 41

5.1 Common Lisp 的演化 . . . . . . . . . . . 41
5.2 正交性 . . . . . . . . . . . 42
5.3 记住过去 . . . . . . . . . 43
5.4 复合函数 . . . . . . . . . 44
5.5 在 cdr 上递归 . . . . . . 45
5.6 在子树上递归 . . . . . . . . . . . . . . . . 47
5.7 何时构造函数 . . . . . . . . . . . . . . . . 50

第 6 章 函数作为表达方式 . . . . . . . . . . . 51

6.1 网络 . . . . . . . . . . . . . 51
6.2 编译后的网络 . . . . . . . . . . . . . . . . 53
6.3 展望 . . . . . . . . . . . . . 54

第 7 章 宏. . . . . . . . . . . . . . . 55

7.1 宏是如何工作的. . . . . . . . . . . . . . . 55
7.2 反引用 (backquote) . . . . . . . . . . . . . 56
7.3 定义简单的宏 . . . . . . . . . . . . . . . . 59
7.4 测试宏展开 . . . . . . . 60
7.5 参数列表的解构. . . . . . . . . . . . . . . 62
7.6 宏的工作模式 . . . . . . . . . . . . . . . . 63
7.7 作为程序的宏 . . . . . . . . . . . . . . . . 64
7.8 宏风格 . . . . . . . . . . . 65
7.9 宏的依赖关系 . . . . . . . . . . . . . . . . 67
7.10 来自函数的宏 . . . . . . . . . . . . . . . . 68
7.11 符号宏 (symbol-macro) . . . . . . . . . 69

第 8 章 何时使用宏 . . . . . . 71

8.1 当别无他法时 . . . . . . . . . . . . . . . . 71
8.2 宏还是函数？ . . . . . . . . . . . . . . . . 72
8.3 宏的应用场合 . . . . . . . . . . . . . . . . 74

第 9 章 变量捕捉 . . . . . . . . 79

9.1 宏参数捕捉 . . . . . . . 79
9.2 自由符号捕捉 . . . . . . . . . . . . . . . . 80
9.3 捕捉发生的时机. . . . . . . . . . . . . . . 80
9.4 取更好的名字避免捕捉 . . . . . . . . . 83
9.5 通过预先求值避免捕捉 . . . . . . . . . 83
9.6 通过 gensym 避免捕捉 . . . . . . . . . . 85
9.7 通过包避免捕捉. . . . . . . . . . . . . . . 86
9.8 其他名字空间里的捕捉 . . . . . . . . . 87
9.9 为何要庸人自扰? . . . . . . . . . . . . . . 88

第 10 章 其他的宏陷阱 . . . . . . . . . . . . . . 89

10.1 求值的次数 . . . . . . . 89
10.2 求值的顺序 . . . . . . . 90
10.3 非函数式的展开器 . . . . . . . . . . . . . 90
10.4 递归 . . . . . . . . . . . . . 92

第 11 章 经典宏. . . . . . . . . . 97

11.1 创建上下文 . . . . . . . 97
11.2 with- 宏. . . . . . . . . . 99
11.3 条件求值 . . . . . . . . . 101
11.4 迭代 . . . . . . . . . . . . . 104
11.5 多值迭代 . . . . . . . . . 106
11.6 需要宏的原因 . . . . . . . . . . . . . . . . 108

第 12 章 广义变量 . . . . . . . 111

12.1 概念 . . . . . . . . . . . . . 111
12.2 多重求值问题 . . . . . . . . . . . . . . . . 112
12.3 新的实用工具 . . . . . . . . . . . . . . . . 113
12.4 更复杂的实用工具 . . . . . . . . . . . . . 115
12.5 定义逆 . . . . . . . . . . . 119

第 13 章 编译期计算 . . . . . . . . . . . . . . . . 123

13.1 新的实用工具 . . . . . . . . . . . . . . . . 123
13.2 举例：贝塞尔曲线. . . . . . . . . . . . . . 126
13.3 应用 . . . . . . . . . . . . . 126

第 14 章 指代宏. . . . . . . . . . 129

14.1 指代的种种变形. . . . . . . . . . . . . . . 129
14.2 失败 . . . . . . . . . . . . . 132
14.3 引用透明 (Referential Transparency) . . . . . . . . . . . 135

第 15 章 返回函数的宏 . . . . . . . . . . . . . . 137

15.1 函数的构造 . . . . . . . 137
15.2 在 cdr 上做递归 . . . . . . . . . . . . . . . 139
15.3 在子树上递归 . . . . . . . . . . . . . . . . 142
15.4 惰性求值 . . . . . . . . . 142

第 16 章 定义宏的宏 . . . . . . . . . . . . . . . . 145

16.1 缩略语 . . . . . . . . . . . 145
16.2 属性 . . . . . . . . . . . . . 146
16.3 指代宏 . . . . . . . . . . . 148

第 17 章 读取宏 (read-macro) . . . . . . . . . 153

17.1 宏字符 . . . . . . . . . . . 153
17.2 dispatching 宏字符 . . . . . . . . . . . . . 154
17.3 定界符 . . . . . . . . . . . 155
17.4 这些发生于何时. . . . . . . . . . . . . . . 156

第 18 章 解构. . . . . . . . . . . . 157

18.1 列表上的解构 . . . . . . . . . . . . . . . . 157
18.2 其他结构 . . . . . . . . . 157
18.3 引用 . . . . . . . . . . . . . 161
18.4 匹配 . . . . . . . . . . . . . 162

第 19 章 一个查询编译器 . . . . . . . . . . . . 169

19.1 数据库 . . . . . . . . . . . 169
19.2 模式匹配查询 . . . . . . . . . . . . . . . . 170
19.3 一个查询解释器. . . . . . . . . . . . . . . 171
19.4 绑定上的限制 . . . . . . . . . . . . . . . . 173
19.5 一个查询编译器. . . . . . . . . . . . . . . 174

第 20 章 续延 (continuation) . . . . . . . . . . 177

20.1 Scheme 续延 . . . . . . . 177
20.2 续延传递宏 . . . . . . . 182
20.3 Code-Walker 和 CPS Conversion . . . . . . . . . . . . . . 186

第 21 章 多进程. . . . . . . . . . 189

21.1 进程抽象 . . . . . . . . . 189
21.2 实现 . . . . . . . . . . . . . 190
21.3 不那么快速的原型 . . . . . . . . . . . . . 194

第 22 章 非确定性 . . . . . . . 197

22.1 概念 . . . . . . . . . . . . . 197
22.2 搜索 . . . . . . . . . . . . . 199
22.3 Scheme 实现 . . . . . . . 201
22.4 Common Lisp 实现 . . . . . . . . . . . . . 202
22.5 减枝 . . . . . . . . . . . . . 205
22.6 真正的非确定性. . . . . . . . . . . . . . . 207

第 23 章 使用 ATN 分析句子 . . . . . . . . . 211

23.1 背景知识 . . . . . . . . . 211
23.2 形式化 . . . . . . . . . . . 211
23.3 非确定性 . . . . . . . . . 213
23.4 一个 ATN 编译器 . . . . . . . . . . . . . . 213
23.5 一个 ATN 的例子 . . . . . . . . . . . . . . 217

第 24 章 Prolog . . . . . . . . . . 223

24.1 概念 . . . . . . . . . . . . . 223
24.2 解释器 . . . . . . . . . . . 224
24.3 规则 . . . . . . . . . . . . . 228
24.4 对于非确定性的需求 . . . . . . . . . . . 230
24.5 新的实现 . . . . . . . . . 231
24.6 增添 Prolog 特性 . . . . . . . . . . . . . . 233
24.7 例子 . . . . . . . . . . . . . 238
24.8 编译的含义 . . . . . . . 240

第 25 章 面向对象的 Lisp . . . . . . . . . . . . 241

25.1 万变不离其宗 . . . . . . . . . . . . . . . . 241
25.2 阳春版 Lisp 中的对象. . . . . . . . . . . 242
25.3 类和实例 . . . . . . . . . 252
25.4 方法 . . . . . . . . . . . . . 254
25.5 辅助方法和组合. . . . . . . . . . . . . . . 258
25.6 CLOS 与 Lisp . . . . . . 260
25.7 何时用对象 . . . . . . . 261

附录: 包 (packages) . . . . . . . . 263
附注 . . . . . . . . . . 267
索 引 . . . . . . . . 277

