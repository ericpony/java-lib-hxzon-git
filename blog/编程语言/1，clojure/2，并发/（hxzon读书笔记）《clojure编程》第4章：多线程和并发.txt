（hxzon读书笔记）《clojure编程》第4章：多线程和并发

by hxzon
======
1，除了var，ref，atom，agent四种引用类型，还有delay，future，promise可以解引用。

引用类型就是值的容器。
@是deref的语法糖，但是不能指定“超时时间”和“超时值”。

----
2，delay

delay提供让代码延迟执行的机制，代码只会在显示调用deref时执行。

这意味着在第一次对一个delay解引用时，可以多个线程同时解引用，
所有的线程都会被阻塞直到delay所包含的代码被求值（只求值一次），
之后所有线程就可以访问这个值了。

--
可以使用realized? 来检测delay、future、promise以及惰性序列，是否已经求值。

----
3，future

future会在另外一个线程里面执行它所包含的代码。
如果future的执行还未完成，解引用会阻塞直到执行完成。

解引用future时可以指定一个“超时时间”和“超时值”。
解引用delay则不可以。

--
future-all可以用来在另外一个线程中调用一个无参函数。

--
future跟agent共享一个线程池里面的线程。
future是java.util.concurrent.Future的对象。

----
4，promise

promise在创建时不会指定任何代码或者函数来最终产出它的值，
它最开始是空的容器，
在其它时间点，通过deliver函数来填充入一个值。

解引用promise也可以指定一个“超时时间”和“超时值”。

promise跟一个一次性的，单值的管道类似。
这种东西有时被称为“数据流变量”，是进行“声明式并发编程”的基础构件。

promise不会检测循环依赖。

对promise的一个最直接的应用是让基于回调的api，以同步的方式执行（即等待这个回调函数执行完毕）。

----
5，pmap，简单的并行化。

pmap是map的并行版本，会以并行的方式，用多线程来把一个函数应用到一个序列的元素上去。
和map一样，它也返回一个惰性序列。
pmap内部只是简单的使用了一些future，
future的个数就是机器的cpu核心个数。

要谨慎使用pmap，如果被并行的操作本身执行时间不长，
则线程之间协调的开销相当可观。

一个缓解方案是，把一些小的计算任务组合成一个较大的计算单元。

--
pcalls，接受任意数量无参函数，返回一个包含它们的返回值的惰性序列。

--
pvalues，宏，接受任意数量的表达式，返回一个包含它们的返回值的惰性序列。

----
6，clojure中所有的无参函数，都实现了Runnable和Callable接口，所以可以使用java的并发库。

----
7，locking宏

用locking宏来获取一个给定对象上的锁，然后在程序控制流离开locking的时候，这个锁会自动释放。









