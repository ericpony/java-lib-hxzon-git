ORM for clojure？注释by hxzon。======http://stackoverflow.com/questions/7351891/orm-for-clojureI was reading this site about the clojure web stack:http://brehaut.net/blog/2011/ring_introductionand it has this to say about ORM for clojure:"There are no SQL/Relational DB ORMs for Clojure for obvious reasons."（obvious，明显。）The obvious reason I can see is that the mapping to object happens automatically when you do a clojure.contrib.sql or clojureql query. However it seems some extra work is needed to do one-to-many or many-to-many relations (although maybe not too much work).在我看来，明显原因，是指两个库的查询语句会自动将字段映射到对象上。但是，还有一些额外工作，例如一对多和多对多，欠缺这些功能。I found this write up for one-to-many: http://briancarper.net/blog/493/这里提到了一对多。Which I'm not sure I agree with; it appears to be assuming that both tables are pulled from the database and then the joined table is filtered in memory.我不同意“在内存过滤数据”这种做法。 In practice I think the sql query would specify the where criteria.So I'm left wondering, is there some fairly obvious way to automatically do one-to-many relations via clojureql or clojure.contrib.sql? The only thing I can think of is something like this (using the typical blog post/comment example):(defn post [id]     @(-> (table :posts)        (select (where :id id))))(defn comments [post_id]    @(-> (table :comments)          (select (where :post_id post_id))))(defn post-and-comments [id]    (assoc (post id) :comments (comments id)))Is there any way to sort of automate this concept or is this as good as it gets?===================There's still no high-level library to create complex relational queries that I know of. There's many ways to tackle this problem (the link you provided is one way) but even if ClojureQL provides a really nice DSL you can build upon, it still miss some important features. Here's a quick and dirty example of a macro that generate imbricated joins:（imbricated，叠瓦状。）这里使用宏来生成表联接代码。(defn parent-id [parent]  (let [id (str (apply str (butlast (name parent))) "_id")]    (keyword (str (name parent) "." id))))(defn child-id [parent child]  (let [parent (apply str (butlast (name parent)))]    (keyword (str (name child) "."  parent "_id"))))(defn join-on [query parent child]  `(join ~(or query `(table ~parent)) (table ~child)         (where          (~'= ~(parent-id parent)               ~(child-id parent child)))))(defn zip [a b] (map #(vector %1 %2) a b))(defmacro include [parent & tables]  (let [pairs (zip (conj tables parent) tables)]    (reduce (fn [query [parent child]] (join-on query parent child)) nil pairs)))With this you could do (include :users :posts :comments) and get this SQL out of it:SELECT users.*,posts.*,comments.*  FROM users  JOIN posts ON (users.user_id = posts.user_id)  JOIN comments ON (posts.post_id = comments.post_id)There's one major issue with this technique though. The main problem is that the returned columns for all tables will be bundled together into the same map.这里的主要问题是，所有表的列都放在同一个map里。 As the column names can't be qualified automatically, it won't work if there's similarly named column in different tables. This also will prevent you from grouping the results without having access to the schema. I don't think there's a way around not knowing the database schema for this kind of things so there's still a lot of work to do. I think ClojureQL will always remain a low-level library, so you'll need to wait for some other higher-level library to exist or create your own.clojureQL只是一个很底层的库。To create such a library, you could always have a look at JDBC's DatabaseMetaData class to provide information about the database schema. I'm still working on a database analyzer for Lobos that use it (and some custom stuff) but I'm still far from starting to work on SQL queries, which I might add in version 2.0.===============================I asked this question quite a while ago, but I ran across the following and decided to add it as an answer in case anyone is interested:http://sqlkorma.com/==============================The "obvious" reason you don't need ORM as such in Clojure is because idiomatic Clojure doesn't have objects, per se.原因是clojure的惯例是很少用对象。The best way to represent data in a Clojure program is as lazy seqs of simple data strutures (maps & vectors). Mapping these to SQL rows is much less complex, and has much less of an impedance mismatch, than full-blown ORM.最佳方式是使用延迟序列，或普通的map和向量来表示数据。Also, regarding the part of your question relating to forming a complex SQL query... reading your code, it doesn't really have any clear advantages over SQL itself. Don't be afraid of SQL! It's great for what it does: relational data manipulation.不要害怕直接使用sql，它是操作关系型数据的很好方式。=============================http://briancarper.net/blog/493/Clojure ORM-ish stuffSuppose I have this:user> (def foo [{:id 1 :foo 123} {:id 2 :foo 456}])#'user/foouser> (def bar [{:foo_id 1 :bar 111} {:foo_id 1 :bar 222}])#'user/barWhat I want is to "join" foo and bar so that each item in foo ends up with a sub-list of bars based on matching key fields.In real life, these lists-of-hash-maps are coming out of a database via clojure.contrib.sql, so this is something I actually want to do pretty often. This is also vaguely similar to what you get out of a Rails-like ORM, where you end up with an object that has lists of sub-objects anywhere you have a one-to-many relationship.Here's how I end up doing this in Clojure:(defn one-to-many  ([xs name ys f]      (for [x xs :let [ys (filter (partial f x) ys)]]        (assoc x name ys))))Now I can do this:user> (pprint (one-to-many foo :bars bar #(= (:id %1) (:foo_id %2))))({:bars ({:foo_id 1, :bar 111} {:foo_id 1, :bar 222}), :id 1, :foo 123} {:bars (), :id 2, :foo 456})And if I define a helper function:(defn key=  ([xkey ykey]     #(= (xkey %1) (ykey %2))))Then I can write it more concisely:user> (pprint (one-to-many foo :bars bar (key= :id :foo_id)));; same as aboveAnd if I have another "table" of data like this:user> (def baz [{:foo_id 1 :baz 555} {:foo_id 2 :baz 999}])#'user/bazThen I can join them all like this:user> (pprint (-> foo                  (one-to-many :bars bar (key= :id :foo_id))                  (one-to-many :bazzes baz (key= :id :foo_id))))({:bazzes ({:foo_id 1, :baz 555}),  :bars ({:foo_id 1, :bar 111} {:foo_id 1, :bar 222}),  :id 1,  :foo 123} {:bazzes ({:foo_id 2, :baz 999}), :bars (), :id 2, :foo 456})This is pretty concise.这是一个很好的选择。 It may be possible to do it in an even more concise way, (if so, do share). If I was willing to adhere to some Rails-y naming convention for my table names and for the id fields in my tables, I could make this shorter by not having to specify the names of the id fields, but I don't want to go there. It's trivial to write similar functions for a one-to-one relationship, or to use a join-table to "join" two tables with a many-to-many relationship.I am happily surprised sometimes by how simple it is to roll my own version of things that previously seemed like dark magic. I used Rails for a long time and it seemed like a crapload of code must have gone into making the ORM work. But four lines of code gets me 75% of what I ever needed Rails' ORM for.This may be more thanks to me opening my eyes a bit than to Clojure being awesome, but either way, I'll take it.November 03, 2009 @ 6:21 PM PST--------FrankQuoth Frank on October 04, 2011 @ 1:57 PM PDTHi Brian,I know this post is old, but I'm curious about something. As a new user and fan of clojure, I keep wondering why there isn't good rails-like functionality in clojure yet. Mainly the concept of defining a "model" or table in clojure code, and from that model, rendering CRUD screens, or forms, and maybe some other db functionality. I use Django in my job, and I love this feature. Do you have any thoughts on the progress of something like this in clojure? I'm asking you because you seem to have the most writing and code related to this subject.Thanks!BrianQuoth Brian on October 04, 2011 @ 2:41 PM PDTProbably the main reason there's no such library is just because no one's written it yet. Clojure is still very young.Java offers ORM libraries of its own, and many devs are probably happy with those. Hibernate isn't too much different than ActiveRecord, though (in my opinion) Hibernate is far more clunky to use, just because Java is like that.Clojure's immutable data structures clash a bit with the traditional concept of an ORM, where objects represent database records and mutating objects mutates your database. An ORM in Clojure will have to look different than that.（mutate，变异。）clojure的数据结构是不可变的。Non-SQL libraries are also popular nowadays, and many people use those, so don't have much need for SQL wrappers.But there are a few libraries already. My completely-out-of-date oyako is one. carte is another. I'm still slowly but surely working on oyako, but other things have sapped up my time to the point where I have been unable to keep it up to date with Clojure development.I have faith that a good ORM-like library for Clojure will show up. Web development (ring, compojure, enlive) is alive and well in Clojure, and a good database library is an itch someone will definitely scratch sooner or later.FrankQuoth Frank on October 04, 2011 @ 2:54 PM PDTOk. Thanks for your response! I was just having a look at Conjure, and it doesn't look too bad, but that's without trying it.=====================http://sqlkorma.com/Clojure is beautiful.It can make SQL beautiful too.Korma is a domain specific language for Clojure that takes the pain out of working with your favorite RDBMS. Built for speed and designed for flexibility, Korma provides a simple and intuitive interface to your data that won't leave a bad taste in your mouth.==oyako==carte==honeysqlhttps://github.com/jkk/honeysqlhttps://github.com/jkk/honeysql/blob/master/README.md