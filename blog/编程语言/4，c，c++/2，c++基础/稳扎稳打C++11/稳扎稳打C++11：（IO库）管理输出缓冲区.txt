稳扎稳打C++11：（IO库）管理输出缓冲区
来源：ilanever.com | 作者：LanPei | 创建时间：2014-5-2 10:10:58
http://ilanever.com/article/sitedetail.html?id=289


使用缓冲区允许操作系统组合程序中的一些操作执行一次写入。由于向设备写入是耗时的，所以使用缓冲区组合多次操作只执行一次写入能够提高性能。
目录
冲掉输出缓冲区
unitbuf控制符
将输入和输出流绑定在一起
每个输出流都控制一个缓冲区（buffer），用于存储程序读取和写入的数据。
使用缓冲区允许操作系统组合程序中的一些操作执行一次写入。由于向设备写入是耗时的，所以使用缓冲区组合多次操作只执行一次写入能够提高性能。
以下条件导致缓冲区被冲向（flush）真实的输出设备或者文件：
程序正常完成。main函数执行return时，所有的输出缓冲区被冲掉。
在一些不确定的时间点上，缓冲区已满时，在写入下个值之前缓冲区会被冲掉。
可以使用endl控制符显示地冲掉缓冲区。
可以使用unitbuf控制符设置流在每次输出操作之后清空缓冲区。默认情况下，cerr被设置为unitbuf，这样向cerr写入后的缓冲区能立即被冲掉。
一个输出流可以绑定到另一个流上。这种情况下，当绑定流读取或写入时，被绑定流的缓冲区会被冲掉。默认情况下，cin和cerr都被绑定到cout上。因此，当读cin或写cerr时都会冲掉cout中的缓冲区。
冲掉输出缓冲区 

用于冲掉输出缓冲区的操作符一共有3个：endl、flush和ends。endl向缓冲区添加一个新行后冲掉缓冲区；flush不添加任何字符直接冲掉流的缓冲区；ends向缓冲区中添加一个null字符后冲掉缓冲区。
#include <iostream>
 
using namespace std;
 
int main()
{
    cout << "hi!" << endl;
    cout << "hi!" << flush;
    cout << "hi!" << ends;
     
    /*
    ENVIRONMENT:
    g++-4.8(64bit)
     
    OUTPUT:
    hi!
    hi!hi!
    */
     
    return 0;
}
unitbuf控制符 

unitbuf让流在每次写入后都冲掉缓冲区。nounitbuf用于还原流的使用。
cout << unitbuf;
cout >> nounitbuf;
将输入和输出流绑定在一起 

当将一个输入流绑定到一个输出流时，任何读取输入流的操作会首先冲掉输出流的缓冲区。
使用tie函数进行绑定。tie函数有两个重载版本：一个版本是没有参数，返回指向被绑定输出流的指针。另一个版本是将输出流的指针作为参数。如果想要解绑定，我们可以传递一个null指针。多个输入流可以绑定在同一个输出流上。
当程序挂掉时，缓冲区不会被冲掉。
现在的文献中多将flush翻译成“刷新”，本人觉得“刷新”不能准确说明flush的作用，“冲走”更为贴切。刷新多为更新到最新状态，而冲走则有清空之意。

