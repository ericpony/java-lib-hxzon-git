（hxzon读书笔记）《SQL反模式》

by hxzon
2013.10.02

hxzon：收益匪浅。

=========
一，存储多值

--
第2章，乱穿马路：使用逗号隔开列表来存储多值。

缺陷：
1，查询困难（只能用like不能用等号）。
2，执行聚合查询困难。
3，约束困难。
4，需要考虑合适的分隔符。
5，字段长度限制值的个数。

解决方案：使用交叉表更优。
优点：
1，容易查询，容易执行聚合查询。
2，能使用约束。
3，不必考虑分隔符，字段长度不限制值的个数。
4，可以在交叉表中添加其他属性。

--
第8章，多列属性：在一个表中用多列来存储多值。

缺陷：
1，查询困难，需要检查多个列。
2，添加和删除值困难，需要检查多个列。
3，确保唯一性困难，需要检查多个列。
4，更改值的个数困难，需新增或删除列。

适用情况：多值的个数是少量，固定的，列的位置和顺序是固定的。

解决方案：使用从属表更优。

========
二，
第3章，单纯的树，另见。

========
--
第6章，实体-属性-值（EAV模式，泛型属性表）

缺陷：
1，查询属性啰嗦复杂。
2，不支持数据完整性，无法声明强制属性，无法使用SQL的数据类型，无法确保引用完整性，无法配置属性名。
3，取一行数据需要使用联接查询。

解决方案1，使用单表继承，所有相关类型都存储在一张表中，用一个列来区分子类型。


解决方案2，使用实体表继承，
缺点1：没有元数据来表明这些子类型之间的关系。
缺点2：在所有对象中（不考虑）进行过滤查找困难，需使用视图等。


解决方案3，使用类表继承，每个子类型表通过外键与基类表相连。


解决方案4，使用半结构化数据类型，使用json格式，存储成一个LOB列，缺点是sql没法处理其中的值。

========
--
第7章，多态关联：一个列连接到不同的父表。

缺陷：
1，不能使用外键约束。

常见查询需求：查找所有对应的父表记录：

select * from a
left join p1 on (p1.id=a.pid and a.type='p1')
left join p2 on (p2.id=a.pid and a.type='p2')

--
解决方案1，使用反向引用，改为原父表指向本表。

--
解决方案2，使用交叉表，为每个父表创建一个独立的交叉表。

优点：移除了type列的依赖，可以确保数据完整性。

缺点：无法限制只关联到一个父行（即不在多个交叉表中被关联）。

查找所有对应的父表记录：

select * from a
left outer join
(ap1 join p1 using(pid)) using(aid)
left outer join
(ap2 join p2 using(pid)) using(aid)
where aid=#aid

--
解决方案3，使用共用的超级表（类似类表继承中的基类表），共用的超级表可以只有一个主键列。

create table superP(
spId serial primary key
)

p1,p2都使用spId（外键）作为自己的主键。

select * from a
left outer join p1 using(spid)
left outer join p2 using(spid)
where a.aid=#aid

优点：能使用外键来确保数据完整性。

========
--
第9章，元数据分裂。

反模式：
1，列来表示维度，多个列分别存储不同范围的值。
2，表来表示维度，多个表分别存储不同范围的值。

混淆了数据和元数据。将数据存储成元数据。
格言：别让数据衍生元数据。

解决方案：
1，使用分区（水平分区，垂直分区）。
2，使用关联表来表示维度。



========
--
第11章，每日新花样：如何使用枚举值。

反模式：使用数据库enum类型。

缺陷：
1，如何查询枚举值。
2，修改枚举值困难（重定义列）。
3，废弃一个选项困难。
4，多个数据库间移植困难。

解决方案：使用检查表（常量表）。

优点：
1，查询枚举值容易。
2，修改枚举值容易。
3，废弃一个选项容易，可增加一个status列，标记为弃用。
4，数据库间移植容易。

========
--
第14章，对未知的恐惧：null问题。

空字符串，空集合（空数组），未知，无意义的值（不能有值）。

null的缺陷：
1，不能在表达式中使用。
2，不能比较。
3，不能在查询参数中使用。

悬空值应该用null来表示。

反模式：将null作为一个普通值处理，或用一个普通值来取代null。

默认值：有些字段无法定义一个合理的默认值，这时只能用null。


========
三，充分使用数据库的功能，避免用程序来完成。

--
第4章，需要ID。

1，尝试使用自然主键，组合键。

hxzon：避免使用易变的自然主键。

2，使用好的命名方式，不要总是使用id这个名字。

--
第5章，不用钥匙的入口。

不要弃用外键，使用外键，让数据库来完成引用完整性，级联更新。

============
第10章，取整错误。

二进制数计算是不精确的。

--
第12章，幽灵文件。

反模式：使用文件系统。

缺陷：
1，delete数据行并没有删除文件本身。
2，不支持事务隔离，不支持回滚操作，不支持数据库备份工具，不支持SQL访问权限设置。

解决方案：尝试使用BLOB来存储文件。

--
第13章，乱用索引：如何优化索引。


--
第15章，模棱两可的分组。

分组结果不能引用非分组列，因为违背单值规则。

解决方案：使用join。

--
第16章，随机选择：如何高效的随机选中1行。

--
第17章，可怜人的搜索引擎。

使用专门的工具（搜索引擎）。

--
第18章，意大利面条式查询。

不要试图总用一条sql完成查询，分而治之。

用sql生成sql。

--
第19章，隐式的列。

select语句明确列出列名，不要使用*。

--
第20章，明文密码。

--
第21章，SQL注入。

--
第22章，伪键洁癖。

不要重用主键。
如果是为显示效果，使用自然主键，或者行号。

--
第23章，非礼勿视。

程序出错时，注意检查数据库api的返回值。打印拼出的sql语句。

--
第24章，外交豁免权。

要有文档，测试，要使用版本控制。

--
第25章，魔豆。

领域模型优于活动记录。

=======
附录A：规范化规则

第1范式：该表必须是一个范式（行，列都没有顺序，不允许重复行，每列都只有一种类型，每行都只有一个值，行没有隐藏组件），同时，该表没有重复组合。

第2范式：

第3范式：所有非关键字列，都必须直接依赖于关键字列。

博伊斯-科德范式：所有列，都必须直接依赖于关键字列。

第4范式：

第5范式：满足博伊斯-科德范式，且没有复合主键。

DK范式（domain-key范式）：

第6范式：消除所有的联接依赖，支持属性的变更历史。一些数据仓库会用到。

附录B：参考书目

1，Joe Celko，2004，Trees and Hierarchies in SQL for Smarties.
2，Joe Celko，2005，SQL Programming Style.
3，Craig Larman，2004，Applying UML and Patterns:an Introduction to Object-Oriented Analysis and Design and Iterative Development.

