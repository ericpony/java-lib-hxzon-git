领域专用语言实战

Debasish Ghosh (作者) 　 郭晓刚 (译者)

http://www.ituring.com.cn/book/836

=======
- 著名博客“Ruminations of a Programmer”作者、ACM高级会员20余年经验总结 
- 多位业内大牛鼎力推荐 
- 全面涵盖5种JVM语言 
- 真正讲透DSL设计与实现


本书是第一本领域专用语言（DSL）的实战图书。
作者积20余年经验，全面、系统地讲解了如何采用DSL驱动的应用程序开发模型，分析了一系列Java、Ruby、Groovy、Scala和Clojure等JVM语言在设计和实现DSL过程的优劣势。
全书分三部分，以金融中介系统为例全面细致介绍DSL的设计、实现与使用。

第一部分（第1章~第3章）详细阐述DSL驱动开发环境的定位，确定其在应用程序架构中的用武之地，
帮助程序员或架构师调整现有的开发工具和技术，使之适应DSL驱动的新范式。

第二部分（第4章~第8章）探讨如何设计优秀的语义模型，使之成为上层语言抽象的有力后盾，
指导开发人员按照优秀的设计原则搭建领域模型。
其中不仅讲解了DSL的实现手法，而且从最基本的技术入手，逐渐深入到高级技术，如元编程、解析器组合子，以及ANTLR、Xtext等开发框架。

第三部分（第9章）主要展望未来趋势，带领大家畅想解析器组合子和DSL工作台技术的未来。 

本书适合领域专用语言的设计、开发和维护人员，同样也适用于领域专家阅读参考。

Debasish Ghosh Anshinsoft公司（http://www.anshinsoft.com）首席技术布道师，
开发者推荐博客“Ruminations of a Programmer”的作者，ACM协会高级会员。
他拥有跨国IT企业20余年工作经验，擅长为各种客户（无论中小型公司还是财富500强企业）交付企业级解决方案，
对自己将软件设计和编程最佳实践制度化而引以为傲，热爱Java、Ruby、Scala、OO及函数式编程，关注DSL和NoSQL数据库。
电子邮件：dghosh@acm.org。Twitter账号：@debasishg。

=========
原书书名	 DSLs in Action
原书书号	978-1935182450
原书国家	美国
原书出版社	Manning
原书页数	376

=========
出版社: 人民邮电出版社; 第1版 (2013年11月1日)
外文书名: DSLs in Action
丛书名: 图灵程序设计丛书
平装: 292页
语种： 简体中文
开本: 16


=========
版权声明	
献词	
序	
前言	
致谢	
关于本书	
关于封面图片	



第一部分 领域专用语言入门	


第1章	初识DSL

1.1 问题域与解答域
1.1.1 问题域
1.1.2 解答域

1.2 领域建模：确立共通的语汇
共通语汇的益处

1.3 初窥DSL
1.3.1	何为DSL
1.3.2 流行的几种DSL
1.3.3	 DSL的结构

1.4 DSL的执行模型

1.5 DSL的分类
1.5.1 内部DSL
1.5.2 外部DSL
1.5.3 非文本DSL

1.6 何时需要DSL
1.6.1	 优点
1.6.2 缺点

1.7 DSL与抽象设计
1.8	小结
1.9 参考文献


第2章 现实中的DSL

2.1 打造首个Java DSL
2.1.1	 确立共通语汇
2.1.2	 用Java完成的首个实现

2.2 创造更友好的DSL
2.2.1	 用XML实现领域的外部化
2.2.2	 Groovy：更具表现力的实现语言
2.2.3	 执行Groovy DSL

2.3 DSL实现模式
2.3.1 内部DSL模式：共性与差异性
2.3.2	 外部DSL模式：共性与差异性

2.4	选择DSL的实现方式
2.5	小结
2.6 参考文献


第3章 DSL驱动的应用程序开发

3.1 探索DSL集成
为什么关心DSL集成

3.2 内部DSL的集成模式
3.2.1	 通过Java 6的脚本引擎进行集成
3.2.2	 通过DSL包装器集成
3.2.3	 语言特有的集成功能
3.2.4	 基于Spring的集成

3.3 外部DSL集成模式

3.4 处理错误和异常
3.4.1 给异常命名
3.4.2 处理输入错误
3.4.3	 处理异常的业务状态

3.5 管理性能表现
3.6 小结
3.7 参考文献



第二部分 实现DSL	


第4章 内部DSL实现模式

4.1 充实DSL“工具箱”

4.2 内嵌式DSL：元编程模式
4.2.1 隐式上下文和灵巧API
4.2.2 利用动态装饰器的反射式元编程
4.2.3 利用buider的反射式元编程
4.2.4 经验总结：元编程模式

4.3 内嵌式DSL：类型化抽象模式
4.3.1 运用高阶函数使抽象泛化
4.3.2 运用显式类型约束建模领域逻辑
4.3.3 经验总结：类型思维

4.4 生成式DSL：通过模板进行运行时代码生成
4.4.1 生成式DSL的工作原理
4.4.2 利用Ruby元编程实现简洁的DSL设计

4.5 生成式DSL：通过宏进行编译时代码生成
4.5.1 开展Clojure元编程
4.5.2 实现领域模型
4.5.3 Clojure宏之美

4.6 小结
4.7 参考文献


第5章 Ruby、Groovy、Clojure 语言中的内部DSL设计

5.1 动态类型成就简洁的DSL
5.1.1 易读
5.1.2 鸭子类型
5.1.3 元编程——又碰面了
5.1.4 为何选择Ruby、Groovy、Clojure

5.2 Ruby语言实现的交易处理DSL
5.2.1 从API开始
5.2.2 来点猴子补丁
5.2.3 设立DSL解释器
5.2.4 以装饰器的形式添加领域规则

5.3 指令处理DSL：精益求精的Groovy实现
5.3.1 指令处理DSL的现状
5.3.2 控制元编程的作用域
5.3.3 收尾工作

5.4 思路迥异的Clojure实现
5.4.1 建立领域对象
5.4.2 通过装饰器充实领域对象
5.4.3 通过REPL进行的DSL会话

5.5 告诫
5.5.1 遵从最低复杂度原则
5.5.2 追求适度的表现力
5.5.3 坚持优秀抽象设计的各项原则
5.5.4 避免语言间的摩擦

5.6 小结
5.7 参考文献


第6章 Scala语言中的内部DSL设计

6.1	为何选择Scala

6.2	迈向Scala DSL的第一步
6.2.1 通过Scala DSL测试Java对象
6.2.2 用Scala DSL作为对Java对象的包装
6.2.3 将非关键功能建模为Scala DSL

6.3 正式启程
6.3.1 语法层面的表现力
6.3.2 建立领域抽象

6.4	制作一种创建交易的DSL
6.4.1 实现细节
6.4.2 DSL实现模式的变化

6.5	用DSL建模业务规则
6.5.1 模式匹配如同可扩展的Visitor模式
6.5.2 充实领域模型
6.5.3 用DSL表达税费计算的业务规则

6.6	把组件装配起来
6.6.1 用trait和类型组合出更多的抽象
6.6.2 使领域组件具体化

6.7	组合多种DSL
6.7.1 扩展关系的组合方式
6.7.2 层级关系的组合方式

6.8	DSL中的Monad化结构

6.9 小结
6.10 参考文献


第7章	外部DSL的实现载体

7.1	解剖外部DSL
7.1.1 最简单的实现形式
7.1.2 对领域模型进行抽象

7.2	语法分析器在外部DSL设计中的作用
7.2.1 语法分析器、语法分析器生成器
7.2.2	语法制导翻译

7.3	语法分析器的分类
7.3.1 简单的自顶向下语法分析器
7.3.2 高级的自顶向下语法分析器
7.3.3 自底向上语法分析器

7.4	工具支持下的DSL开发——Xtext
7.4.1 文法规则和大纲视图
7.4.2 文法的元模型
7.4.3 为语义模型生成代码

7.5	小结
7.6 参考文献


第8章 用Scala语法分析器组合子设计外部DSL

8.1	分析器组合子
8.1.1 什么是分析器组合子
8.1.2	按照分析器组合子的方式设计DSL

8.2	Scala的分析器组合子库
8.2.1 分析器组合子库中的基本抽象
8.2.2 把分析器连接起来的组合子
8.2.3 用Monad组合DSL分析器
8.2.4 左递归DSL语法的packrat分析

8.3	用分析器组合子设计DSL的步骤
8.3.1 第一步：执行文法
8.3.2 第二步：建立DSL的语义模型
8.3.3 第三步：设计Order抽象
8.3.4 第四步：通过函数施用组合子生成AST

8.4	一个需要packrat分析器的DSL实例
8.4.1 待解决的领域问题
8.4.2	定义文法
8.4.3	设计语义模型
8.4.4 通过分析器的组合来扩展DSL语义

8.5	小结
8.6	参考文献



第三部分 DSL开发的未来趋势	

第9章 展望DSL设计的未来

9.1 语言层面对DSL设计的支持越来越充分
9.1.1 对表现力的不懈追求
9.1.2	 元编程的能力越来越强
9.1.3 S表达式取代XML充当载体
9.1.4	 分析器组合子越来越流行

9.2 DSL工作台
9.2.1 DSL工作台的原理
9.2.2 使用DSL工作台的好处

9.3 其他方面的工具支持

9.4 DSL的成长和演化
9.4.1	 DSL的版本化
9.4.2 DSL平稳演化的最佳实践

9.5	小结
9.6	参考文献



附录A	 抽象在领域建模中的角色

A.1	设计得当的抽象应具备的特质
A.1.1	 极简
A.1.2	 精炼
A.1.3	扩展性和组合性

A.2	极简，只公开对外承诺的
A.2.1	 用泛化来保留演化余地
A.2.2	 用子类型化防止实现的泄露
A.2.3 正确实施实现继承

A.3 精炼，只保留自身需要的
A.3.1	 什么是非本质的
A.3.2 非本质复杂性
A.3.3 撇除杂质
A.3.4	 用DI隐藏实现细节

A.4 扩展性提供成长的空间
A.4.1	 什么是扩展性
A.4.2 mixin：满足扩展性的一种设计模式
A.4.3	 用mixin扩展Map
A.4.4	 函数式的扩展性
A.4.5 扩展性也可以临时抱佛脚

A.5 组合性，源自纯粹
A.5.1	 用设计模式满足组合性
A.5.2 回归语言
A.5.3	 副作用和组合性
A.5.4 组合性与并发

A.6	参考文献


附录B 元编程与DSL设计

B.1 DSL中的元编程
B.1.1 DSL实现中的运行时元编程
B.1.2 DSL实现中的编译时元编程

B.2 作为DSL载体的Lisp
B.2.1 Lisp的特殊之处
B.2.2 代码等同于数据
B.2.3 数据等同于代码
B.2.4 简单到只分析列表结构的语法分析器

B.3 参考文献


附录C Ruby语言的DSL相关特性

C.1 Ruby语言的DSL相关特性
C.2 参考文献


附录D Scala语言的DSL相关特性

D.1 Scala语言的DSL相关特性
D.2 参考文献


附录E Groovy语言的DSL相关特性

E.1 Groovy语言的DSL相关特性
E.2 参考文献


附录F Clojure语言的DSL相关特性

F.1 Clojure语言的DSL相关特性
F.2 参考文献


附录G 多语言开发

G.1 对IDE的特性要求
G.2 搭建Java和Groovy的混合开发环境
G.3 搭建Java和Scala的混合开发环境
G.4 常见的多语言开发IDE

