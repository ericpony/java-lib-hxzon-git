（hxzon学习笔记）java nio-org.ronsoft.nioserver源码解读2by hxzon========6，6.1，读取数据：class InputQueueImpl implements InputQueue{	private final BufferFactory bufferFactory;	private final ByteBuffer emptyBuffer;	private ByteBuffer buffer = null;	public InputQueueImpl (BufferFactory bufferFactory)	{		this.bufferFactory = bufferFactory;		emptyBuffer = ByteBuffer.allocate (0).asReadOnlyBuffer();	}	//从channel读取数据。在handlerAdapter.fillInput()中调用。	//如何保证读取到完整的数据？	public synchronized int fillFrom (ByteChannel channel)		throws IOException	{		if (buffer == null) {			buffer = bufferFactory.newBuffer();		}		return channel.read (buffer);//并未读完本次可读的全部数据。为什么不循环读取？	}	// -- not needed by framework	public synchronized boolean isEmpty()	{		return (buffer == null) || (buffer.position () == 0);	}	public synchronized int indexOf (byte b)	{		if (buffer == null) {			return -1;		}		int pos = buffer.position();		for (int i = 0; i < pos; i++) {			if (b == buffer.get (i)) {				return i;			}		}		return -1;	}	public synchronized ByteBuffer dequeueBytes (int count)	{		if ((buffer == null) || (buffer.position() == 0) || (count == 0)) {			return emptyBuffer;		}		int size = Math.min (count, buffer.position());		ByteBuffer result = ByteBuffer.allocate (size);		buffer.flip();		// TODO: Validate this//			result.put (buffer.array(), 0, size);//			buffer.position (size);//			result.position (size);		// TODO: this if() should be replaceable by the above		if (buffer.remaining() <= result.remaining()) {			result.put (buffer);		} else {			while (result.hasRemaining()) {				result.put (buffer.get());			}		}		if (buffer.remaining() == 0) {			bufferFactory.returnBuffer (buffer);			buffer = null;		} else {			buffer.compact();		}		result.flip();		return (result);	}	public void discardBytes (int count)	{		dequeueBytes (count);	}}6.2，写入数据：class OutputQueueImpl implements OutputQueue{	private final BufferFactory bufferFactory;	private final ChannelFacade facade;	private final LinkedList<ByteBuffer> queue;	private ByteBuffer active = null;	public OutputQueueImpl (BufferFactory bufferFactory, ChannelFacade adapter)	{		this.bufferFactory = bufferFactory;		this.facade = adapter;		queue = new LinkedList<ByteBuffer>();	}	public synchronized boolean isEmpty()	{		return (active == null) && (queue.size() == 0);	}	//向channel写入数据。在handlerAdapter.drainOutput()方法中调用。	public synchronized int drainTo (ByteChannel channel) throws IOException	{		int bytesWritten = 0;		while (true) { //循环写入所有数据。			if (active == null) {				if (queue.size() == 0) break;				active = queue.removeFirst();				active.flip();			}			int rc = channel.write (active);			bytesWritten += rc;			if ( ! active.hasRemaining()) {				bufferFactory.returnBuffer (active);				active = null;			}			if (rc == 0) break; //?		}		return bytesWritten;	}	// -- not needed by framework	public synchronized boolean enqueue (ByteBuffer byteBuffer)	{		if (byteBuffer.remaining() == 0) {			return false;		}		if (queue.size() > 0) {			ByteBuffer tail = queue.getLast();			if (tail.hasRemaining()) {				topUpBuffer (tail, byteBuffer);			}		}		while (byteBuffer.hasRemaining()) {			ByteBuffer newBuf = bufferFactory.newBuffer();			topUpBuffer (newBuf, byteBuffer);			queue.addLast (newBuf);		}		facade.modifyInterestOps (SelectionKey.OP_WRITE, 0);//注册写操作		return true;	}	private void topUpBuffer (ByteBuffer dest, ByteBuffer src)	{		if (src.remaining() <= dest.remaining()) {			dest.put (src);		} else {			// TODO: make this more efficient with buffer slice?			while (dest.hasRemaining()) {				dest.put (src.get());			}		}	}}