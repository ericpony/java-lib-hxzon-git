3D游戏编程大师技巧(套装共2册)
拉莫斯(André LaMothe) (作者), 李祥瑞 (译者), 陈武 (译者)

有扫描中文电子版，没有书签。
88.80，已购。3D数学，重点学习。
==========
本书的组织结构
本书由6部分组成。

第一部分——3D游戏编程简介。简要地介绍游戏、Windows和DirectX编程，
将建立一个虚拟计算机接口，用于创建所有的演示程序。

第二部分——3D数学和变换。介绍各种数学概念，创建一个供本书使用的完整数学库。
这部分的最后几章涉及3D图形学、数据结构、相机和线框模式渲染等。

第三部分——基本3D渲染。讨论光照、基本着色、隐藏面消除和3D裁剪。

第四部分——高级3D渲染。讨论纹理映射、高级光照、阴影以及BSP树、入口等空间划分算法等。

第五部分——高级动画、物理建模和优化。介绍动画、运动、碰撞检测、简单物理建模等。
另外，还将讨论层次型建模、加载大型游戏世界和众多的优化技术。

==========
出版社: 人民邮电出版社; 第1版 (2012年7月13日)
外文书名: Tricks of the 3D Game Programming Gurus-Advanced 3D Graphics and Rasterization
丛书名: 游戏设计与开发技术丛书
平装: 1086页
语种： 简体中文
开本: 16

Tricks of the 3D Game Programming Gurus-Advanced 3D Graphics and Rasterization
作者: Andre LaMothe 
出版社: Sams
出版年: 2003-6-2
页数: 1728
定价: USD 59.99
装帧: Paperback
ISBN: 9780672318351

==========
编辑推荐

Amazon.com好评如潮、游戏编程与3D图形学领域必读必备的重量级著作，全面覆盖3D光栅化、算法及实现的高级技术。
姚晓光、史晓明、沙鹰等专业人士重磅推荐。

名人推荐

《3D游戏编程大师技巧》由浅入深地介绍了3D图形学基础知识及其在游戏开发中的应用。本书是《Windows游戏编程大师技巧（第2版）》的姊妹篇，
但是内容专注于3D编程，层次也更深一些。
但作者André LaMothe一向善于把复杂问题简单化，因此，读者可以较为轻松地读懂本书，并掌握3D图形编程的核心技能。 
——腾讯游戏琳琅天上工作室总经理 姚晓光（NPC6）

André LaMothe的这本书立足于3D软件图形编程，讲的不是如何利用现有接口实现，而是如何自行实现的方法。
本书不需要有很深的3D几何知识，通篇会逐步带你学习3D图形学的基础知识和用法，并且拥有很详细的实现细节。
对于希望更深入学习3D图形应用开发的人来说，建议好好读一读这本书。 
——BigWorld高级软件工程师 史晓明（polyrandom）

《3D游戏编程大师技巧》是一部独一无二的书。
与现今充斥市场的各类速成类书籍不同，本书秉承其作者的一贯风格，由浅入深地引领读者进入3D游戏编程的世界，在领会3D游戏编程技巧的同时也打下良好的理论基础。
如果您希望有朝一日自行编写3D游戏和引擎，我推荐您将这本书列入基础必读书单。 
——《Windows游戏编程大师技巧（第2版）》译者 沙鹰

媒体推荐

这是向程序员介绍从零开始创建下一代视频游戏所需技能的一本重要著作，很荣幸应邀为其作序。
从绘制像素开始介绍创建实时3D引擎的著作并不多。
以前，先进技术和Atari公司开发的粗糙游戏形成了鲜明的反差，对此进行反思时发现，我们确实曾致力于提高技术发展水平，但看起来收效甚微。
回顾过去，早期的游戏从技术的角度看根本算不上计算机游戏，它们不过是奇特的信号生成器，是使用计数器和基于布尔逻辑的移位寄存器的状态机，由拼凑而成的MSI（中等规模集成）门组成。
读者可能还记得我于20世纪70年代开发的第一款游戏——Computer Space，它面世的时间比Intel 4004早了4年，比8080早6年。
我曾希望有微处理器来运行它！在那时候，对于任何重要的实时计算而言，典型的时钟速度太慢了。
我们开发的第一款使用微处理器的游戏是Asteriods，即使是这样，仍使用了大量的硬件来支持该程序，因为微处理器不能完成软件的所有工作。
当前，我们正在通向创建照片级图像的道路上迈进，虽然这种目标还未达到。能够动态地创建这样的图像确实令人兴奋。
软件和硬件工具为游戏制作人员提供了非常强大的创建真实感游戏世界、环境和角色的功能。
使用这些功能可以缩短游戏制作周期，增加财富，使开发新的游戏项目成为可能。

André LaMothe不但谙熟这些技术，还有独特的“游戏感”。
多年来，我见过很多精通尖端技术的专家，但缺乏编写优秀游戏必备的游戏感；而其他人有良好的游戏感，却是平庸的程序员。
André不但是真正的游戏大师，还是软件大师，这一点在他撰写的每本著作中都表现得淋漓尽致。
在我们最近合作开发的一个项目中，André对尖端技术的精通、历史知识的广博以及对早期一些默默无闻游戏的了解之深，给我留下了深刻的印象。
更值得一提的是，他竟然只花了19天的时间就为我编写了一款完整的游戏！
了解一些成功案例很容易，但对败笔也了如指掌很难。是的，Atari确实有一些糟糕的败笔，但如大家所知，我们也开发了很多著名的经典游戏。
希望读者喜欢本书，并以此为跳板，在未来开发出让我流连忘返的优秀游戏。
Atari公司创始人
Nolan Bushnell

=======
作者简介
作者：(美国)拉莫斯(André LaMothe) 译者：李祥瑞 陈武

André LaMothe有25年的计算行业从业经验，拥有数学、计算机科学和电子工程等学位，是20岁时就在NASA做研究工作的少数几人之一。
在30岁之前，他在硅谷的众多公司中从事过咨询工作，了解了公司运作，
获得了多种领域的知识，如电信、虚拟现实、机器人技术、编译器设计、3D引擎、人工智能以及计算和工程的其他领域的知识。
他创办的公司Xtreme Game公司一直是自成一体的游戏开发商和发行商。
后来他创办了Xtreme Games Developer Conference(XGDC)，为游戏开发人员提供了费用更低廉的GDC替代品。
他参与了多个项目的开发工作，其中包括eGamezone Networks——一个公平、有趣、没有任何广告的网络游戏分发系统。
他还创建了一家公司——Nurve Networks公司，为在乎价格的消费者和业余爱好者开发手持设备上的视频游戏系统。
最后，他还是世界上最庞大的游戏开发系列丛书的编辑。

=========
序言

游戏编程原理和实践
很久以前，我编写了一本有关游戏编程的图书《Windows游戏编程大师技巧》，终于实现了夙愿——为读者编写一本介绍如何制作游戏的图书。
多年后，我在游戏编程方面的经验更加丰富，思想也更睿智，同时学会了更多游戏编程的技巧。
读者即使没有阅读过《Windows游戏编程大师技巧》，也能读懂本书；
但需要提醒您的是，本书的内容更深，重点为3D游戏编程，要求读者具备众多的背景知识。
本书将续写和弥补《Windows游戏编程大师技巧》没有涉及的内容，进一步探讨3D游戏编程的概念，
在时间和篇幅允许的情况下，尽可能地涵盖3D游戏编程的每个重要主题。
当然，我不会假设读者是位大师级程序员且已经知道如何制作游戏。
本书是为游戏编程新手编写的，针对的读者群是中高级程序员。如果读者不熟悉C/C++编程，势必会在阅读本书的过程中深感迷惘。
市面上有很多优秀的C/C++图书，建议读者参考Stephen Prata或Robert Lafore的著作。在笔者看来，他们是世界上最棒的C/C++图书作者。

当前是有史以来游戏行业最美好的时代。现在的技术足以让您创建出栩栩如生的游戏！
想象一下即将出现的技术，PlayStation 2、Xbox和GameCube都很酷。然而，这些技术掌握起来并不容易，您必须付出艰苦的努力。
当前，游戏编程的难度更高了，为制作游戏必须掌握更多的技能。然而，如果您正阅读这段文字，表明您乐于迎接挑战。
算您找对了地方，阅读本书后，您将能够使用自己编写的软件光栅化模块，制作出支持纹理映射和光照效果的3D PC视频游戏。
另外，您还将理解3D图形学的基本原理，更深入地认识与运用当前和未来的3D硬件。

内容简介

本书的内容极其丰富，涵盖了创建基于Windows 9x/2000的PC游戏所需的全部知识，其中包括以下主题：

《Windows游戏编程大师技巧》中开发的引擎；
Win32编程和DirectX基础知识；
包括四元数在内的高等数学知识；
2D/3D图形学和算法；
3D投影和相机操控；
线框和实心模式渲染；
光照和纹理映射；
高级可见性算法；
3D动画技术。

读者可能会问，本书介绍如何使用3D硬件还是使用代码实现3D软件光栅化模块？
答案是后者。
只有懦弱的人才依赖于3D硬件，真正的游戏程序员能够从头开始编写3D引擎，对这样的工作充满激情，同时知道如何使用3D硬件。
本书将介绍真正的3D游戏编程，具备这些知识后，读者将能够在两三周内学会使用任何3D API。
在作者看来，如果您知道如何编写纹理映射函数和观察系统，使用硬件时将更为得心应手。
另外，您不能假设每台计算机都配置了优秀的3D硬件，这样的时代还没有到来；
只因为计算机没有3D硬件就将其排除在目标市场之外是非常糟糕的，尤其是在您没有数百万的资金，又想进入游戏市场时。
在这种情况下，您将从非3D加速的软件市场着手。
最后，读者肯定对“Windows-DirectX”有些担心。
只要方法得当，Windows编程实际上非常简单、有趣，DOS32编程中的很多问题都不再会出现。
不要将Windows编程视为障碍——它让我们能够将更多的时间花在游戏代码而不是诸如GUI、I/O和图形驱动程序等细节上。
如果想为市面上所有的2D/3D加速硬件编写图形驱动器，就是日夜不停地干也干不完，况且还有声卡、游戏杆等硬件呢。

读者必须具备的知识
本书假定读者有很强的编程技能。如果您不懂如何编写C语言代码，不知道怎样使用编译器，将会在阅读本书时感到相当迷惘。
本书还使用了一些C++代码，这可能会让C语言程序员感到有些担心。不过也不用怕，我在做任何怪异的事情前将提醒读者。
如果您需要C++程序设计的速成课程，可参阅附录D。基本上，本书只有有关DirectX的范例偶尔使用了C++。

然而，我还是决定在本书中稍微多用些C++，因为在游戏编程中，很多东西都是面向对象的，如果将它们设计成C语言风格的结构，简直是悖理逆天。
总之，如果您能够使用C语言进行编程，那很好；如果能够使用C/C++进行编程，阅读本书将完全不成问题。

众所周知，计算机程序是由逻辑和数学计算组成的。3D视频游戏的重点在数学运算，数学在3D图形学中几乎无处不在。
幸运的是，读者只需具备一些基本的代数和几何学知识即可；本书还将介绍有关向量和矩阵的知识。
读者只要知道加、减、乘、除，就可以理解90％以上的内容，虽然不能亲自推导。毕竟，最终的目的只是要能使用其中的代码。


附带光盘的内容
附带光盘包含本书全部的源代码、可执行文件、范例程序、素材、软件程序、音效和技术文章，其目录结构如下。
Tricks 3D\
SOURCE\
T3DIICHAP01\
T3DIICHAP02\
T3DIICHAP16\
TOOLS\
GAMES\
MEDIA\
BITMAPS\
3DMODELS\
SOUND\
DIRECTX\
ARTICLES\
每个主目录都包含您所需的特定数据，具体情况如下。
Tricks 3D：包含其他所有目录的根目录。请阅读README.TXT文件以便了解最后的修改。
SOURCE：按章节顺序收录了书中所有的源代码。只需将整个SOURCE\目录拷贝到硬盘上就可以使用。
TOOLS：收录了各公司慷慨地允许我放入本光盘的演示版程序。
MEDLA：可在您的游戏中随便使用的图像、声音和模型。
DIRECTX：最新版本的DirectX SDK。
GAMES：大量演示了软件光栅化的共享版2D、3D游戏。
ARTICLES：由3D游戏编程领域的许多老手撰写的启迪性文章。

附带光盘包含各种程序和数据，因此没有统一的安装程序，您需要自行安装不同的程序和数据。
然而，在大多数情况下，只需将SOURCE\目录拷贝到硬盘中就可以了。至于其他程序和数据，可以在需要时安装它们。

安装DirectX
附带光盘中最重要的、必须安装的部分是DirectX SDK及其运行阶段文件。
安装程序位于DIRECTX\目录中，该目录中还有一个README.TXT文件，阐明了最后的修改。
注意：必须安装了DirectX 8.1 SDK或更高版本（附带光盘中提供了DirectX 9.0）才能使用本书的源代码。
如果不能确定系统中是否已经安装了最新版本的DirectX SDK，请运行安装程序进行确认。

编译程序
本书的程序是使用Microsoft Visual C++6.0编写的。然而，多数情况下，也可以任何与Win32兼容的编译器进行编译。
尽管如此，我还是推荐使用Microsoft VC++或.NET，因为用它们做这类工作最有效率。
如果您不熟悉您的编译器集成开发环境（IDE），编译Windows程序时肯定会遇到麻烦。
因此，编译程序之前，请务必花些时间来熟悉编译器，至少达到知道如何编译控制台（console）程序“Hello World”的程度。
要编译生成Windows Win32.EXE程序，只需将工程的目标程序设置为Win32.EXE，再进行编译。
然而，要创建DirectX程序，必须在工程中包含DirectX导入库。
您可能认为只要将DirectX库添加到包含路径（Include path）中即可，但这样不行。
为避免麻烦，最好手工将DirectX.LIB文件包含到工程中，.LIB文件位于DirectX SDK安装目录中的LIB\目录下。
这样将不会出现链接错误。在大多数情况下，需要下面这些文件。
DDRAW.LIB：DirectDraw导入库。
DINPUT.LIB：DirectInput导入库。
DINPUT8.LIB：DirectInput8导入库。
DSOUND.LIB：DirectSound导入库。
WINMM.LIB：Windows多媒体扩展库。
具体使用上述文件时，将更详细地介绍它们；当链接器指出“未知符号（Unresolved Symbol）”错误时，请检查是否包含了这些库。
我不想从新手那里再收到有关这方面的电子邮件。
除DirectX.LIB文件外，还需要将DirectX.H文件放到头文件搜索路径中。
另外，请务必将DirectX SDK目录放在搜索路径列表的最前面，
因为很多C++编译器带有旧版本的DirectX，编译器可能在其INCLUDE\目录下找到旧版本的头文件，而使用这些头文件是错误的。
正确的位置是DirectX SDK的包含目录，即DirectX SDK安装目录中的INCLUDE\目录。
最后，如果读者使用的是Borland产品，请务必使用Borland版本的DirectX.LIB文件，它们位于DirectX SDK安装目录中的BORLAND\目录下。

=========
目录

（上册）

第一部分 3D游戏编程简介

第1章 3D游戏编程入门 2

1.1 简介 2
1.2 2D/3D游戏的元素 3
1.2.1 初始化 4
1.2.2 进入游戏循环 4
1.2.3 读取玩家输入 4
1.2.4 执行AI和游戏逻辑 4
1.2.5 渲染下一帧 4
1.2.6 同步显示 5
1.2.7 循环 5
1.2.8 关闭 5

1.3 通用游戏编程指南 7
1.4 使用工具 11
1.4.1 3D关卡编辑器 14
1.4.2 使用编译器 15

1.5 一个3D游戏范例：Raiders 3D 17
1.5.1 事件循环 37
1.5.2 核心3D游戏逻辑 38
1.5.3 3D投影 39
1.5.4 星空 41
1.5.5 激光炮和碰撞检测 41
1.5.6 爆炸 41
1.5.7 玩Raiders3D 41
1.6 总结 41

第2章 Windows和DirectX 简明教程 43

2.1 Win32编程模型 43
2.2 Windows程序的最小需求 44

2.3 一个基本的Windows应用程序 48
2.3.1 Windows类 49
2.3.2 注册Windows类 53
2.3.3 创建窗口 53
2.3.4 事件处理程序 55
2.3.5 主事件循环 59
2.3.6 构建实时事件循环 63

2.4 DirectX和COM简明教程 64
2.4.1 HEL和HAL 65
2.4.2 DirectX基本类 66

2.5 COM简介 67
2.5.1 什么是COM对象 68
2.5.2 创建和使用DirectX COM接口 70
2.5.3 查询接口 70
2.6 总结 72

第3章 使用虚拟计算机进行3D游戏编程 73

3.1 虚拟计算机接口简介 73

3.2 建立虚拟计算机接口 75
3.2.1 帧缓存和视频系统 75
3.2.2 使用颜色 78
3.2.3 缓存交换 80
3.2.4 完整的虚拟图形系统 82
3.2.5 I/O、声音和音乐 82

3.3 T3DLIB游戏控制台 83
3.3.1 T3DLIB系统概述 83
3.3.2 基本游戏控制台 83

3.4 T3DLIB1库 89
3.4.1 DirectX图形引擎体系结构 89
3.4.2 基本常量 89
3.4.3 工作宏 91
3.4.4 数据类型和结构 92
3.4.5 函数原型 95
3.4.6 全局变量 99
3.4.7 DirectDraw接口 100
3.4.8 2D多边形函数 103
3.4.9 数学函数和错误函数 110
3.4.10 位图函数 111
3.4.11 8位调色板函数 115
3.4.12 实用函数 118
3.4.13 BOB（Blitter对象）引擎 119

3.5 T3DLIB2 DirectX输入系统 126
3.6 T3DLIB3声音和音乐库 131
3.6.1 头文件 132
3.6.2 类型 132
3.6.3 全局变量 133
3.6.4 DirectSound API封装函数 133
3.6.5 DirectMusic API封装函数 138

3.7 建立最终的T3D游戏控制台 140
3.7.1 映射真实图形到虚拟接口的非真实图形 141
3.7.2 最终的T3DLIB游戏控制台 143

3.8 范例T3LIB应用程序 152
3.8.1 窗口应用程序 152
3.8.2 全屏应用程序 153
3.8.3 声音和音乐 154
3.8.4 处理输入 154
3.9 总结 157


第二部分 3D数学和变换

第4章 三角学、向量、矩阵和四元数 160

4.1 数学表示法 160
4.2 2D坐标系 161
4.2.1 2D笛卡尔坐标 161
4.2.2 2D极坐标 163
4.3 3D坐标系 165
4.3.1 3D笛卡尔坐标 165
4.3.2 3D柱面坐标 168
4.3.3 3D球面坐标 168

4.4 三角学 170
4.4.1 直角三角形 171
4.4.2 反三角函数 172
4.4.3 三角恒等式 173

4.5 向量 173
4.5.1 向量长度 174
4.5.2 归一化 174
4.5.3 向量和标量的乘法 175
4.5.4 向量加法 176
4.5.5 向量减法 176
4.5.6 点积 177
4.5.7 叉积 179
4.5.8 零向量 180
4.5.9 位置和位移向量 180
4.5.10 用线性组合表示的向量 181

4.6 矩阵和线性代数 182
4.6.1 单位矩阵 183
4.6.2 矩阵加法 184
4.6.3 矩阵的转置 184
4.6.4 矩阵乘法 184
4.6.5 矩阵运算满足的定律 186

4.7 逆矩阵和方程组求解 186
4.7.1 克来姆法则 188
4.7.2 使用矩阵进行变换 190
4.7.3 齐次坐标 191
4.7.4 应用矩阵变换 192

4.8 基本几何实体 198
4.8.1 点 198
4.8.2 直线 199
4.8.3 平面 202

4.9 使用参数化方程 206
4.9.1 2D参数化直线 206
4.9.2 3D参数化直线 208

4.10 四元数简介 213
4.10.1 复数理论 213
4.10.2 超复数 218
4.10.3 四元数的应用 223
4.11 总结 226

第5章 建立数学引擎 227

5.1 数学引擎概述 227
5.1.1 数学引擎的文件结构 228
5.1.2 命名规则 228
5.1.3 错误处理 229
5.1.4 关于C++的最后说明 229

5.2 数据结构和类型 229
5.2.1 向量和点 230
5.2.2 参数化直线 231
5.2.3 3D平面 232
5.2.4 矩阵 233
5.2.5 四元数 236
5.2.6 角坐标系支持 237
5.2.7 2D极坐标 237
5.2.8 3D柱面坐标 238
5.2.9 3D球面坐标 239
5.2.10 定点数 239

5.3 数学常量 240
5.4 宏和内联函数 242
5.4.1 通用宏 246
5.4.2 点和向量宏 246
5.4.3 矩阵宏 247
5.4.4 四元数 249
5.4.5 定点数宏 249

5.5 函数原型 250
5.6 全局变量 253

5.7 数学引擎API清单 253
5.7.1 三角函数 254
5.7.2 坐标系支持函数 255
5.7.3 向量支持函数 258
5.7.4 矩阵支持函数 266
5.7.5 2D和3D参数化直线支持函数 277
5.7.6 3D平面支持函数 281
5.7.7 四元数支持函数 285
5.7.8 定点数支持函数 293
5.7.9 方程求解支持函数 298

5.8 浮点单元运算初步 300
5.8.1 FPU体系结构 301
5.8.2 FPU堆栈 302
5.8.3 FPU指令集 303
5.8.4 经典指令格式 306
5.8.5 内存指令格式 306
5.8.6 寄存器指令格式 307
5.8.7 寄存器弹出指令格式 307
5.8.8 FPU范例 307
5.8.9 FLD范例 308
5.8.10 FST范例 308
5.8.11 FADD范例 310
5.8.12 FSUB范例 312
5.8.13 FMUL范例 313
5.8.14 FDIV范例 314
5.9 数学引擎使用说明 315
游戏控制台 317
5.10 关于数学优化的说明 317
5.11 总结 317

第6章 3D图形学简介 318

6.1 3D引擎原理 318
6.2 3D游戏引擎的结构 319
6.2.1 3D引擎 319
6.2.2 游戏引擎 320
6.2.3 输入系统和网络 320
6.2.4 动画系统 321
6.2.5 碰撞检测和导航系统 324
6.2.6 物理引擎 325
6.2.7 人工智能系统 326
6.2.8 3D模型和图像数据库 327

6.3 3D坐标系 328
6.3.1 模型（局部）坐标 328
6.3.2 世界坐标 331
6.3.3 相机坐标 334
6.3.4 有关相机坐标的说明 341
6.3.5 隐藏物体（面）消除和裁剪 342
6.3.6 透视坐标 347
6.3.7 流水线终点：屏幕坐标 356

6.4 基本的3D数据结构 363
6.4.1 表示3D多边形数据时需要考虑的问题 363
6.4.2 定义多边形 365
6.4.3 定义物体 369
6.4.4 表示世界 373

6.5 3D工具 374
动画数据和运动数据 375
6.6 从外部加载数据 375
6.6.1 PLG文件 375
6.6.2 NFF文件 378
6.6.3 3D Studio文件 381
6.6.4 Caligari COB文件 387
6.6.5 Microsoft DirectX .X文件 389
6.6.6 3D文件格式小结 389

6.7 基本刚性变换和动画 389
6.7.1 3D平移 389
6.7.2 3D旋转 390
6.7.3 3D变形 392

6.8 再看观察流水线 393
6.9 3D引擎类型 394
6.9.1 太空引擎 394
6.9.2 地形引擎 395
6.9.3 FPS室内引擎 396
6.9.4 光线投射和体素引擎 397
6.9.5 混合引擎 398
6.10 将各种功能集成到引擎中 399
6.11 总结 399

第7章 渲染3D线框世界 400

7.1 线框引擎的总体体系结构 400
7.1.1 数据结构和3D流水线 401
7.1.2 主多边形列表 403
7.1.3 新的软件模块 406

7.2 编写3D文件加载器 406
7.3 构建3D流水线 414
7.3.1 通用变换函数 414
7.3.2 局部坐标到世界坐标变换 420
7.3.3 欧拉相机模型 423
7.3.4 UVN相机模型 426
7.3.5 世界坐标到相机坐标变换 437
7.3.6 物体剔除 440
7.3.7 背面消除 444
7.3.8 相机坐标到透视坐标变换 446
7.3.9 透视坐标到屏幕（视口）坐标变换 451
7.3.10 合并透视变换和屏幕变换 455

7.4 渲染3D世界 457
7.5 3D演示程序 461
7.5.1 单个3D三角形 461
7.5.2 3D线框立方体 464
7.5.3 消除了背面的3D线框立方体 466
7.5.4 3D坦克演示程序 467
7.5.5 相机移动的3D坦克演示程序 470
7.5.6 战区漫步演示程序 472
7.6 总结 476


（下册）

第三部分 基本3D渲染

第8章 基本光照和实体造型 478

8.1 计算机图形学的基本光照模型 478
8.1.1 颜色模型和材质 480
8.1.2 光源类型 487

8.2 三角形的光照计算和光栅化 493
8.2.1 为光照做准备 497
8.2.2 定义材质 498
8.2.3 定义光源 502

8.3 真实世界中的着色 507
8.3.1 16位着色 507
8.3.2 8位着色 507
8.3.3 一个健壮的用于8位模式的RGB模型 508
8.3.4 一个简化的用于8位模式的强度模型 511
8.3.5 固定着色 515
8.3.6 恒定着色 517
8.3.7 Gouraud着色概述 533
8.3.8 Phong着色概述 535

8.4 深度排序和画家算法 535
8.5 使用新的模型格式 540
8.5.1 分析器类 540
8.5.2 辅助函数 543
8.5.3 3D Studio MAX ASCII格式.ASC 546
8.5.4 TrueSpace ASCII.COB格式 548
8.5.5 Quake II二进制.MD2格式概述 557

8.6 3D建模工具简介 558
8.7 总结 561

第9章 插值着色技术和仿射纹理映射 562

9.1 新T3D引擎的特性 562
9.2 更新T3D数据结构和设计 563
9.2.1 新的#defines 564
9.2.2 新增的数学结构 566
9.2.3 实用宏 567
9.2.4 添加表示3D网格数据的特性 568
9.2.5 更新物体结构和渲染列表结构 574
9.2.6 函数清单和原型 577

9.3 重新编写物体加载函数 583
9.3.1 更新.PLG/PLX加载函数 584
9.3.2 更新3D Studio .ASC加载函数 595
9.3.3 更新Caligari .COB加载函数 596

9.4 回顾多边形的光栅化 601
9.4.1 三角形的光栅化 601
9.4.2 填充规则 604
9.4.3 裁剪 606
9.4.4 新的三角形渲染函数 607
9.4.5 优化 612

9.5 实现Gouraud着色处理 613
9.5.1 没有光照时的Gouraud着色 614
9.5.2 对使用Gouraud Shader的多边形执行光照计算 624

9.6 基本采样理论 632
9.6.1 一维空间中的采样 632
9.6.2 双线性插值 634
9.6.3 u和v的插值 635
9.6.4 实现仿射纹理映射 637

9.7 更新光照/光栅化引擎以支持纹理 640
9.8 对8位和16位模式下优化策略的最后思考 645
9.8.1 查找表 645
9.8.2 网格的顶点结合性 646
9.8.3 存储计算结果 646
9.8.4 SIMD 647
9.9 最后的演示程序 647
Raider 3D II 648
9.10 总结 651

第10章 3D裁剪 652

10.1 裁剪简介 652
10.1.1 物体空间裁剪 652
10.1.2 图像空间裁剪 655

10.2 裁剪算法 656
10.2.1 有关裁剪的基本知识 657
10.2.2 Cohen-Sutherland裁剪算法 661
10.2.3 Cyrus-Beck/梁友栋-Barsky裁剪算法 662
10.2.4 Weiler-Atherton裁剪算法 665
10.2.5 深入学习裁剪算法 667

10.3 实现视景体裁剪 667
10.3.1 几何流水线和数据结构 669
10.3.2 在引擎中加入裁剪功能 670

10.4 地形小议 691
10.4.1 地形生成函数 692
10.4.2 生成地形数据 700
10.4.3 沙地汽车演示程序 700
10.5 总结 704

第11章 深度缓存和可见性 705

11.1 深度缓存和可见性简介 705
11.2 z缓存基础 708
11.2.1 z缓存存在的问题 709
11.2.2 z缓存范例 709
11.2.3 平面方程法 711
11.2.4 z坐标插值 713
11.2.5 z缓存中的问题和1/Z缓存 714
11.2.6 一个通过插值计算z和1/z的例子 715

11.3 创建z缓存系统 718
11.4 可能的z缓存优化 734
11.4.1 使用更少的内存 734
11.4.2 降低清空z缓存的频率 734
11.4.3 混合z缓存 736
11.5 z缓存存在的问题 736
11.6 软件和z缓存演示程序 736
11.6.1 演示程序I：z缓存可视化 737
11.6.2 演示程序II：Wave Raider 738
11.7 总结 743


第四部分 高级3D渲染

第12章 高级纹理映射技术 746

12.1 纹理映射——第二波 746
12.2 新的光栅化函数 754
12.2.1 最终决定使用定点数 754
12.2.2 不使用z缓存的新光栅化函数 755
12.2.3 支持z缓存的新光栅化函数 758

12.3 使用Gouruad着色的纹理映射 759
12.4 透明度和alpha混合 765
12.4.1 使用查找表来进行alpha混合 766
12.4.2 在物体级支持alpha混合功能 778
12.4.3 在地形生成函数中加入alpha支持 784

12.5 透视修正纹理映射和1/z缓存 786
12.5.1 透视纹理映射的数学基础 787
12.5.2 在光栅化函数中加入1/z缓存功能 793
12.5.3 实现完美透视修正纹理映射 799
12.5.4 实现线性分段透视修正纹理映射 803
12.5.5 透视修正纹理映射的二次近似 808
12.5.6 使用混合方法优化纹理映射 812

12.6 双线性纹理滤波 814
12.7 mipmapping和三线性纹理滤波 819
12.7.1 傅立叶分析和走样简介 819
12.7.2 创建mip纹理链 822
12.7.3 选择mip纹理 830
12.7.4 三线性滤波 836

12.8 多次渲染和纹理映射 837
12.9 使用单个函数来完成渲染工作 837
12.9.1 新的渲染场境 838
12.9.2 设置渲染场境 840
12.9.3 调用对渲染场境进行渲染的函数 842
12.10 总结 851

第13章 空间划分和可见性算法 852

13.1 新的游戏引擎模块 852
13.2 空间划分和可见面判定简介 852

13.3 二元空间划分 856
13.3.1 平行于坐标轴的二元空间划分 857
13.3.2 任意平面空间划分 858
13.3.3 使用多边形所在的平面来划分空间 858
13.3.4 显示/访问BSP树中的每个节点 861
13.3.5 BSP树数据结构和支持函数 863
13.3.6 创建BSP树 865
13.3.7 分割策略 868
13.3.8 遍历和显示BSP树 876
13.3.9 将BSP树集成到图形流水线中 886
13.3.10 BSP关卡编辑器 887
13.3.11 BSP的局限性 897
13.3.12 使用BSP树的零重绘策略 897
13.3.13 将BSP树用于剔除 899
13.3.14 将BSP树用于碰撞检测 906
13.3.15 集成BSP树和标准渲染 907

13.4 潜在可见集 912
13.4.1 使用潜在可见集 913
13.4.2 潜在可见集的其他编码方法 914
13.4.3 流行的PVS计算方法 915

13.5 入口 917
13.6 包围体层次结构和八叉树 919
13.6.1 使用BHV树 921
13.6.2 运行性能 922
13.6.3 选择策略 923
13.6.4 实现BHV 924
13.6.5 八叉树 931

13.7 遮掩剔除 932
13.7.1 遮掩体 933
13.7.2 选择遮掩物 934
13.7.3 混合型遮掩物选择方法 934
13.8 总结 934

第14章 阴影和光照映射 935

14.1 新的游戏引擎模块 935
14.2 概述 935

14.3 简化的阴影物理学 936
14.4 使用透视图像和广告牌来模拟阴影 939
14.4.1 编写支持透明功能的光栅化函数 941
14.4.2 新的库模块 944
14.4.3 简单阴影 945
14.4.4 缩放阴影 947
14.4.5 跟踪光源 950
14.4.6 有关模拟阴影的最后思考 953

14.5 平面网格阴影映射 954
14.5.1 计算投影变换 954
14.5.2 优化平面阴影 957

14.6 光照映射和面缓存技术简介 958
14.6.1 面缓存技术 960
14.6.2 生成光照图 960
14.6.3 实现光照映射函数 961
14.6.4 暗映射（dark mapping） 963
14.6.5 光照图特效 964
14.6.6 优化光照映射代码 964

14.7 整理思路 965
14.8 总结 965


第五部分 高级动画、物理建模和优化

第15章 3D角色动画、运动和碰撞检测 968

15.1 新的游戏引擎模块 968
15.2 3D动画简介 968

15.3 Quake II .MD2文件格式 969
15.3.1 .MD2文件头 971
15.3.2 加载Quake II .MD2文件 979
15.3.3 使用.MD2文件实现动画 987
15.3.4 .MD2演示程序 995

15.4 不基于角色的简单动画 996
15.4.1 旋转运动和平移运动 997
15.4.2 复杂的参数化曲线移动 998
15.4.3 使用脚本来实现运动 999

15.5 3D碰撞检测 1001
15.5.1 包围球和包围圆柱 1001
15.5.2 使用数据结构来提高碰撞检测的速度 1003
15.5.3 地形跟踪技术 1003
15.6 总结 1004

第16章 优化技术 1005

16.1 优化技术简介 1005
16.2 使用Microsoft Visual C++和Intel VTune剖析代码 1006
16.2.1 使用Visual C++进行剖析 1006
16.2.2 分析剖析数据 1008
16.2.3 使用VTune进行优化 1009

16.3 使用Intel C++编译器 1015
16.3.1 下载Intel的优化编译器 1015
16.3.2 使用Intel编译器 1015
16.3.3 使用编译器选项 1016
16.3.4 手工为源文件选择编译器 1017
16.3.5 优化策略 1017

16.4 SIMD编程初步 1017
16.4.1 SIMD基本体系结构 1019
16.4.2 使用SIMD 1019
16.4.3 一个SIMD 3D向量类 1030

16.5 通用优化技巧 1036
16.5.1 技巧1：消除_ftol() 1036
16.5.2 技巧2：设置FPU控制字 1036
16.5.3 技巧3：快速将浮点变量设置为零 1037
16.5.4 技巧4：快速计算平方根 1038
16.5.5 技巧5：分段线性反正切 1038
16.5.6 技巧6：指针递增运算 1039
16.5.7 技巧7：尽可能将if语句放在循环外面 1039
16.5.8 技巧8：支化（branching）流水线 1040
16.5.9 技巧9：数据对齐 1040
16.5.10 技巧10：将所有简短函数都声明为内联的 1040
16.5.11 参考文献 1040
16.6 总结 1040


第六部分 附录

附录A 光盘内容简介 1042

附录B 安装DirectX和使用Visual C/C++ 1044
B.1 安装DirectX 1044
B.2 使用Visual C/C++编译器 1044
B.3 编译提示 1045

附录C 三角学和向量参考 1047
C.1 三角学 1047
C.2 向量 1049
C.2.1 向量长度 1050
C.2.2 归一化 1050
C.2.3 标量乘法 1051
C.2.4 向量加法 1052
C.2.5 向量减法 1052
C.2.6 点积 1053
C.2.7 叉积 1054
C.2.8 零向量 1055
C.2.9 位置向量 1055
C.2.10 向量的线性组合 1056

附录D C++入门 1057
D.1 C++是什么 1057
D.2 必须掌握的C++知识 1059
D.3 新的类型、关键字和约定 1059
D.3.1 注释符 1059
D.3.2 常量 1060
D.3.3 引用型变量 1060
D.3.4 即时创建变量 1061
D.4 内存管理 1062
D.5 流式输入/输出 1062
D.6 类 1064
D.6.1 新结构 1064
D.6.2 一个简单的类 1065
D.6.3 公有和私有 1065
D.6.4 类的成员函数（方法） 1066
D.6.5 构造函数和析构函数 1067
D.6.6 编写构造函数 1068
D.6.7 编写析构函数 1070
D.7 域运算符 1071
在类外部定义成员函数 1071
D.8 函数和运算符重载 1072
D.9 基本模板 1074
D.10 异常处理简介 1075
异常处理的组成部分 1076
D.11 总结 1078

附录E 游戏编程资源 1079
E.1 游戏编程和新闻网站 1079
E.2 下载站点 1079
E.3 2D/3D引擎 1080
E.4 游戏编程书籍 1080
E.5 微软公司的Direct X 多媒体展示 1081
E.6 新闻组 1081
E.7 跟上行业的步伐 1081
E.8 游戏开发杂志 1081
E.9 Quake资料 1082
E.10 免费模型和纹理 1082
E.11 游戏网站开发者 1082

附录F ASCII码表 1083



