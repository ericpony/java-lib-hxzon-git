领域驱动设计与模式实战
~ 尼尔森(Jimmy Nilsson) (作者), 赵俐 (译者), 马燕新 (译者), 等 (译者) 

有中文版电子书。
===========
出版社: 人民邮电出版社; 第1版 (2009年11月1日)
外文书名: Applying Domain-driven Design and Patterns
丛书名: 图灵程序设计丛书
平装: 354页
语种： 简体中文
开本: 16
ISBN: 7115212775, 9787115212771
----
编辑推荐

《领域驱动设计与模式实战》：.NET开发人员必读之作，带领读者踏上领域驱动设计世界的实用、博学之旅。
《企业应用架构模式》与《领域驱动设计》两大名著精髓的实战演练。
不仅足够详细地解释了基本思想，而且将一系列思想综合到一起，帮助开发人员从头到位了解整个路线。
教你穿越业务层、数据层和UI层之间重重障碍，打通任督二脉。

Martin Fowler和Eric Evans两位大师联袂推荐。
模式、领域驱动设计和测试驱动开发赋予架构师和开发人员前所未有的能力。使他们能够创建功能强大、健壮且可维护的系统。但是，如何在实际项目中充分发挥这些利器的潜力呢？
《领域驱动设计与模式实战》中，作者将Martin Fowler《企业应用架构模式》和Eric Evans《领域驱动设计》两部经典名著中的思想精髓以及重构、测试驱动开发等技术融会贯通，并通过大量C#实例加以阐释，跨越了领域模型、数据库与UI层之间的障碍。真实展示了创建高质量的企业级应用架构的全部过程。
《领域驱动设计与模式实战》就像是精彩纷呈的旅行见闻，每一处的所思所想都闪耀着智慧的光芒，生动诠释了作者对面向对象开发中各种设计选择的深刻理解。
----
媒体推荐

“本书向读者展示了如何将测试驱动设计、对象-关系映射和领域驱动设计等方法应用于.NET项目……书中介绍的技术在很多开发人员看来是未来软件开发的关键……随着技术越来越强大，复杂度越来越高，理解如何更好地使用技术也变得越来越重要。本书在推进这种理解方面迈出了可贵的一步。”
　　——Martin Fowler，ThoughtWorks公司首席科学家，《重构》与《企业应用架构模式》作者

“学习领域驱动设计的最好方法是坐在一位友好、耐心且经验丰富的从业者身边，一步一步地共同研究问题。阅读本书正是这种体验。”
　　——Eric Evans，领域驱动设计创始人

----
作者简介

作者：(瑞典)尼尔森(Jimmy Nilsson) 译者：赵俐 马燕新 等

Jimmy Nilsson，资深软件架构师，有超过20年从业经验，2008年在瑞典主要IT媒体评选的全国软件架构师和开发人员排行榜上名列第2。目前担任factor10咨询公司CEO，客户包括爱立信、微软、沃尔沃等。本书是他的代表作，已被翻译为日、俄等多种文字，他的另一部著作.NET Enterprise Design with Visual Basic .NET and SQL Server 2000也获得Amazon 4星半评价。他的博客是http://JimmyNilsson.com/blog/。
================
目录


第一部分 背景知识

第1章 应重视的价值，也是对过去几年的沉重反思

1.1 总体价值

1.2 应重视的架构风格
1.2.1 焦点之一：模型
1.2.2 焦点之二：用例
1.2.3 如果重视模型，就可以使用领域模型模式
1.2.4 慎重处理数据库
1.2.5 领域模型与关系数据库之间的阻抗失配
1.2.6 谨慎处理分布式
1.2.7 消息传递很重要

1.3 对过程的各个组成部分的评价
1.3.1 预先架构设计
1.3.2 领域驱动设计
1.3.3 测试驱动开发
1.3.4 重构
1.3.5 选择一种还是选择组合

1.4 持续集成
1.4.1 解决方案（或至少是正确方向上的一大步）
1.4.2 从我的组织汲取的教训
1.4.3 更多信息

1.5 不要忘记运行机制
1.5.1 有关何时需要运行机制的一个例子
1.5.2 运行机制的一些例子
1.5.3 它不仅仅是我们的过错
1.6 小结

第2章 模式起步

2.1 模式概述
2.1.1 为什么要学习模式
2.1.2 在模式方面要注意哪些事情
2.2 设计模式
2.3 架构模式
2.3.1 示例：层
2.3.2 另一个示例：领域模型模式
2.4 针对具体应用程序类型的设计模式
2.5 领域模式
2.6 小结

第3章 TDD与重构

3.1 TDD
3.1.1 TDD流程
3.1.2 演示
3.1.3 设计效果
3.1.4 问题
3.1.5 下一个阶段

3.2 模拟和桩
3.2.1 典型单元测试
3.2.2 声明独立性
3.2.3 处理困难因素
3.2.4 用测试桩替换协作对象
3.2.5 用模拟对象替换协作对象
3.2.6 设计含义
3.2.7 结论
3.2.8 更多信息

3.3 重构
3.4 小结

第二部分 应用DDD

第4章 新的默认架构

4.1 新的默认架构的基础知识
4.1.1 从以数据库为中心过渡到以领域模型为中心
4.1.2 进一步关注DDD
4.1.3 根据DDD进行分层

4.2 轮廓
4.2.1 领域模型示例的问题/特性
4.2.2 逐个处理特性
4.2.3 到目前为止的领域模型

4.3 初次尝试将UI与领域模型挂接
4.3.1 基本目标
4.3.2 简单UI的当前焦点
4.3.3 为客户列出订单
4.3.4 添加订单
4.3.5 刚才我们看到了什么

4.4 另一个维度
4.4.1 领域模型的位置
4.4.2 孤立或共享的实例
4.4.3 有状态或无状态领域模型实例化
4.4.4 领域模型的完整实例化或子集实例化
4.5 小结

第5章 领域驱动设计进阶

5.1 通过简单的TDD实验来精化领域模型
5.1.1 从Order和OrderFactory的创建开始
5.1.2 一些领域逻辑
5.1.3 第二个任务：OrderRepository+OrderNumber
5.1.4 重建持久化的实体：如何从外部设置值
5.1.5 获取订单列表
5.1.6 该到讨论实体的时候了
5.1.7 再次回到流程上来
5.1.8 总览图
5.1.9 建立OrderRepository的伪实现
5.1.10 简单讨论一下保存
5.1.11 每个订单的总量
5.1.12 历史客户信息
5.1.13 实例的生命周期
5.1.14 订单类型
5.1.15 订单的介绍人

5.2 连贯接口
5.3 小结

第6章 准备基础架构

6.1 将POCO作为工作方式
6.1.1 实体和值对象的PI
6.1.2 是否使用PI
6.1.3 运行时与编译时PI
6.1.4 PI实体/值对象的代价
6.1.5 将PI用于存储库
6.1.6 单组存储库的代价

6.2 对保存场景的处理

6.3 建立伪版本机制
6.3.1 伪版本机制的更多特性
6.3.2 伪版本的实现
6.3.3 影响单元测试

6.4 数据库测试
6.4.1 在每次测试之前重置数据库
6.4.2 在测试运行期间保持数据库的状态
6.4.3 测试之前重置测试所使用的数据
6.4.4 不要忘记不断演变的模式
6.4.5 分离单元测试和数据库调用测试

6.5 查询
6.5.1 单组查询对象
6.5.2 单组查询对象的代价
6.5.3 将查询定位到哪里
6.5.4 再次将聚合作为工具
6.5.5 将规格用于查询
6.5.6 其他查询选择
6.6 小结

第7章 应用规则

7.1 规则的分类

7.2 规则的原则及用法
7.2.1 双向规则检查：可选的（可能的）主动检查，必需的（和自动的）被动检查
7.2.2 所有状态（即使是错误状态）都应该是可保存的
7.2.3 规则应该高效使用
7.2.4 规则应该是可配置的，以便添加自定义规则
7.2.5 规则应与状态放在一起
7.2.6 规则应该具有很高的可测试性
7.2.7 系统应阻止我们进入错的状态

7.3 开始创建API
7.3.1 上下文，上下文，还是上下文
7.3.2 数据库约束
7.3.3 将规则绑定到与领域有关的转换，还是绑定到与基础架构有关的转换
7.3.4 精化原则：所有状态，即使是错误状态，都应该是可保存的

7.4 与持久化有关的基本的规则API的需求
7.4.1 回到已发现的API问题上
7.4.2 问题是什么
7.4.3 我们允许了不正确的转换
7.4.4 如果忘记检查怎么办

7.5 关注与领域有关的规则
7.5.1 需要合作的规则
7.5.2 使用基于集合的处理方法
7.5.3 基于服务的验证
7.5.4 在不应该转换时尝试转换
7.5.5 业务ID
7.5.6 避免问题
7.5.7 再次将聚合作为工具

7.6 扩展API
7.6.1 查询用于设置UI的规则
7.6.2 使注入规则成为可能

7.7 对实现进行精化
7.7.1 一个初步实现
7.7.2 创建规则类，离开最不成熟的阶段
7.7.3 设置规则列表
7.7.4 使用规则列表
7.7.5 处理子列表
7.7.6 一个API改进
7.7.7 自定义
7.7.8 为使用者提供元数据
7.7.9 是否适合用模式来解决此问题
7.7.10 复杂规则又是什么情况

7.8 绑定到持久化抽象
7.8.1 使验证接口成为可插入的
7.8.2 在保存方面实现被动验证的替代解决方案
7.8.3 重用映射元数据

7.9 使用泛型和匿名方法
7.10 其他人都做了什么
7.11 小结

第三部分 应用PoEAA

第8章 用于持久化的基础架构

8.1 持久化基础架构的需求

8.2 将数据存储到哪里
8.2.1 RAM
8.2.2 文件系统
8.2.3 对象数据库
8.2.4 关系数据库
8.2.5 使用一个还是多个资源管理器
8.2.6 其他因素
8.2.7 选择和前进

8.3 方法
8.3.1 自定义手工编码
8.3.2 自定义代码的代码生成
8.3.3 元数据映射（对象关系（O/R）映射工具）
8.3.4 再次选择

8.4 分类
8.4.1 领域模型风格
8.4.2 映射工具风格
8.4.3 起点
8.4.4 API焦点
8.4.5 查询风格
8.4.6 高级数据库支持
8.4.7 其他功能

8.5 另一个分类：基础架构模式
8.5.1 元数据映射：元数据的类型
8.5.2 标识字段
8.5.3 外键映射
8.5.4 嵌入值
8.5.5 继承解决方案
8.5.6 标识映射
8.5.7 操作单元
8.5.8 延迟加载/立即加载
8.5.9 并发控制
8.6 小结

第9章 应用NHibernate

9.1 为什么使用NHibernate

9.2 NHibernate简介
9.2.1 准备
9.2.2 一些映射元数据
9.2.3 一个小的API示例
9.2.4 事务

9.3 持久化基础架构的需求
9.3.1 高级持久化透明
9.3.2 持久化实体的生命周期所需的特定特性
9.3.3 谨慎处理关系数据库

9.4 分类
9.4.1 领域模型风格
9.4.2 映射工具风格
9.4.3 起点
9.4.4 API焦点
9.4.5 查询语言风格
9.4.6 高级数据库支持
9.4.7 其他功能

9.5 另一种分类：基础架构模式
9.5.1 元数据映射：元数据类型
9.5.2 标识字段
9.5.3 外键映射
9.5.4 嵌入值
9.5.5 继承解决方案
9.5.6 标识映射
9.5.7 操作单元
9.5.8 延迟加载/立即加载
9.5.9 并发性控制
9.5.10 额外功能：验证挂钩

9.6 NHibernate和DDD
9.6.1 程序集概览
9.6.2 ISession和存储库
9.6.3 ISession、存储库和事务
9.6.4 得到了什么结果
9.7 小结

第四部分 下一步骤

第10章 博采其他设计技术

10.1 上下文为王
10.1.1 层和分区
10.1.2 分区的原因
10.1.3 限界上下文
10.1.4 限界上下文与分区有何关联
10.1.5 向上扩展DDD项目
10.1.6 为什么对领域模型——SO分区

10.2 SOA简介
10.2.1 什么是SOA
10.2.2 为什么需要SOA
10.2.3 SOA有什么不同
10.2.4 什么是服务
10.2.5 服务中包括什么
10.2.6 深入分析4条原则
10.2.7 再来看一下什么是服务
10.2.8 OO在SOA中的定位
10.2.9 客户-服务器和SOA
10.2.10 单向异步消息传递
10.2.11 SOA如何提高可伸缩性
10.2.12 SOA服务的设计
10.2.13 服务之间如何交互
10.2.14 SOA和不可用的服务
10.2.15 复杂的消息传递处理
10.2.16 服务的可伸缩性
10.2.17 小结

10.3 控制反转和依赖注入
10.3.1 任何对象都不是孤岛
10.3.2 工厂、注册类和服务定位器
10.3.3 构造方法依赖注入
10.3.4 setter依赖注入
10.3.5 控制反转
10.3.6 使用了Spring.NET框架的依赖注入
10.3.7 利用PicoContainer.NET进行自动装配
10.3.8 嵌套容器
10.3.9 服务定位器与依赖注入的比较
10.3.10 小结

10.4 面向方面编程
10.4.1 热门话题有哪些
10.4.2 AOP术语定义
10.4.3 .NET中的AOP
10.4.4 小结
10.5 小结

第11章 关注UI

11.1 提前结语

11.2 模型-视图-控制器模式
11.2.1 示例：Joe的Shoe Shop程序
11.2.2 通过适配器简化视图界面
11.2.3 将控制器从视图解耦
11.2.4 将视图和控制器结合起来
11.2.5 是否值得使用MVC

11.3 测试驱动的Web窗体
11.3.1 背景
11.3.2 一个示例
11.3.3 领域模型
11.3.4 GUI的TDD
11.3.5 Web窗体实现
11.3.6 小结
11.3.7 用NMock创建模拟

11.4 映射和包装
11.4.1 映射和包装
11.4.2 用表示模型来包装领域模型
11.4.3 将表示模型映射到领域模型
11.4.4 管理关系
11.4.5 状态问题
11.4.6 最后的想法
11.5 小结
11.6 结束语

第五部分 附录

附录A 其他领域模型风格
附录B 已讨论的模式的目录


