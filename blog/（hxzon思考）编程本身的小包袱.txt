（hxzon思考）编程本身的小包袱

by hxzon
====
编程里的问题分两种，一种是业务本身的问题，一种是编程本身的问题。
编程语言是工具和原材料，所以，它自身的问题是自找的“小包袱”。
这是我一直在思考的问题，我觉得很有趣。

1，“接口继承”和“实现继承”

接口的意义是用代码本身来表达一种契约。

“实现继承”则是为了代码复用。
用“实现继承”来实现复用，是因为编程语言有缺陷。
我很喜欢scala的“混入”，比实现继承更佳。

1.1，
C++因为支持多重继承，所以会产生菱形继承的问题。
菱形继承问题就是有两种实现都匹配调用规则。
clojure解决这个问题很直接，用prefer明确指明哪个实现优先。

1.2，
层级问题：java通过继承来静态形成层级，
clojure则使用元数据来表达层级。
因此，在clojure里，可以任意地动态地建立层级，不必为了得到层级而继承。
层级只是一种数据分类，而接口是为了订立契约，不是用来表达层级关系的。

2，异常处理

2.1，受检异常vs非受检异常

受检异常的优点是明确标出了抛出哪些异常。

但我一直很痛恨受检异常。
首先，受检异常强迫你在代码中捕获，带来两种“繁琐”：切断了变量的作用域；嵌套try catch。
其次，当不宜或无法立刻处理受检异常时，需要继续往上抛，
这时异常变成方法签名的一部分，后续如果更改就会显得“僵硬”。

非受检异常的缺点是方法签名本身没有明确标明可能抛出的异常。
但我想，有朝一日，ide足够发达的话，不是不可能自动列出所有可能的异常。
非受检异常的优点，就是避免了“受检异常”上述的所有缺点。

相比受检异常的“繁琐”和“僵硬”，“非检查异常”的缺点不足挂齿。

2.2，异常vs返回值

在不支持“多返回值”和元组的语言里，如果有别的值需要返回，就没办法用返回值来表示错误。

我觉得两种方式的本质区别是：
异常允许此刻不检查不处理，留到更合适的上层处理。
返回值则要求立刻检查并处理。
所以我觉得返回值就是“受检异常”的另一种表达方式，但是没有“受检异常”的“繁琐”和“僵硬”的缺点。

我觉得异常更灵活，更简洁。
有人反对异常，因为异常隐藏的中断逻辑。

3，编译型和虚拟机型

go将虚拟机编译进程序当中。

我一直在想的问题是，虚拟机所提供的所有功能，有没有可能不用虚拟机也能提供。
这个问题我还没有想好。

来自别人的说法：

不能提供“所有”，原因是虚拟机运行于用户的电脑（或生产环境），而编译器运行于开发的机器，
所以编译器（和开发人员）可能完全无法预知用户的电脑的配置情况，
编译器只能对有限的硬件猜测做保守的优化。
而虚拟机在安装时，可以精确检测电脑的指令集等性能相关的参数而做优化。

4，数据类型

代码中声明类型，就限制了代码的通用性。
有类型的好处是可以编译检查。
我比较喜欢common lisp的方式，动态类型，但是在需要的地方可以加上类型声明，帮助编译器优化。

5，给一个类（你无法修改）添加方法

支持元编程的语言，做这种事很easy。

给一个类添加方法只是为了直观，不然直接用静态方法就可以了。

scala提供了隐式转换，定义的时候就是静态方法，用的时候像这个类有了你要的方法。

6，多态

多态就是根据数据“类型”，自动调用合适的具体实现。

common lisp支持多重方法，方法中的每个参数都可以特化。

面向对象的多态，只是很受限的多重方法的一个特例。

7，代码复用

静态方法的缺点是不直观。

“实现继承”可以复用方法，但是却产生了层级，本末倒置。
如果语言不支持多继承，则不能从多个类复用方法。

scala的混入是很灵活的多继承，不仅可在类级别混入，也可在实例级别混入。

lisp提供宏，用代码来生成代码，我觉得是终极的武器。

8，dsl，领域专用语言

虽然物质都是原子构成的，但是化学家用原子就太底层了，所以它们用分子。
这就是领域专用语言的好处，和领域里的概念吻合。

9，变量可见性

让变量和函数私有，一是为了屏蔽细节，二是为了避免意外调用。

js没有提供私有可见性，需要一些技巧才能实现私有可见性。

java提供私有可见性，可通过反射绕过。

clojure用元数据来标明私有可见性，这防止你意外调用，但如果你知道自己想干什么，就可以简单而明确地有意绕过。

我觉得编程语言就该这样，防止意外，而不是防止欺骗。

10，鸭子类型

鸭子类型就是有匹配的方法即可，不必实现接口。

实现接口表明遵守契约。
有匹配的方法不代表是遵守契约。

ruby就是鸭子类型。

java，必须实现接口。对于不受控制的类，因为无法让它实现接口，就需要另想别的方式，再次把问题复杂化。

go，也是有匹配方法即可，实现方不必实现接口。
但和ruby不同，go可以事后（且是“另外的”）定义接口，也就是调用方也可定义接口。
但我觉得接口还是应该实现方定义，因为有匹配方法，始终不代表是遵守契约。

clojure的“协议扩展”，可以很轻松的给一个类添加新方法，我觉得明确又灵活，是最佳的。

11，常量

大部分语言都有常量，但是它们提供的常量，都只是运行时不会改变。
但还有一种需求，是运行时统一改变。
在这些语言里只能使用全局变量。
但我觉得这种“统一改变”和普通变量的修改是不同的，
所以需要有一种方式，明确的，而不是意外的，修改这种“全局常量”。
clojure提供了 var 引用类型 和 alter-var-root 函数。

12，js中的with 和 clojure中的doto

js中的with被视为糟粕，因为操作的可能是对象的字段，也可能是外部环境的变量。容易出错。

clojure中的doto，操作的一定是对象。简洁好用。

13，延迟求值

延迟求值在理念上和并发相违背，
并发的目的，就是需要某个值时，它已经准备好。

延迟减少了不必要的计算，有些值可能永远未被用到。
但这不是重点。

延迟求值，在于提供一种假象，所有的值都在那，即便是无限序列。
这一点上，怎么并发都无能为力。

14，common lisp的广义函数 vs clojure的多重方法

（common lisp的多重方法指“真正的”多重方法，即确实对多个参数进行特化。）

common lisp定义广义函数时指定了参数个数，clojure则不指定任何参数（参数由注册的“实现体”决定）。
common lisp的“实现体”在参数上“基于类型”或者“基于某个实例”特化。
因此common lisp的转发只依赖于“实现体”，但是转发只能是“基于类型”或者“基于某个实例”的特化。

clojure定义多重方法时指定转发函数，“实现体”则指定转发值。
因此clojure的转发同时依赖于“转发函数”和“实现体”的转发值，但是转发很灵活，不必是“基于类型”。

想比较下，clojure更灵活。

15，不确定性计算

不确定性计算就是一个函数的返回值是几个可能值中的某一个。
每一个不确定表达式产生一个选择点，不确定性求值器会系统的尝试这些可能值，直到求出答案。
不确定性计算让程序员只提问题要求，不必思考怎么搜索答案。

16，一种数据结构

lisp里面用点对，点对就是一个两元素列表，第二个元素要么为空，要么又是一个点对。
clojure最出色的不是并发，而是它的数据结构思想。
向量，列表，set，映射，都可以转成序列（即点对）。

向量和列表可以看成下标到值的映射，set可以看成元素自身到自身的映射。

所以，clojure的操作，对向量、列表、set、映射都是通用的。

对比起java，映射甚至不是collection的子类，违背人的直觉。

用clojure写代码思想包袱可以很轻，不管你是用map，还是用bean，语法都是一样的。
不必纠结map灵活却性能低，bean性能好但又不够灵活。

数据结构也分两种，业务本身的，编程本身的，所以clojure提供了defrecord和deftype。

16，erlang

在erlang里，本地进程之间，和本地线程与其它主机进程之间的通信是一样的。
所以，一个本地程序，切换模式，就可以分布式运行了。 

17，c

在看c++的设计和演化时，我突然想到，
c本来就是面向机器设计的，不是生产力语言，所以不需要提供各种高级功能。
c的问题在于语法，最明显的一点，
c的声明既有前缀方式又有后缀方式，当两种方式同时用时，看起来就复杂了，
甚至还会出现歧义。出现歧义的时候又必须靠括号解决，更更复杂了。
你每看一遍代码，就得在脑子里语法解析一遍。
如果c当初改用S表达式，那么就可以用语法宏而不是用文本宏来代码生成代码了，
c程序员会不会轻松很多。