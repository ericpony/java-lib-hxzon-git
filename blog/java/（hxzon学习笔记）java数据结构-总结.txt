（hxzon学习笔记）java数据结构-总结by hxzon=========1，ArrayList,LinkedList,Vector的区别？LinkedList使用链表实现。非同步。属于java集合框架。它返回的迭代器是快速失败的。Vector属于java集合框架。它返回的迭代器是快速失败的，而返回的枚举器而不是快速失败的。同步的。========2，HashMap,LinkedHashMap,HashTable的区别？HashMap和HashTable都实现了Map接口，主要的区别有：线程安全性，同步(synchronization)，以及速度。HashMap，可接受null的键和值，非同步。属于java集合框架。它返回的迭代器是快速失败的。HashTable，键和值都必须是非null的。同步的。属于java集合框架。它返回的迭代器是快速失败的。HashTable的enumerator迭代器不是fail-fast的。如果只需要单一线程，那么使用HashMap性能要好过HashTable。如果你使用Java 5或以上的话，请使用ConcurrentHashMap代替HashTable。HashMap不能保证随着时间的推移Map中的元素次序是不变的。LinkedHashMap使用双向链表来保持有序（插入顺序）。非同步的。属于java集合框架。它返回的迭代器是快速失败的。ConcurrentHashMap，键和值都必须是非null的。返回的迭代器是“弱一致性”的，不会“快速失败”。在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。========3，优先级队列（PriprityQueue）优先级队列（PriprityQueue）是一种无界队列，基于优先级堆，它的元素根据自然顺序或者通过实现Comparator接口的自定义排序方式进行排序。优先级队列不是同步的，如果需要保证线程安全那么请使用PriorityBlockingQueue。队列的获取操作如poll(),peek()和element()是访问的队列的头，保证获取的是最小的元素（根据指定的排序规则）。返回的迭代器并不保证提供任何的有序性。优先级队列不允许null元素，否则抛出NullPointException。以上所有就是有关优先级队列的全部，它是一个很特别的类，用在一些特性的情景。记住：BlockingQueue维持的是插入的顺序，如果想维持自定义的顺序，PriorityQueue或者PriorityBlockingQueue是正确的选择，TreeSet提供类似的功能，但是没有类似的检索+移除的方法：poll()。优先级队列提供了O(log(n))时间在出队和入队的方法上，比如：offer()，poll()，add()，但是对于检索操作如：peek()，element()提供的是常量（固定）时间。========4，阻塞队列（BlockingQueue）-1，四种类型的方法（抛出异常，返回null或false，阻塞，超时阻塞）：*		Throws exception Special value Blocks Times out Insert add(e) offer(e) put(e) offer(e, time, unit) Remove remove() poll() take() poll(time, unit) Examine element() peek() （not applicable） （not applicable）-2，不能接受null元素。-3，阻塞队列的实现是线程安全的。但批量操作不保证原子性，例如addAll(c)，可能会加入部分c元素。-4，可选的边界。=======5，ConcurrentLinkedQueue返回的迭代器是“弱一致性”的，不会“快速失败”。size()不是常量操作，返回值也不是完全精确的，如果执行期间别的线程对队列添加或删除了元素。======6，<T> List<T> java.util.Collections.synchronizedList(List<T> list)Returns a synchronized (thread-safe) list backed by the specified list. In order to guarantee serial access, it is critical that all access to the backing list is accomplished through the returned list.It is imperative that the user manually synchronize on the returned list when iterating over it:   List list = Collections.synchronizedList(new ArrayList());      ...  synchronized (list) {      Iterator i = list.iterator(); // Must be in synchronized block      while (i.hasNext())          foo(i.next());  } Failure to follow this advice may result in non-deterministic behavior. The returned list will be serializable if the specified list is serializable.--public static <T> Collection<T> java.util.Collections.unmodifiableCollection(Collection<? extends T> c)仍使用c的迭代器，所以如果c有序，返回的集合仍有序。======7，