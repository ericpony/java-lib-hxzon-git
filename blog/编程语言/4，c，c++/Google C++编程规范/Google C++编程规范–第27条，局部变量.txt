Google C++编程规范–第27条，局部变量
http://roclinux.cn/?p=3471

Google C++编程规范 – 第二十七条 -《局部变量》
本原创文章属于《Linux大棚》博客。
文章作者为roc wu

==

【规范】

将一个变量限制在尽可能小的作用域内，并且要在声明部分初始化变量

【详解】

C++语言本身允许在一个函数的任何位置声明变量。

但是我们鼓励大家将变量声明在尽可能小的范围内，且声明的位置尽量离首次使用的位置越近越好。

这有助于阅读代码的人可以方便的看到变量的声明是什么，变量的类型是什么以及变量初始化的值是什么。

特别需要强调的是，在变量声明的时候就要进行赋值，不要拆成两步。
请看下面的例子：

int i;
i = f();      // 错误；声明和赋值被拆开了
int j = g();  // 正确；声明时便赋值

再看一个例子：

vector v;
v.push_back(1);  // 不建议；声明和赋值被拆开了。
v.push_back(2);

vector v = {1, 2};  // 正确；声明和赋值同时进行

注意，在for语句、if语句和while语句的条件部分声明的变量，是可以继续在同一作用域内使用的，
比如下面例子中for语句的i变量、while语句的p指针：

for (int i = 0; i < 10; ++i) ...

while (const char* p = strchr(str, '/')) str = p + 1;

大括号是切割作用域的元凶之一。
而一个对象变量，就会在离开其作用域的位置进行析构，比如下面的例子：

for (int i = 0; i < 1000000; ++i) {
  Foo f;  // f的构造函数和析构函数会被调用1000000次
  f.DoSomething(i);
} //f对象的作用域仅限大括号内，因此在右大括号处会发生f对象的析构动作。

所以，对于上述情况，应该这样来写：

Foo f;  // f的构造函数和析构函数只会被调用一次
for (int i = 0; i < 1000000; ++i) {
  f.DoSomething(i);
}

谢谢！

