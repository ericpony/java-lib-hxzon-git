《angularjs》第3章-使用AngularJS 进行开发

注释 by hxzon

====
目录：

Project Organization  47
Tools 50
IDEs  50
Running Your Application 51
With Yeoman  51
Without Yeoman  51
Testing with AngularJS 52
Karma  52
Unit Tests 54
End-to-End/Integration Tests  55
端到端集成测试。
Compilation 57
Other Awesome Tools  59
Debugging  59
Batarang 60
Yeoman: Optimizing Your Workflow  64
Installing Yeoman 65
Starting a Fresh AngularJS project  65
Running Your Server  65
Adding New Routes, Views, and Controllers 65
The Testing Story  66
Building Your Project  66
Integrating AngularJS with RequireJS  67

====
Developing in AngularJS

By now we have delved a little bit into the cogs that make up AngularJS. We now know
how to get data from the user into our application, how to display text, and how to do
some funky stuff with validation, filtering, and even changing the DOM. But how do
we put it all together?

如何将它们组合在一起？

In this chapter, we will cover:

• How to lay out your AngularJS app for rapid development
• Starting your server to see your AngularJS app in action
• Writing and running your unit and scenario tests using Karma
• Compiling and minifying your AngularJS app for production deployment
• Debugging your AngularJS app using Batarang
• Simplifying your development workflow (from creating new files to running your
application and tests)
• Integrating your AngularJS project with RequireJS, a dependency management library
和requireJs集成。

This chapter aims to give you a 20,000-foot view of how to possibly lay out your 
AngularJS app. We won’t go into the actual app itself. That is for Chapter 4, which dives
into a sample application that uses and shows off various AngularJS features.

====
Project Organization
项目组织结构。

We recommend seeding your project using Yeoman, which will create all the necessary
files to bootstrap your AngularJS application.

建议使用yeoman，会帮你创建文件夹结构。

Yeoman is a robust tool comprised of multiple frameworks and client-side libraries. It
provides a rapid development environment by automating some routine tasks needed
to bootstrap and develop your application. We’ll go through a whole section on how to
install and use Yeoman this chapter, but until then, we will briefly touch upon Yeoman
commands as alternatives to manually performing those operations.
本章有一节会讲解yeoman。

We will also detail the various pieces involved in case you decide not to use Yeoman
because Yeoman does have some issues on Windows computers, and getting it set up
can be slightly challenging.

For those not using Yeoman, we will take a look at a sample application structure (which
can be found in the  chapter3/sample-app folder in our GitHub examples repository),
which follows the recommended structure, as well as the structure generated by Yeoman.
可参看github上的文件夹结构。

The files in the application can be broken into the following categories:

--
JS source files
js脚本文件夹。

Take a look at the app/scripts folder. This is where all your JS source code lives. One
main file (app/scripts/app.js) will set up the the Angular module and the routes for
your application.

In addition, there is a separate folder—app/scripts/controller—which houses the
individual controllers. Controllers provide the action and publish data to the scope
which will then be displayed in the view. Usually, they correspond one to one with
the view.

Directives, filters, and services can also be found under app/scripts, either as 
complete files (directives.js, filters.js, services.js), or individually, if they are nice and
complex.

--
HTML Angular template files
模板文件夹。

Now, every AngularJS partial template that Yeoman creates can be found in the
app/views folder. This will mirror our  app/scripts/controller folder for the most part.
There is one other important Angular template file, which is the main  app/
index.html. This is responsible for sourcing the AngularJS source files, as well as
any source files you create for your application.
首页。

If you end up creating a new JS file, ensure that you add it to the index.html, and
also update the main module and the routes (Yeoman does this for you as well!).
如果创建了新的js文件，需要加到index.html中。（？）

--
JS library dependencies
js依赖文件夹。

Yeoman provides you the app/scripts/vendor folder for all JS source dependencies.
Want to use Underscore or  SocketIO in your application? No problem—add the
dependency to the vendor folder (and your index.html!) and start referencing it in
your application.

--
Static resources
静态资源文件夹。

You are creating an HTML application in the end, and it is a given that you will
have CSS and image dependencies that you need served as part of your application.

The  app/styles and  app/img folders are for this very purpose. Just add what you need
and start referring to them (with the correct relative paths, of course!) in your
application.

Yeoman does not create the app/img path by default.

--
Unit tests
单元测试文件夹。

Testing is super important, and totally effortless when it comes to AngularJS. The
test/spec folder should mirror your  app/scripts in terms of tests. Each file should
have a mirror spec file which has its unit tests. The seed creates a stub for each
controller file, under test/spec/controllers, with the same name as the original controller. 
These are Jasmine-style specs, which describe a specification for each 
expected behavior of the controller.

--
Integration tests
集成测试文件夹。

AngularJS comes with end-to-end testing support built right into the library. All
your E2E tests, in the form of Jasmine specs, are saved under the folder tests/e2e.
Yeoman does not create the tests/folder by default.

While the E2E tests might look like Jasmine, they are not. They are
functions that are executed asynchronously, in the future, by the
Angular Scenario Runner. So don’t expect to be able to do stuff like
you would in a normal Jasmine test (like console.log on the value
of a repeater).

There is also a simple HTML file generated that can be opened by itself in a browser
to run the tests manually. Yeoman doesn’t generate the stubs for these yet, but they
follow a similar style to the unit tests.

--
Configuration files
配置文件。

There are two configuration files needed. The first one, karma.conf.js, is generated
by Yeoman for you and is used to run the unit tests. The second one, which Yeoman
does not generate yet, is the karma.e2e.conf.js. This is used to run the scenario tests.
There is a sample file at the end of this chapter in the RequireJS integration section.

The config details the dependencies and the files to use when running the unit tests
using Karma. By default, it runs the Karma server at port 9876.

You might ask: how do I run my application? What about unit tests? How do I even
write these various pieces that you are talking about?

Don’t worry, young grasshopper, all in due time. In this chapter, we will deal with setting
up your project and development environment so that things can move along at a rapid
pace once we do start churning out some awesome code. What code you write, and how
it hooks together to form your final awesome application, will come in the next few
chapters.

（2014.2.21）
====
Tools

AngularJS is just one part of your toolkit that allows you to actually develop your web
pages. In this section, we will take a look at various tools that you would use to ensure
efficient and fast development, from IDEs to test runners to debuggers.
IDEs
Let’s start with how you actually edit your source code. There is a whole slew of JavaScript
editors out there, both free and paid. Things have come a long way from the days when
Emacs or Vi was the best option to develop in JS. Nowadays, IDEs come with syntax
highlighting, auto-completion, and so much more, and it might be worth your while to
give one a whirl. So which one should you use?
WebStorm. If you don’t mind shelling out a few bucks (though there is a free 30-day
trial!), then  WebStorm by JetBrainsoffers one of the most comprehensive web devel‐
opment platforms in recent times. It has features that were only previously available for
typed languages, including code-completion (browser specific at that, as shown in
Figure 3-1), code navigation, syntax, error highlighting, and out-of-the-box support for
multiple libraries and frameworks. In addition, there is some very nice integration for
debugging JavaScript right from the IDE while it is executing in Chrome.
Figure 3-1. Browser specific code completion in WebStorm
The biggest reason you should seriously consider W ebStorm for AngularJS develop‐
ment is that it is one of the only IDEs that has an AngularJS plug-in. The plug-in gives
you auto-complete support for AngularJS HTML tags right in your HTML templates.
In addition, one of the coolest things it supports is the concept of live templates. These
are pre-formed templates for common code snippets that you would otherwise type
from scratch every time. So instead of typing the following:
directive('$directiveName$', function factory($injectables$) {
var directiveDefinitionObject = {
$directiveAttrs$
compile: function compile(tElement, tAttrs, transclude) {
$END$
return function (scope, element, attrs) {
}
}
};
return directiveDefinitionObject;
});
in W ebStorm, you can just type:
ngdc
and press the  tabkey to get the same thing. This is just one of the many code-completions
the plug-in provides.
Running Your Application
Now let’s talk about how we get to the payload of all that we do—seeing your application
live, in the browser. To really get a feel for how the application would work, we need to
have a web server serving our HTML and JavaScript code. I will explore two ways: one
very simple way of running your application with Yeoman, and another not so easy, but
just as good, method without Yeoman.
With Yeoman
Yeoman makes it simple for you to start a web server and serve all your static and
AngularJS-related files. Just execute the following command:
yeoman server
and it will start up a server and open your browser with the main page of your AngularJS
application. It will even refresh the browser whenever you make changes to your source
code. How cool is that?
Without Yeoman
Without Yeoman, you would need to configure a web server to serve all the files in your
main directory. If you don’t know an easy way to do that, or don’t want to waste time
creating your own web server, you can quickly write a simple web server using ExpressJS
(as simple as npm install -g express to get it) in Node. It might look something like
the following:
// available at chapter3/sample-app/web-server.js
var express = require("express"),
app  = express(),
port  = parseInt(process.env.PORT, 10) || 8080;

app.configure(function(){
app.use(express.methodOverride());
app.use(express.bodyParser());
app.use(express.static(__dirname + '/'));
app.use(app.router);
});
app.listen(port);
console.log('Now serving the app at http://localhost:' + port + '/app');
Once you have the file, you can run the file using Node, by executing the following
command:
node web-server.js
and it will start up the server on port 8080 (or one of your own choosing).
Alternatively, with Python in the folder with your application you could run:
python -m SimpleHTTPServer
Whichever way you decide to proceed, once you have the server configured, up and
running, navigate to the following:
http://localhost:[port-number]/app/index.html
in your browser to see the application you have just created. Do note that you will have
to manually refresh your browser to see the changes, unlike with Yeoman.
Testing with AngularJS
We have said it before (even right in this chapter), and we will say it again: testing is
essential, and AngularJS makes it simple to write the right kind of unit and integration
tests. While AngularJS plays nicely with multiple test runners, we strongly believe that
Karmatrumps most of them providing the most robust, solid, and insanely fast test
runner for all your needs.
Karma
Karma’s main reason for existence is to make your test-driven development (TDD)
workflow simple, fast, and fun. It uses NodeJSand SocketIO (you don’t need to know
what they are, just assume that they are awesome, cool libraries) to allow running your
code, and tests in multiple browsers at insanely fast speeds. Go find out more at https://
github.com/vojtajina/karma/.
TDD: An Intro
Test-driven development, or TDD, is an AGILE methodology that flips the development
lifecycle by ensuring that tests are written first, before the code is implemented, and that
tests drive the development (and are not just used as a validation tool).
The tenets of TDD are simple:
• Code is written only when there is a failing test that requires the code to pass
• The bare minimum amount of code is written to ensure that the test passes
• Duplication is removed at every step
• Once all tests are passing, the next failing test is added for the next required func‐
tionality .
These simple rules ensure that:
• Your code develops organically, and that every line of code written is purposeful.
• Your code remains highly modular, cohesive, and reusable (as you need to be able
to test it).
• You provide a comprehensive array of tests to prevent future breakages and bugs.
• The tests also act as specification, and thus documentation, for future needs and
changes.
We at AngularJS have found this to be true, and the entire AngularJS codebase has been
developed using TDD. For an uncompiled, dynamic language like JavaScript, we strong‐
ly believe that having a good set of unit tests will reduce headaches in the future!
So how do we get this awesomeness that is Karma? Well, first ensure that  NodeJS  is
installed on your machine. This comes with NPM (Node Package Manager), which
makes it easy to manage and install the thousands of libraries available for NodeJS.
Once you have NodeJS and NPM installed, installing Karma is as easy as running:
sudo npm install -g karma
There you go. You are ready to start Karmaing (I just made that up, please don’t go about
using it in real life) in three easy steps!
Getting your config file up
If you used Y eoman to create your app skeleton, then you already have a readymade Karma config file waiting for you to use. If not, just go ahead and execute the
following command from the base folder of your application directory:
karma init
in your terminal console, and it will generate a dummy config file (karma.conf.js)
for you to edit to your liking, with some pretty standard defaults. You can use that.
Starting the Karma server
Just run the following command:
karma start [optionalPathToConfigFile]
This will start the Karma server on port 9876 (the default, which you can change
by editing the karma.conf.jsfile from the previous step). While Karma should open
up a browser and capture it automatically, it will print all the instructions needed
to capture another browser in the console. If you are too lazy to do that, just go to
http://localhost:9876 in another browser or device, and you are good to start run‐
ning tests in multiple browsers.
While Karma can capture the usual browsers automatically, on start
(Firefox, Chrome, IE, Opera, and even PhantomJS), it is not limited to
just those browsers. Any device on which you can browse to a URL can
possibly be a runner for Karma. So if you open up the browser of your
iPhone or Android device and browse to  http://machinename:9876
(provided it is accessible!), you could potentially run your tests on mo‐
bile devices as well.
Running the tests
Execute the following command:
karma run
That’s it. You should get your results printed right in the console where you ran the
command. Easy, isn’t it?
Unit Tests
AngularJS makes it easy to write your unit tests, and supports the Jasmine style of writing
tests by default (as does Karma). Jasmine is what we call a behavior-driven development
framework, which allows you to write specifications that denote how your code should
behave. A sample test in Jasmine might look something like this.
describe("MyController:", function() {
it("to work correctly", function() {
var a = 12;
var b = a;
expect(a).toBe(b);
expect(a).not.toBe(null);
});
});
As you can see, it lends itself to a very readable format, as most of the code that could
be read in plain English. It also provides a very diverse and powerful set of matchers
(like the expect  clauses), and of course has the xUnit  staples of setUpand tearDowns
(functions that are executed before and after each individual test case).
AngularJS provides some nice mockups, as well as testing functions, to allow you to
create services, controllers, and filters right in your unit tests, as well as mock out
HttpRequestsand the like. We will cover this in Chapter 5.
Karma can be integrated with your development workflow to make it easier, as well as
to get faster feedback on the code you have written.
Integration with IDEs
Karma does not have plug-ins (yet!) for all the latest and greatest IDEs, but you
don’t really need any. All you need to do is add a shortcut command to execute
“karma start” and “karma run” from within your IDE. This can usually be done by
adding a simple script to execute, or the actual shell command, depending on your
choice of editor. You should see the results every time it finishes running, of course.
Running tests on every change
This is utopia for many TDD developers: being able to run all their tests, every time
they press save, within a few milliseconds, and get results back quickly. And this
can be done with AngularJS + Karma pretty easily. Turns out, the Karma config file
(remember the  karma.conf.jsfile from before?) has an innocuous-looking flag
named “autoWatch”. Setting it to true tells Karma to run your tests every time the
file it watches (which is your source and test code) changes. And if you do “karma
start” from within your IDE, guess what? The results from the Karma run will be
available right within your IDE. You won’t even need to switch to console or terminal
to figure out what broke!
End-to-End/Integration Tests
As applications grow (and they tend to, really fast, before you even realize it), testing
whether they work as intended manually just doesn’t cut it anymore. After all, every
time you add a new feature, you have to not only verify that the new feature works, but
also that your old features still work, and that there are no bugs or regressions. If you
start adding multiple browsers, you can easily see how this can become a combinatorial
explosion!
AngularJS tries to ease that by providing a Scenario Runner that simulates user inter‐
actions with your application.
The Scenario Runner allows you to describe your application in a Jasmine-like syntax.
Just as with the unit tests before, we will have a series of  describes(for the feature),
and individual its (to describe each individual functionality of the feature). As always,
you can have some common actions, to be performed before and after each spec (as we
call a test).
A sample test that looks at an application that filters a list of results might look something
like the following:
describe('Search Results', function() {
beforeEach(function() {
browser().navigateTo('http://localhost:8000/app/index.html');
});
it('should filter results', function() {
input('searchBox').enter('jacksparrow');
element(':button').click();
expect(repeater('ul li').count()).toEqual(10);
input('filterText').enter('Bees');
expect(repeater('ul li').count()).toEqual(1);
});
});
There are two ways of running these tests. Either way you run them, though, you must
have a web server started that serves your application (refer to previous section for more
information on how to do that). Once that is done, use one of the following methods:
1. Automated: Karma now supports running of Angular scenario tests. Create a Kar‐
ma config file with the following changes:
a. Add ANGULAR_SCENARIO & ANGULAR_SCENARIO_ADAPTER to the
files section of the config.
b. Add a proxies section that redirects requests to the server to the correct folder
where your test files are located, for example:
proxies = {'/': 'http://localhost:8000/test/e2e/'};
c. Add a Karma root to ensure that Karma’s source files don’t interfere with your
tests, like so:
urlRoot = '/_karma_/';
Then just remember to capture your Karma server by browsing to http://local‐
host:9876/_karma_, and you should be free to run your tests using Karma.
2. Manual: The manual method allows you to open a simple page from your web
server and run (and see) all the tests. To do so, you must:
a. Create a simple runner.htmlfile, which sources the  angular-scenario.jsfile from
the Angular library.
b. Source all your JS files which hold the specifications that you have written as
part of your Scenario suite.
c. Start your web server, and browse to the runner.htmlfile.
Why should you use the Angular Scenario Runner over, say, an external third party
integration or end-to-end test runner? There are some amazing benefits that you get
from using the Scenario Runner, including:
AngularJS aware
The Angular Scenario Runner, as the name suggests, is made by and for Angular.
Thus, it is AngularJS aware, and knows and understands the various AngularJS
elements, like bindings. Need to input some text? Check the value of a binding?
Verify the state of a repeater? All can be done easily through the use of the scenario
runner.
No more random waits
The Angular awareness also means that Angular is aware of all XHRs being made
to the server, and thus can avoid waiting for random intervals of time for pages to
load. The Scenario Runner knows when a page has loaded, and thus is much more
deterministic than a Selenium test, for example, where tests can fail by timing out
while waiting for a page to load.
Debugging capabilities
Wouldn’t it be nice if you could look at your code, dig into the JavaScript, and pause
and resume the test when you wanted to, all while the Scenario tests were running?
With the Angular Scenario Runner, all this is possible, and much more.
Compilation
Compilation in the JavaScript world usually means minification of the code, though
there is some amount of actual compilation possible using the Google Closure Library.
But why would you want to convert all that glorious, well-written, and easily under‐
standable code to almost pure gibberish?
One reason is the goal of making applications that are quick and responsive for the user.
That is a major reason why client-side applications took off like they did a few years ago.
And the sooner you can get your application up and running, the sooner it will be
responsive.
That responsiveness is the motivation of minification of JS code. The smaller the code,
the smaller the payload, and the faster the transmission of the file to the user’s browser.
This becomes especially important in mobile apps, where size becomes the bottleneck.
There are a few ways you can minify the AngularJS code that you have written for your
app, each with varying levels of effectiveness.
Basic and simple optimization
This involves minifying all the variables that you use in your code, but avoiding
minifying the properties. This is known as the Simple optimization pass in Closure
Compiler.
This will not give you a great reduction in file size, but you’ll still get a substantial
one, for minimal overhead.
The reason this works is that the compiler (Closureor UglifyJS) avoids renaming
properties that are referenced from the templates. Thus, your templates continue
to work, and only local variables and parameters are renamed.
With Google Closure, this is as simple as calling:
java -jar closure_compiler.jar --compilation_level SIMPLE_OPTIMIZATIONS
--js path/to/file.js
Advanced optimization
Advanced optimization is a bit more tricky, as it tries to rename pretty much any
and every function possible. To get this level of optimization to work, you will need
to handhold the compiler a bit by telling it explicitly (through the use of an  ex
ternsfile) which functions, variables, and properties should not be renamed. These
are generally the functions and properties accessed by the templates.
The compiler will use this externsfile and then rename everything else. If done
properly, this can result in a substantial reduction in the size of your JavaScript, but
it does require a significant amount of work, including updating the  externs  file
every time your code changes.
One thing to keep in mind: you have to use the declared form of dependency in‐
jection (specifying the  $injectproperty on the controller) when you want to minify
your code.
This will not work:
function MyController($scope, $resource) {
// Stuff here
}
You will need to do one of the following instead:
function MyController($scope, $resource) {
// Same stuff here
}
MyController.$inject = [‘$scope’, ‘$resource’];
or use the module, like so:
myAppModule.controller(‘MyController’, [‘$scope’,
‘$resource’,
function($scope, $resource) {
// Same stuff here
}]);
This is the only way AngularJS can figure out which service or variable you were
originally asking for once all the variables are obfuscated or compressed.
It is generally good practice to use the array-style injection all the time,
to avoid bugs later when you start compiling the code. Scratching your
head later and trying to figure out why the provider of the $evariable
(the minified, obfuscated version of some service) is suddenly missing
is just not worth it.
Other Awesome Tools
In this section, we will take a look at some other tools that will help ease your develop‐
ment flow and make you that much more productive. These range from debugging with
Batarang to actual coding and development with Yeoman.
Debugging
When you work with JavaScript, debugging your code in the browser is going to become
second nature. The sooner you accept that, the better off you will be. Thankfully, things
have come a long way since the old days when there was no Firebug. Now, regardless
of the choice of browser, there is generally something you can use to step in to your
code, analyze your errors, and figure out the state of the application. Get to know the
Developer Tools in Chrome and Internet Explorer; Firebug works across Firefox and
Chrome.
A few further tips to help you out when debugging your application:
• Always, always switch to the non-minified version of all your source code and
dependencies when you want to debug. Not only will you get better variable names,
you’ll also get line numbers and actual useful information and debugging capabil‐
ities.
• Try to keep your source code in individual JS files, not inlined in HTML.
• Breakpoints are useful! They allow you to check the state of your application, its
models, and everything in between at a given point in time.
• “Pause on all exceptions” is a very useful option that is built in to most developer
tools nowadays. The debugger will halt when an exception occurs, and highlight
the line causing it.
Batarang
And then, of course, we have Batarang. Batarang is a Chrome extension that adds An‐
gularJS knowledge to the built-in Developer Tools suite in Google Chrome. Once in‐
stalled (you can get it from  http://bit.ly/batarangjs), it adds another tab to the Developer
Tools panel of Chrome called AngularJS.
Have you ever wondered what the current state of your AngularJS application is? What
each model, each scope, and each variable currently contains? How is the performance
of your application? if you haven’t yet, trust me, you will! And when you do, Batarang
is there for you!
There are four main useful additions in Batarang.
Model tab
Batarang allows you to dig into the scope, from the root downwards. You can then see
how scopes are nested and how models are attached to them (as shown in Figure 3-2).
You can even change them in real time and see the changes reflected in your application.
How cool is that?
Figure 3-2. Model tree in Batarang
Performance tab
The performance tab must be enabled separately, as it injects some special JavaScript
juice into your application. Once you enable it, you can look at various scopes and
models, and evaluate the performance of all the watch expressions in each scope (as
shown in  Figure 3-3). The performance also gets updated as you use the app, so it works
in real time as well!
Figure 3-3. Performance tab in Batarang
Service dependencies
For a simple application, you won’t have more than one or two dependencies for your
controllers and services. But in a real, full-scale application, service dependency man‐
agement can become nightmarish without the proper tool support. Batarang is there
for you, filling this very hole, as it gives you a clean, simple way of visualizing your
service dependency chart (as shown in Figure 3-4).
Figure 3-4. Charting dependencies in Batarang
Elements properties and console access
When you dig through the HTML template code of an AngularJS application, there is
now an additional AngularJS Properties section in the Properties pane of the Elements
tab. This allows you to inspect the models attached to a given element’s  scope. It also
exposes the scope  of the element to the console, so that you can access it through the
$scopevariable in the console. This is shown in Figure 3-5.

Figure 3-5. AngularJS properties within Batarang
Y eoman: Optimizing Your Workflow
There are quite a few tools that have sprung up to help optimize your workflow when
developing web applications. Yeoman, which we touched upon in previous sections, is
one such tool that boasts an impressive set of features, including:
• Lightning-fast scaffolding
• Built-in preview server
• Integrated package management
• An awesome build process
• Unit testing using PhantomJS
I t also integrates nicely and extensively with AngularJS, which is one of the foremost
reasons why we strongly recommend using it for any AngularJS project. Let’s walk
through the various ways that Yeoman makes your life easier:

Installing Yeoman
Installing Y eoman is quite an involved process, but there are scripts to help you through
it.
On a Mac/Linux machine, run the following command:
curl -L get.yeoman.io | bash
and just follow the instructions it prints to get Yeoman.
For Windows, or if you run into any issues, go to https://github.com/yeoman/yeoman/
wiki/Manual-Installand follow the instructions there to get you unblocked.
Starting a Fresh AngularJS project
As previously mentioned, even a simple AngularJS project has quite a bit of seeding that
needs to be done, from the templates, the basic controllers, and the library dependencies,
to everything else that needs to be structured. You could do it yourself manually, or use
Yeoman to do it for you.
Simply create a folder for your project (the name of the folder will be taken as the project
name by Yeoman), and then run:
yeoman init angular
This will create the entire structure detailed in the Project Organization part of this
chapter for you, including the skeletons for rendering your routes, your unit tests, and
more.
Running Your Server
If you don’t use Yeoman, you will have to create an HTTP server that serves your frontend code. But with Yeoman, you get a built-in server that is pre-configured and has
some nice added benefits. You can start the server using:
yeoman server
This not only starts a web server that serves your code, but it also automatically opens
your web browser and refreshes your browser when you make changes to your appli‐
cation.
Adding New Routes, Views, and Controllers
Adding a new route to Angular involves multiple steps, including:
• Sourcing the New Controller JS file in the index.html
• Adding the correct route to the AngularJS module
• Creating the template HTML
• Adding unit tests
All of this can be accomplished in a single step in Yeoman with the following command:
yeoman init angular:route routeName
So if you ended up running yeoman init angular:route home, it would:
• Create a home.jscontroller skeleton in the app/scripts/controllersfolder
• Create a home.jstest spec skeleton in the test/specs/controllersfolder
• Add the home.htmltemplate to the app/viewsfolder
• Hook up the home route in the main app module (app/scripts/app.jsfile)
All of this from a single command!
The Testing Story
We’ve already seen how ridiculously easy it is to start and run tests using Karma. In the
end, just two commands were needed to run all your unit tests.
Yeoman makes it easier (if you can believe it). Anytime you generate a file using Yeoman,
it also creates a testing stub for you to fill out. Once you’ve installed Karma, running
tests with Yeoman is as simple as executing the following command:
yeoman test
Building Your Project
Building the production-ready version of your app can be a pain, or at least involve
many steps. Yeoman alleviates some of this by allowing you to:
• Concatenate all your JS Scripts into one file
• Version your files
• Optimize images
• Generate Application Cache manifests
All these benefits come from just one command:
yeoman build
Y eoman does not support minification yet, but it is coming soon, according to the
developers.

Integrating AngularJS with RequireJS
Getting your development environment just right is much easier if you get more done
early. Modifying your development environment at a later stage will require modifica‐
tions to a larger number of files. Dependency management and creating deployment
packages are top worries for any sizable project.
With JavaScript, setting up your development environment used to be quite difficult,
as it involved maintaining Ant builds, building scripts to concatenate your files, mini‐
fying them, and more. Thankfully, in the recent past, tools like RequireJS have emerged,
which allow you to define and manage your JS dependencies, as well as hook them into
a simpler build process. With these asynchronous load-management tools, which en‐
sure that all dependencies are loaded before the code is executed, focusing on developing
the actual features has never been easier.
Thankfully, AngularJS can and does play nice with RequireJS, so you can have the best
of both worlds. For the purpose of this example, we will provide a sample setup that we
have found to work nicely, and in a systematic, easy-to-follow way.
Let us take a look at the project organization (similar to the skeletons previously de‐
scribed, with minor changes):
1. app: This folder hosts all the app code that is displayed to the user. This includes
HTML, JS, CSS, images, and dependent libraries.
a. /styles: Contains all the CSS/LESS files
b. /images: Contains images for our project
c. /scripts: The main AngularJS codebase. This folder also includes our bootstrap‐
ping code, and the main integration with RequireJS
i. /controllers: AngularJS controllers go here
ii. /directives: AngularJS Directives go here
iii. /filters: AngularJS filters go here
iv. /services: AngularJS ser vices go here
d. /vendor: The libraries we depend on (Bootstrap, RequireJS, jQuery)
e. /views: The HTML partials for the views and the components used in our project
2. config: Contains Karma configs for unit and scenario tests
3. test: Contains the unit and scenario (integration) tests for the app
a. /spec: Contains the unit tests, mirroring the structure of the JS folder in the app
directory
b. /e2e: Contains the end-to-end scenario specs

The first thing we need is the main.jsfile (in the app folder) that RequireJS loads, which
then triggers loading of all the other dependencies. In this example, our JS project will
depend on jQuery and Twitter Bootstrap in addition to our code.
// the app/scripts/main.js file, which defines our RequireJS config
require.config({
paths: {
angular: 'vendor/angular.min',
jquery: 'vendor/jquery',
domReady: 'vendor/require/domReady',
twitter: 'vendor/bootstrap',
angularResource: 'vendor/angular-resource.min',
},
shim: {
'twitter/js/bootstrap': {
deps: ['jquery/jquery']
},
angular: {
deps: [ 'jquery/jquery',
'twitter/js/bootstrap'],
exports: 'angular'
},
angularResource: { deps:['angular'] }
}
});
require([
'app',
// Note this is not Twitter Bootstrap
// but our AngularJS bootstrap
'bootstrap',
'controllers/mainControllers',
'services/searchServices',
'directives/ngbkFocus'
// Any individual controller, service, directive or filter file
// that you add will need to be pulled in here.
// This will have to be maintained by hand.
],
function (angular, app) {
'use strict';
app.config(['$routeProvider',
function($routeProvider) {
// Define your Routes here
}
]);
}
);
We then define an app.jsfile. This defines our AngularJS app, and tells it that it depends
on all the controllers, services, filters, and directives we define. We’ll look at the files
that are mentioned in the RequireJS dependency list in just a bit.

You can think of the RequireJS dependency list as a blocking import statement for
JavaScript. That is, the function within the block will not execute until all the depen‐
dencies listed are satisfied or loaded.
Also notice that we don’t individually tell RequireJS what directive, service, or filter to
pull in, because that is not how this project is structured. There is one module each for
controllers, services, filters, and directives, and thus it is sufficient to just define those
as our dependencies.
// The app/scripts/app.js file, which defines our AngularJS app
define(['angular', 'angularResource', 'controllers/controllers',
'services/services', 'filters/filters',
'directives/directives'], function (angular) {
return angular.module(‘MyApp’, ['ngResource', 'controllers', 'services',
'filters', 'directives']);
});
We also have a bootstrap.jsfile, which waits for the DOM to be ready (using RequireJS’s
plug-in, domReady), and then tells AngularJS to go forth and be awesome.
// The app/scripts/bootstrap.js file which tells AngularJS
// to go ahead and bootstrap when the DOM is loaded
define(['angular', 'domReady'], function(angular, domReady) {
domReady(function() {
angular.bootstrap(document, [‘MyApp’]);
});
});
There is another advantage to splitting the bootstrap from the app, which is that we
could potentially replace our  mainAppwith a fake or a  mockAppfor the purpose of testing.
For example, if the servers you depend on are flaky, you could just create a fakeApp  that
replaces all  $httprequests with fake data to allow you to develop in peace. That way,
you can just slip in a fakeBootstrapand a fakeAppinto your application.
Now, your main index.html(which is in the app folder) could look something like:
<!DOCTYPE html>
<html> <!-- Do not add ng-app here as we bootstrap AngularJS manually-->
<head>
<title>My AngularJS App</title>
<meta charset="utf-8" />
<link rel="stylesheet" type="text/css"
href="styles/bootstrap.min.css">
<link rel="stylesheet" type="text/css"
href="styles/bootstrap-responsive.min.css">
<link rel="stylesheet" type="text/css" href="styles/app.css">
</head>
<body class="home-page" ng-controller="RootController">

<div ng-view ></div>
<script data-main="scripts/main"
src="lib/require/require.min.js"></script>
</body>
</html>
Now, we’ll take a look at the js/controllers/controllers.js file, which will look almost ex‐
actly the same as js/directives/directives.js, js/filters/filters.js, and js/services/services.js:
define(['angular'], function(angular) {
'use strict';
return angular.module('controllers', []);
});
Because of the way we have our RequireJS dependencies structured, all these are guar‐
anteed to run only after the Angular dependency has been satisfied and loaded.
Each of these files defines an AngularJS module, which will then be used by the indi‐
vidual controllers, directives, filters, and services to add on to the definition.
Let’s take a look at a directive definition (such as our focusdirective from Chapter 2):
// File: ngbkFocus.js
define(['directives/directives'], function(directives) {
directives.directive(ngbkFocus, ['$rootScope', function($rootScope) {
return {
restrict: 'A',
scope: true,
link: function(scope, element, attrs) {
element[0].focus();
}
};
}]);
});
The directive itself is quite trivial, but let us take a closer look at what’s happening. The
RequireJS shim around the file says that my ngbkFocus.jsdepends on the module dec‐
laration file  directives/directives.js. It then uses the injected directives module to add on
its own directive declaration. You could choose to have multiple directives, or a single
one per file. It is completely up to you.
One major note: if you have a controller that pulls in a service (say your RootControl
lerdepends on your UserService, and gets the UserService injected in), then you have
to make sure that you define the file dependency to RequireJS as well, like so:
define(['controllers/controllers', 'services/userService'],
function(controllers) {
controllers.controller('RootController', ['$scope', 'UserService',
function($scope, UserService) {
// Do what's needed

};
}]);
});
That is basically how your entire source folder structure is set up.
But how does this affect my tests, you ask? We’re glad you asked that question, because
you are going to get the answer now!
The good news is that Karma does support RequireJS. Just install the latest and greatest
version of Karma (using npm install -g karma).
Once you have done that, the Karma configfor the unit tests also changes slightly. The
following is how we would set up the unit tests to run for the project structure we have
previously defined: 
// This file is config/karma.conf.js.
// Base path, that will be used to resolve files
// (in this case is the root of the project)
basePath = '../';
// list files/patterns to load in the browser
files = [
JASMINE,
JASMINE_ADAPTER,
REQUIRE,
REQUIRE_ADAPTER,
// !! Put all libs in RequireJS 'paths' config here (included: false).
// All these files are files that are needed for the tests to run,
// but Karma is being told explicitly to avoid loading them, as they
// will be loaded by RequireJS when the main module is loaded.
{pattern: 'app/scripts/vendor/**/*.js', included: false},
// all the sources, tests // !! all src and test modules (included: false)
{pattern: 'app/scripts/**/*.js', included: false},
{pattern: 'app/scripts/*.js', included: false},
{pattern: 'test/spec/*.js', included: false},
{pattern: 'test/spec/**/*.js', included: false},
// !! test main require module last
'test/spec/main.js'
];
// list of files to exclude
exclude = [];
// test results reporter to use
// possible values: dots || progress
reporter = 'progress';
// web server port

port = 8989;
// cli runner port
runnerPort = 9898;
// enable/disable colors in the output (reporters and logs)
colors = true;
// level of logging
logLevel = LOG_INFO;
// enable/disable watching file and executing tests whenever any file changes
autoWatch = true;
// Start these browsers, currently available:
// - Chrome
// - ChromeCanary
// - Firefox
// - Opera
// - Safari
// - PhantomJS
// - IE if you have a windows box
browsers = ['Chrome'];
// Continuous Integration mode
// if true, it captures browsers, runs tests, and exits
singleRun = false;
We use a slightly different format to define our dependencies (the included: falseis
quite important). We also add the dependency on REQUIRE_JS and its adapter. The
final thing to get all this working is main.js, which triggers our tests.
// This file is test/spec/main.js
require.config({
// !! Karma serves files from '/base'
// (in this case, it is the root of the project /your-project/app/js)
baseUrl: '/base/app/scripts',
paths: {
angular: 'vendor/angular/angular.min',
jquery: 'vendor/jquery',
domReady: 'vendor/require/domReady',
twitter: 'vendor/bootstrap',
angularMocks: 'vendor/angular-mocks',
angularResource: 'vendor/angular-resource.min',
unitTest: '../../../base/test/spec'
},
// example of using shim, to load non-AMD libraries
// (such as Backbone, jQuery)
shim: {
angular: {
exports: 'angular'
},
angularResource: { deps:['angular']},
angularMocks: { deps:['angularResource']}
}
});
// Start karma once the dom is ready.
require([
'domReady',
// Each individual test file will have to be added to this list to ensure
// that it gets run. Again, this will have to be maintained manually.
'unitTest/controllers/mainControllersSpec',
'unitTest/directives/ngbkFocusSpec',
'unitTest/services/userServiceSpec'
], function(domReady) {
domReady(function() {
window.__karma__.start();
});
});
So with this setup, we can run the following:
karma start config/karma.conf.js
Then we can run the tests.
Of course there is a slight change when it comes to writing your unit tests. They need
to be RequireJS-supported modules as well, so let’s take a look at a sample test:
// This is test/spec/directives/ngbkFocus.js
define(['angularMocks', 'directives/directives', 'directives/ngbkFocus'],
function() {
describe('ngbkFocus Directive', function() {
beforeEach(module('directives'));
// These will be initialized before each spec (each it(), that is),
// and reused
var elem;
beforeEach(inject(function($rootScope, $compile) {
elem = $compile('<input type=”text” ngbk-focus>')($rootScope);
}));
it('should have focus immediately', function() {
expect(elem.hasClass('focus')).toBeTruthy();
});
});
});
Every test of ours will do the following:
1. Pull in  angularMocks, which gets us  angular,  angularResource, and of course,
angularMocks.

2. Pull in the high-level module (directives for directives, controllers for control‐
lers, and so on), then the individual file it is actually testing (the  loadingIndicator).
3. If your test depends on some other service or controller, make sure you also define
the RequireJS dependency , in addition to telling AngularJS about it.
This kind of approach can be used with any test, and you should be good to go.
Thankfully, the RequireJS approach doesn’t affect our end-to-end tests at all, so they can
simply be done the way we have seen so far. A sample config follows, assuming that the
server that runs your app is running on http://localhost:8000.
// base path, that will be used to resolve files
// (in this case is the root of the project
basePath = '../';
// list of files / patterns to load in the browser
files = [
ANGULAR_SCENARIO,
ANGULAR_SCENARIO_ADAPTER,
'test/e2e/*.js'
];
// list of files to exclude
exclude = [];
// test results reporter to use
// possible values: dots || progress
reporter = 'progress';
// web server port
port = 8989;
// cli runner port
runnerPort = 9898;
// enable / disable colors in the output (reporters and logs)
colors = true;
// level of logging
logLevel = LOG_INFO;
// enable / disable watching file and executing tests whenever any file changes
autoWatch = true;
urlRoot = '/_karma_/';
proxies = {
'/': 'http://localhost:8000/'
};
// Start these browsers, currently available:
browsers = ['Chrome'];
// Continuous Integration mode
// if true, it capture browsers, run tests and exit
singleRun = false;



