（hxzon读书笔记）《实用common lisp编程》第20章：特殊操作符

by hxzon
（2012.10.22 ， 2014.1.6 ）
=====
25个特殊操作符：

function （获得函数对象）。
quote，if，progn 。
let，let* ，setq ，
flet（局部函数），labels（局部函数），
macrolet（局部宏），symbol-macrolet （符号宏）。

block 和 return-from 。
tagbody 和 go 。

catch 和 throw 。
unwind-protect 。

multiple-value-call 。
eval-when 。
locally，the 。
load-time-value 。
progv 。

=====
1，控制求值

1.1，quote，避免求值。

1.2，if。（许多lisp方言里，最基本的条件求值操作符是cond。）

1.3，progn，即clojure里的do 。

=====
2，维护词法环境（lexical environment）

2.1，let

2.2，let*

2.3，setq，用来访问词法环境，可以用它设置由let 和 let* 所创建的绑定。

----
2.4，flet，创建局部函数。（f前缀表示函数。）
由flet定义的函数名，只能在flet的主体中使用。
flet不能用来定义递归函数，但却能够编写出一个调用另一个同名函数的局部函数。
被调用的同名函数可能是一个全局定义的函数，或是来自外围作用域的另一个局部函数。

----
2.5，labels，创建局部函数。
由labels所定义的名字可以立即使用，包括labels所定义的函数本身，所以可以用来定义递归函数。

在flet或labels的主体内，可以像任何其他函数那样使用这些局部函数的名字，包括使用function特殊操作符。

由于可以使用function来获得代表flet或labels所定义的函数的函数对象，
并且因为一个flet或labels可以定义在其它诸如let这样的绑定形式的作用域内，
所以这些函数可能是闭包。

;示例，count-version接受单一参数，这是walk-directory所要求的，但该函数还用到了外围let所引入的变量version。

--
确实有可能使匿名函数成为递归的。不过，你必须使用一种称为“Y组合器”（Y combinator）的古怪手法。
Y组合器是一种有趣的理论结果，并非实用的编程工具。

--
flet 和 labels 在用于宏展开时也相当有用。
一个宏的展开代码里可以含有一个flet或labels，用来创建可在宏主体中使用的函数。
这个技术既可以用来引入宏的用户要调用的函数，也可以只作为一种组织宏所生成的代码的方式。
举个例子，这就是为什么能够定义出像 call-next-method 这种只能在一个方法的定义内使用的函数的原因。

----
2.6，macrolet，用来定义局部宏。
局部宏定义可以用来覆盖全局的函数或宏，或者外围的局部定义。

----
2.7，symbol-macrolet，定义符号宏。
符号宏和常规宏相似，只是不能接受任何参数，并且只能用单个符号，而非列表的形式来引用它。
即，在值的位置上，对该符号的任何使用将被展开，由此产生的形式将在该位置上进行求值。

with-slots 和 with-accessors 就是通过这种方法，
来定义“变量”用来在特定范围内，访问某个特定对象的状态。

符号宏通常都是局部的。宏define-symbol-macro 则定义全局的符号宏。

由symbol-macrolet 定义的符号宏
将覆盖 define-symbol-macro 或 外围symbol-macrolet 所定义的其它同名符号宏。

=====
3，局部控制流

以下4个特殊操作符也会在词法环境中创建并使用名字，但目的是为调整控制流。

----
3.1，block 和 return-from 。

return-from用来从块结构中提前返回。
当一个return-from被求值时，会导致该命名的block立即返回。
如果return-from带有返回值，block返回该值，否则返回nil。

一个块的名字可以是任何符号，包括nil。
许多标准控制构造宏，如do，dotimes和dolist，都会生成一个含有名为nil的block 。
这允许你使用 宏return 来从这些循环中跳出，
该宏是 (return-from nil ...) 的语法糖。

诸如defun，flet，labels这类可以定义函数的宏，会将它们的函数体封装在一个与该函数同名的block中，
所以可以用 return-from 来从一个函数中返回。

---
3.2，tagbody 和 go ，一种相当底层的goto结构。

tagbody含有一系列标记和形式。（即标记必须出现在tagbody的最顶层。）
形式按顺序求值，而标记则被忽略。
整个tagbody返回nil。
go立即跳转到任何标记上，求值过程将从紧跟着该标记的那个形式开始继续执行。

很少使用tagbody，因为使用已有的循环宏更方便。
但是，在将其他语言的算法转译成common lisp时很有用。


=====
4，从栈上回退

----
4.1，block，tagbody

可以正常使用block和tagbody来管理单一函数内的控制流，
但也可以将它们与闭包一起使用，
可以强制从栈底部的函数立即非本地返回。
因为block名字和tagbody标记可以被block或tagbody词法作用域之内的任何代码所闭合。

由于块的名字是词法作用域的，一个return-from总是从它所在的词法环境中最小的外围block上返回，
即使return-from是在不同的动态上下文中执行。

这个额外的block不会改变foo的行为。
名字a是词法解析的，并且是在编译期，而非动态地解析的。

没有办法让块外的语句从该块上返回，除非通过调用一个在block的词法作用域内部封装的闭包。

block名字和tagbody标记在某个重要方面与“词法变量绑定”不同。
词法绑定具有无限时效，这意味着在绑定形式返回后，绑定也可以保持效果。
而block和tagbody具有动态时效，只有当block和tagbody在栈上时，
才能通过return-from回到一个block，或者通过go回到一个tagbody标记上。
即，一个捕捉了块名或tagbody标记的闭包，只能向栈的下方传递（从而稍后再调用），
不能向栈的上方传递。

（
这是一个合理的限制，“从一个已经返回的形式中返回”的意义并不是完全清楚的。
但scheme支持续延（continuation），允许从相同的函数调用中多次返回。
）

很少会亲自使用block和tagbody来实现这种栈的回退。
状况系统基于它们。

----
4.2，catch 和 throw

它们是早期没有common lisp状况系统的lisp方言所留下的东西。

它们是block和return-from的“动态版本”。
与block不同，catch和throw之间的关联是动态建立的，
一个catch的标签是对象，称为捕捉标记，
而任何在catch的动态时效中，求值的throw在抛出该对象时，将导致栈回退到catch上，使catch立即返回。

如果bar中的某些代码重新赋值或绑定了*obj* ，那么baz中的throw将不会抛出同样的catch。
这使得代码更难理解。
使用catch和throw的唯一优势是，不再需要向下传递一个闭包以便底层代码可以从一个catch中返回，
任何在一个catch的动态时效内运行的代码，都可以通过抛出正确的对象来返回。

在古老的lisp方言中，catch和throw用于错误处理。
为了确保它们可管理，捕捉标记通常只是一些引用了的符号。
common lisp中，使用状况系统会更加灵活。

----
4.3，unwind-protect，等价于java中的try...finally 。

with-风格宏以它为基础。

=====
5，多值

multiple-value-call

=====
6，eval-when ，控制特定代码在“何时”被求值。

:compile-toplevel
:load-toplevel
:execute

=====
7，locally 和 the ，属于common lisp声明系统的一部分。
它们用来与编译器沟通（有助于生成更好的代码，clojure中使用元数据），
而对代码的含义没有影响（唯一有影响的是special声明）。

=====
8，load-time-value

用来创建一个在加载期决定的值。

当文件编译器编译load-time-value形式时，
会安排在加载fasl时只求值它的第一个子形式一次，并返回该值。

在没有被compile-file处理过的代码中，load-time-value仅在代码被编译时求值一次。
这可能是在显示使用compile编译一个函数，或者在求值代码的过程中隐式的编译。

在未编译的代码中，load-time-value在其每次被求值时都会求值其子形式。

=====
9，progv，为变量创建其名字在运行期才确定的新的动态绑定。
对于支持动态作用域变量的语言实现嵌入式解释器特别有用。

其中symbols-list求值到一个符号的列表上，values-list求值到值列表。
每个符号被动态的绑定到对应的值上，然后求值body-form 。
progv和let的区别在于，symbols-list 是在运行期求值的，被绑定的变量名可以动态地确定。





