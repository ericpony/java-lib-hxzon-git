（hxzon思考）编程本身的常见问题

by hxzon

本不是问题的问题。

=======
1，接口，实现继承

继承分“接口继承”和“实现继承”。

接口的意义：契约（用代码来表示契约，对比文档标注，好处是强制）。

“实现继承”只是为了代码复用。
用这种方式来实现复用，大部分时候是因为编程语言有缺陷。
例如“混入”，比实现继承更佳。

----
菱形继承问题（两种实现都匹配）：像clojure的prefer机制，明确指明那种实现优先即可。

----
层级问题：java等通过继承来静态形成层级，
clojure通过元数据，任意地动态地建立层级，不必为了得到层级而继承，层级只是一种数据分类。
而接口是为了订立契约，不是用来表达层级关系。


=======
2，异常处理（受检异常，非受检异常，返回错误值）

2.1，受检异常vs非受检异常
http://www.mindview.net/Etc/Discussions/CheckedExceptions

受检异常

优点：抛出的异常明确。

缺点：
-1，强制在代码中需要捕获，带来两种“繁琐”：切断了变量的作用域；嵌套try catch。
-2，当不宜或无法立刻处理时，需要继续上抛，此时异常变成方法签名的一部分，影响后续更改（“僵硬”）。

----
非受检异常

缺点：方法签名本身没有明确表明可能抛出的异常。（可通过ide，文档等来改进）

优点：避免了“受检异常”上述的缺点。

----
hxzon个人观点：推荐使用“非检查异常”，抛弃“受检异常”。

----------
2.2，异常vs返回值

现状限制：大多数语言不支持“多返回值”，所以不一定能用返回值来表示错误。

两者的本质区别：
异常允许此刻不检查不处理，留到更合适的上层处理。
返回值强制要求立刻检查并处理。（其本质就是“受检异常”，但没有“受检异常”“繁琐”和“僵硬”的缺点。）

hxzon个人观点：异常更灵活，更简洁，但同时，增加了隐藏的中断逻辑。

=======
3，编译型和虚拟机型

虚拟机能够提供运行时信息，从而实现动态性。（有性能损耗。）

编译型只能通过代码生成代码（预处理文本宏，模板）？
C++的多态是在编译期？

lisp通过语法宏，在编译期完成语法转换，从而完全不需要运行时的元信息。（最佳？）

go将虚拟机编译进程序当中。

=======
4，类型

提前写上类型，限制了代码的通用性（限制了可用类型）。
但如果事先知道类型限制（包括长度），写上类型有助于优化性能。类似整形长度等信息，编译器是不可能自动推断的。

=======
5，给一个类（你无法修改）添加方法

静态方法即可。但是不直观。

隐式转换（scala）。语法糖，使得直观。

元编程。运行时修改，更灵活。


6，多态（即转发，根据数据“类型”，自动调用合适的具体实现）

多重方法（lisp），根据参数（“类型”）自动选择合适的具体实现。

面向对象的多态（多重方法的一个特例，只根据第一个参数的类型，
为了类型层级，需要接口和父类，复杂化问题本身）。

7，复用

静态方法（重载）即可，但是不直观。

复用继承，实现了复用，却产生了层级，这个层级可能是我们不打算要的。
如果不支持多继承，则不能从多个类复用。

混入（scala）。灵活的多继承（不仅类级别，也可实例级别）。

宏（lisp），代码生成代码，最通用。

----
8，dsl，领域专用语言

隐式上下文。语法需要（简洁）。

动态类型。避免人为限制类型。

类型自动推断。语法需要（简洁）。

类型化。语法需要（明确）。
（如果是希望编辑器能提供检查信息，则类型化既不是唯一，也不是最佳的选择。）

元编程。运行时生成代码。
（有无可能完全不需要运行时生成代码？）

编译时代码生成。（宏。）

//灵巧api（连贯接口）。



----
9，变量可见性

变量或函数私有，可以避免意外调用。

js没有提供私有可见性，需要一些技巧实现私有可见性。

java提供私有可见性，可通过反射绕过。

clojure提供私有可见性（一个元数据），防止你意外调用，可以简单但明确地有意绕过。

hxzon：提供，但是可以明确地绕过，不人为做限制。

----
10，鸭子类型（有对应方法即可，不必实现接口）

实现接口表明遵守契约。
有可用方法不代表遵守契约。

ruby，有可用方法即可。但是有可用方法不代表遵守契约。

java，必须实现接口（表明遵守契约）。不受控制的类，无法让它实现接口，需要包装。

go，有可用方法即可，实现方不必实现接口，调用方可定义接口。
有可用方法不代表遵守契约。

clojure，可后期实现接口（“扩展协议”）（表明遵守契约）。灵活，明确，最佳。

----
11，常量

常量，编译时固定（提升性能；防止意外改变）。

如果需要运行时统一改变，使用全局变量。

hxzon：需要提供不同于修改普通变量的方式，使得修改“常量”明确而不是意外。

clojure：alter-var-root 。

----
12，js中的with 和 clojure中的doto

js中的with，操作的可能是对象的字段，也可能是外部环境的变量。容易出错，弃用。

clojure中的doto，操作的一定是对象。简洁好用。

----
13，延迟求值

延迟减少了不必要的计算（有些值可能永远未被用到）。
这一点上，延迟求值和并发相违背，
并发的目的，就是需要某个值时，它已经准备好。

延迟求值，使得可以轻松的表达无限序列。
这一点，并发无能为力。

----
14，common lisp的广义函数 vs clojure的多重方法

（common lisp的多重方法指“真正的”多重方法，即确实对多个参数进行特化。）

common lisp定义广义函数时指定了参数个数，clojure则不指定任何参数（参数由注册的“实现体”决定）。
common lisp的“实现体”在参数上“基于类型”或者“基于某个实例”特化。
因此common lisp的转发只依赖于“实现体”，但是转发只能是“基于类型”或者“基于某个实例”的特化。

clojure定义多重方法时指定转发函数，“实现体”则指定转发值。
因此clojure的转发同时依赖于“转发函数”和“实现体”的转发值，但是转发很灵活，不必是“基于类型”。

hxzon个人观点：clojure更灵活。

----
15，

