（hxzon读书笔记）《clojure编程》第3章：集合和数据结构-生命值游戏

Revisiting a classic: Conway’s Game of Life
https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life

(defn empty-board
"Creates a rectangular empty board of the specified width
and height."
[w h]
(vec (repeat w (vec (repeat h nil)))))

(defn populate
"Turns :on each of the cells specified as [y, x] coordinates."
[board living-cells]
(reduce (fn [board coordinates]
(assoc-in board coordinates :on))
board
living-cells))
(def glider (populate (empty-board 6 6) #{[2 0] [2 1] [2 2] [1 2] [0 1]}))
(pprint glider)
; [[nil :on nil nil nil nil]
; [nil nil :on nil nil nil]
; [:on :on :on nil nil nil]
; [nil nil nil nil nil nil]
; [nil nil nil nil nil nil]
; [nil nil nil nil nil nil]]

(defn neighbours
[[x y]]
(for [dx [-1 0 1] dy [-1 0 1] :when (not= 0 dx dy)]
[(+ dx x) (+ dy y)]))
(defn count-neighbours
[board loc]
(count (filter #(get-in board %) (neighbours loc)))) 
(defn indexed-step
"Yields the next state of the board, using indices to determine neighbors,
liveness, etc."
[board]
(let [w (count board)
h (count (first board))]
(loop [new-board board x 0 y 0]
(cond
(>= x w) new-board
(>= y h) (recur new-board (inc x) 0)
:else
(let [new-liveness
(case (count-neighbours board [x y])
2 (get-in board [x y])
3 :on
nil)]
(recur (assoc-in new-board [x y] new-liveness) x (inc y)))))))


(-> (iterate indexed-step glider) (nth 8) pprint)
; [[nil nil nil nil nil nil]
; [nil nil nil nil nil nil]
; [nil nil nil :on nil nil]
; [nil nil nil nil :on nil]
; [nil nil :on :on :on nil]
; [nil nil nil nil nil nil]]

(defn indexed-step2
[board]
(let [w (count board)
h (count (first board))]
(reduce
(fn [new-board x]
(reduce
(fn [new-board y]
(let [new-liveness
(case (count-neighbours board [x y])
2 (get-in board [x y])
3 :on
nil)]
(assoc-in new-board [x y] new-liveness)))
new-board (range h)))
board (range w))))

(defn indexed-step3
[board]
(let [w (count board)
h (count (first board))]
(reduce
(fn [new-board [x y]]
(let [new-liveness
(case (count-neighbours board [x y])
2 (get-in board [x y])
3 :on
nil)]
(assoc-in new-board [x y] new-liveness)))
board (for [x (range h) y (range w)] [x y]))))

(partition 3 1 (range 5))
;= ((0 1 2) (1 2 3) (2 3 4))

(partition 3 1 (concat [nil] (range 5) [nil]))
;= ((nil 0 1) (0 1 2) (1 2 3) (2 3 4) (3 4 nil))

(defn window
"Returns a lazy sequence of 3-item windows centered around each item of coll."
[coll]
(partition 3 1 (concat [nil] coll [nil])))

(defn cell-block
"Creates a sequences of 3x3 windows from a triple of 3 sequences."
[[left mid right]]
(window (map vector
(or left (repeat nil)) mid (or right (repeat nil)))))

(defn window
"Returns a lazy sequence of 3-item windows centered
around each item of coll, padded as necessary with
pad or nil."
([coll] (window nil coll))
([pad coll]
(partition 3 1 (concat [pad] coll [pad]))))
(defn cell-block
"Creates a sequences of 3x3 windows from a triple of 3 sequences."
[[left mid right]]
(window (map vector left mid right)))

(defn liveness
"Returns the liveness (nil or :on) of the center cell for
the next step."
[block]
(let [[_ [_ center _] _] block]
(case (- (count (filter #{:on} (apply concat block)))
(if (= :on center) 1 0))
2 center
3 :on
nil)))

(defn- step-row
"Yields the next state of the center row."
[rows-triple]
(vec (map liveness (cell-block rows-triple))))
(defn index-free-step
"Yields the next state of the board."
[board]
(vec (map step-row (window (repeat nil) board))))

(= (nth (iterate indexed-step glider) 8)
(nth (iterate index-free-step glider) 8))
;= true

=====
(defn step
"Yields the next state of the world"
[cells]
(set (for [[loc n] (frequencies (mapcat neighbours cells))
:when (or (= n 3) (and (= n 2) (cells loc)))]
loc)))

(->> (iterate step #{[2 0] [2 1] [2 2] [1 2] [0 1]}) 
(drop 8)
first
(populate (empty-board 6 6))
pprint)
; [[nil nil nil nil nil nil]
; [nil nil nil nil nil nil]
; [nil nil nil :on nil nil]
; [nil nil nil nil :on nil]
; [nil nil :on :on :on nil]
; [nil nil nil nil nil nil]]

(defn stepper
"Returns a step function for Life-like cell automata.
neighbours takes a location and return a sequential collection
of locations. survive? and birth? are predicates on the number
of living neighbours."
[neighbours birth? survive?]
(fn [cells]
(set (for [[loc n] (frequencies (mapcat neighbours cells))
:when (if (cells loc) (survive? n) (birth? n))]
loc))))

(defn hex-neighbours
[[x y]]
(for [dx [-1 0 1] dy (if (zero? dx) [-2 2] [-1 1])]
[(+ dx x) (+ dy y)]))
(def hex-step (stepper hex-neighbours #{2} #{3 4}))
;= ; this configuration is an oscillator of period 4
(hex-step #{[0 0] [1 1] [1 3] [0 4]})
;= #{[1 -1] [2 2] [1 5]}
(hex-step *1)
;= #{[1 1] [2 4] [1 3] [2 0]}
(hex-step *1)
;= #{[1 -1] [0 2] [1 5]}
(hex-step *1)
;= #{[0 0] [1 1] [1 3] [0 4]}

(stepper #(filter (fn [[i j]] (and (< -1 i w) (< -1 j h)))
(neighbours %)) #{2 3} #{3})


