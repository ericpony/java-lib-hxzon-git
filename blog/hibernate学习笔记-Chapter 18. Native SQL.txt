hibernate学习笔记-Chapter 18. Native SQL

by hxzon

18.1，18.2节。
-------------------------
Chapter 18. Native SQL

You can also express queries in the native SQL dialect of your database. This is useful if you want to utilize database-specific features such as query hints or the CONNECT keyword in Oracle. It also provides a clean migration path from a direct SQLJDBC based application to Hibernate.

Hibernate3 allows you to specify handwritten SQL, including stored procedures, for all create, update, delete, and load operations.


-----------------------------
18.1. Using a SQLQuery



Execution of native SQL queries is controlled via the SQLQuery interface, which is obtained by calling Session.createSQLQuery(). The following sections describe how to use this API for querying.

18.1.1. Scalar queries

The most basic SQL query is to get a list of scalars (values).

sess.createSQLQuery(SELECT  FROM CATS).list();
sess.createSQLQuery(SELECT ID, NAME, BIRTHDATE FROM CATS).list();
These will return a List of Object arrays (Object[]) with scalar values for each column in the CATS table. Hibernate will use ResultSetMetadata to deduce the actual order and types of the returned scalar values.

To avoid the overhead of using ResultSetMetadata, or simply to be more explicit in what is returned, one can use addScalar()

sess.createSQLQuery(SELECT  FROM CATS)
 .addScalar(ID, Hibernate.LONG)
 .addScalar(NAME, Hibernate.STRING)
 .addScalar(BIRTHDATE, Hibernate.DATE)
This query specified

the SQL query string
the columns and types to return
This will return Object arrays, but now it will not use ResultSetMetadata but will instead explicitly get the ID, NAME and BIRTHDATE column as respectively a Long, String and a Short from the underlying resultset. This also means that only these three columns will be returned, even though the query is using  and could return more than the three listed columns.

It is possible to leave out the type information for all or some of the scalars.

sess.createSQLQuery(SELECT  FROM CATS)
 .addScalar(ID, Hibernate.LONG)
 .addScalar(NAME)
 .addScalar(BIRTHDATE)
This is essentially the same query as before, but now ResultSetMetaData is used to determine the type of NAME and BIRTHDATE, where as the type of ID is explicitly specified.

How the java.sql.Types returned from ResultSetMetaData is mapped to Hibernate types is controlled by the Dialect. If a specific type is not mapped, or does not result in the expected type, it is possible to customize it via calls to registerHibernateType in the Dialect.



18.1.2. Entity queries 实体查询（返回实体）

The above queries were all about returning scalar values, basically returning the raw values from the resultset. The following shows how to get entity objects from a native sql query viaaddEntity().

sess.createSQLQuery(SELECT  FROM CATS).addEntity(Cat.class);
sess.createSQLQuery(SELECT ID, NAME, BIRTHDATE FROM CATS).addEntity(Cat.class);
This query specified

the SQL query string
the entity returned by the query
Assuming that Cat is mapped as a class with the columns ID, NAME and BIRTHDATE the above queries will both return a List where each element is a Cat entity.

If the entity is mapped with a many-to-one to another entity it is required to also return this when performing the native query, otherwise a database specific column not found error will occur. The additional columns will automatically be returned when using the  notation, but we prefer to be explicit as in the following example for a many-to-one to a Dog

sess.createSQLQuery(SELECT ID, NAME, BIRTHDATE, DOG_ID FROM CATS).addEntity(Cat.class);
This will allow cat.getDog() to function properly.



18.1.3. Handling associations and collections 处理对象属性和集合属性

It is possible to eagerly join in the Dog to avoid the possible extra roundtrip for initializing the proxy. This is done via the addJoin() method, which allows you to join in an association or collection.

sess.createSQLQuery(SELECT c.ID, NAME, BIRTHDATE, DOG_ID, D_ID, D_NAME FROM CATS c, DOGS d WHERE c.DOG_ID = d.D_ID)
 .addEntity(cat, Cat.class)
 .addJoin(cat.dog);
In this example, the returned Cat's will have their dog property fully initialized without any extra roundtrip to the database. Notice that you added an alias name (cat) to be able to specify the target property path of the join. It is possible to do the same eager joining for collections, e.g. if the Cat had a one-to-many to Dog instead.

sess.createSQLQuery(SELECT ID, NAME, BIRTHDATE, D_ID, D_NAME, CAT_ID FROM CATS c, DOGS d WHERE c.ID = d.CAT_ID)
 .addEntity(cat, Cat.class)
 .addJoin(cat.dogs);
At this stage you are reaching the limits of what is possible with native queries, without starting to enhance the sql queries to make them usable in Hibernate. Problems can arise when returning multiple entities of the same type or when the default aliascolumn names are not enough.



18.1.4. Returning multiple entities 返回多个实体

Until now, the result set column names are assumed to be the same as the column names specified in the mapping document. This can be problematic for SQL queries that join multiple tables, since the same column names can appear in more than one table.

Column alias injection is needed in the following query (which most likely will fail)

sess.createSQLQuery(SELECT c., m.  FROM CATS c, CATS m WHERE c.MOTHER_ID = c.ID)
 .addEntity(cat, Cat.class)
 .addEntity(mother, Cat.class)
The query was intended to return two Cat instances per row a cat and its mother. The query will, however, fail because there is a conflict of names; the instances are mapped to the same column names. Also, on some databases the returned column aliases will most likely be on the form c.ID, c.NAME, etc. which are not equal to the columns specified in the mappings (ID and NAME).

The following form is not vulnerable to column name duplication

sess.createSQLQuery(SELECT {cat.}, {m.}  FROM CATS c, CATS m WHERE c.MOTHER_ID = m.ID)
 .addEntity(cat, Cat.class)
 .addEntity(mother, Cat.class)
This query specified

the SQL query string, with placeholders for Hibernate to inject column aliases
the entities returned by the query
The {cat.} and {mother.} notation used above is a shorthand for all properties. Alternatively, you can list the columns explicitly, but even in this case Hibernate injects the SQL column aliases for each property. The placeholder for a column alias is just the property name qualified by the table alias. In the following example, you retrieve Cats and their mothers from a different table (cat_log) to the one declared in the mapping metadata. You can even use the property aliases in the where clause.

String sql = SELECT ID as {c.id}, NAME as {c.name},  +
         BIRTHDATE as {c.birthDate}, MOTHER_ID as {c.mother}, {mother.}  +
         FROM CAT_LOG c, CAT_LOG m WHERE {c.mother} = c.ID;

List loggedCats = sess.createSQLQuery(sql)
        .addEntity(cat, Cat.class)
        .addEntity(mother, Cat.class).list()
18.1.4.1. Alias and property references

In most cases the above alias injection is needed. For queries relating to more complex mappings, like composite properties, inheritance discriminators, collections etc., you can use specific aliases that allow Hibernate to inject the proper aliases.

The following table shows the different ways you can use the alias injection. Please note that the alias names in the result are simply examples; each alias will have a unique and probably different name when used.

Table 18.1. Alias injection names

Description	Syntax	Example
A simple property	{[aliasname].[propertyname]	A_NAME as {item.name}
A composite property	{[aliasname].[componentname].[propertyname]}	CURRENCY as {item.amount.currency}, VALUE as {item.amount.value}
Discriminator of an entity	{[aliasname].class}	DISC as {item.class}
All properties of an entity	{[aliasname].}	{item.}
A collection key	{[aliasname].key}	ORGID as {coll.key}
The id of an collection	{[aliasname].id}	EMPID as {coll.id}
The element of an collection	{[aliasname].element}	XID as {coll.element}
property of the element in the collection	{[aliasname].element.[propertyname]}	NAME as {coll.element.name}
All properties of the element in the collection	{[aliasname].element.}	{coll.element.}
All properties of the collection	{[aliasname].}	{coll.}


18.1.5. Returning non-managed entities

It is possible to apply a ResultTransformer to native SQL queries, allowing it to return non-managed entities.

sess.createSQLQuery(SELECT NAME, BIRTHDATE FROM CATS)
        .setResultTransformer(Transformers.aliasToBean(CatDTO.class))
This query specified

the SQL query string
a result transformer
The above query will return a list of CatDTO which has been instantiated and injected the values of NAME and BIRTHNAME into its corresponding properties or fields.



18.1.6. Handling inheritance

Native SQL queries which query for entities that are mapped as part of an inheritance must include all properties for the baseclass and all its subclasses.



18.1.7. Parameters

Native SQL queries support positional as well as named parameters支持基于位置和命名的sql参数

Query query = sess.createSQLQuery(SELECT  FROM CATS WHERE NAME like ).addEntity(Cat.class);
List pusList = query.setString(0, Pus%).list();
     
query = sess.createSQLQuery(SELECT  FROM CATS WHERE NAME like name).addEntity(Cat.class);
List pusList = query.setString(name, Pus%).list();



------------------------------
18.2. Named SQL queries 命名查询语句



Named SQL queries can also be defined in the mapping document and called in exactly the same way as a named HQL query (see Section 11.4.1.7, “Externalizing named queries”). In this case, you do not need to call addEntity().

Example 18.1. Named sql query using the sql-query maping element

sql-query name=persons
    return alias=person class=eg.Person
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex}
    FROM PERSON person
    WHERE person.NAME LIKE namePattern
sql-query


Example 18.2. Execution of a named query

List people = sess.getNamedQuery(persons)
    .setString(namePattern, namePattern)
    .setMaxResults(50)
    .list();


The return-join element is use to join associations and the load-collection element is used to define queries which initialize collections,

Example 18.3. Named sql query with association

sql-query name=personsWith
    return alias=person class=eg.Person
    return-join alias=address property=person.mailingAddress
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           address.STREET AS {address.street},
           address.CITY AS {address.city},
           address.STATE AS {address.state},
           address.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS address
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE namePattern
sql-query


A named SQL query may return a scalar value. You must declare the column alias and Hibernate type using the return-scalar element

Example 18.4. Named query returning a scalar

sql-query name=mySqlQuery
    return-scalar column=name type=string
    return-scalar column=age type=long
    SELECT p.NAME AS name, 
           p.AGE AS age,
    FROM PERSON p WHERE p.NAME LIKE 'Hiber%'
sql-query


You can externalize the resultset mapping information in a resultset element which will allow you to either reuse them across several named queries or through the setResultSetMapping() API.

Example 18.5. resultset mapping used to externalize mapping information

resultset name=personAddress
    return alias=person class=eg.Person
    return-join alias=address property=person.mailingAddress
resultset

sql-query name=personsWith resultset-ref=personAddress
    SELECT person.NAME AS {person.name},
           person.AGE AS {person.age},
           person.SEX AS {person.sex},
           address.STREET AS {address.street},
           address.CITY AS {address.city},
           address.STATE AS {address.state},
           address.ZIP AS {address.zip}
    FROM PERSON person
    JOIN ADDRESS address
        ON person.ID = address.PERSON_ID AND address.TYPE='MAILING'
    WHERE person.NAME LIKE namePattern
sql-query


You can, alternatively, use the resultset mapping information in your hbm files directly in java code.

Example 18.6. Programmatically specifying the result mapping information

List cats = sess.createSQLQuery(
        select {cat.}, {kitten.} from cats cat, cats kitten where kitten.mother = cat.id
    )
    .setResultSetMapping(catAndKitten)
    .list();


So far we have only looked at externalizing SQL queries using Hibernate mapping files. The same concept is also available with anntations and is called named native queries. You can use@NamedNativeQuery (@NamedNativeQueries) in conjunction with @SqlResultSetMapping (@SqlResultSetMappings). Like @NamedQuery, @NamedNativeQuery and @SqlResultSetMapping can be defined at class level, but their scope is global to the application. Lets look at a view examples.

Example 18.7, “Named SQL query using @NamedNativeQuery together with @SqlResultSetMapping” shows how a resultSetMapping parameter is defined in @NamedNativeQuery. It represents the name of a defined@SqlResultSetMapping. The resultset mapping declares the entities retrieved by this native query. Each field of the entity is bound to an SQL alias (or column name). All fields of the entity including the ones of subclasses and the foreign key columns of related entities have to be present in the SQL query. Field definitions are optional provided that they map to the same column name as the one declared on the class property. In the example 2 entities, Night and Area, are returned and each property is declared and associated to a column name, actually the column name retrieved by the query.

In Example 18.8, “Implicit result set mapping” the result set mapping is implicit. We only describe the entity class of the result set mapping. The property  column mappings is done using the entity mapping values. In this case the model property is bound to the model_txt column.

Finally, if the association to a related entity involve a composite primary key, a @FieldResult element should be used for each foreign key column. The @FieldResult name is composed of the property name for the relationship, followed by a dot (.), followed by the name or the field or property of the primary key. This can be seen in Example 18.9, “Using dot notation in @FieldResult for specifying associations ”.

Example 18.7. Named SQL query using @NamedNativeQuery together with @SqlResultSetMapping

@NamedNativeQuery(name=night&area, query=select night.id nid, night.night_duration, 
    +  night.night_date, area.id aid, night.area_id, area.name 
    + from Night night, Area area where night.area_id = area.id, 
                  resultSetMapping=joinMapping)
@SqlResultSetMapping(name=joinMapping, entities={
    @EntityResult(entityClass=Night.class, fields = {
        @FieldResult(name=id, column=nid),
        @FieldResult(name=duration, column=night_duration),
        @FieldResult(name=date, column=night_date),
        @FieldResult(name=area, column=area_id),
        discriminatorColumn=disc
    }),
    @EntityResult(entityClass=org.hibernate.test.annotations.query.Area.class, fields = {
        @FieldResult(name=id, column=aid),
        @FieldResult(name=name, column=name)
    })
    }
)


Example 18.8. Implicit result set mapping

@Entity
@SqlResultSetMapping(name=implicit,
                     entities=@EntityResult(entityClass=SpaceShip.class))
@NamedNativeQuery(name=implicitSample, 
                  query=select  from SpaceShip, 
                  resultSetMapping=implicit)
public class SpaceShip {
    private String name;
    private String model;
    private double speed;

    @Id
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Column(name=model_txt)
    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public double getSpeed() {
        return speed;
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }
}


Example 18.9. Using dot notation in @FieldResult for specifying associations

@Entity
@SqlResultSetMapping(name=compositekey,
        entities=@EntityResult(entityClass=SpaceShip.class,
            fields = {
                    @FieldResult(name=name, column = name),
                    @FieldResult(name=model, column = model),
                    @FieldResult(name=speed, column = speed),
                    @FieldResult(name=captain.firstname, column = firstn),
                    @FieldResult(name=captain.lastname, column = lastn),
                    @FieldResult(name=dimensions.length, column = length),
                    @FieldResult(name=dimensions.width, column = width)
                    }),
        columns = { @ColumnResult(name = surface),
                    @ColumnResult(name = volume) } )

@NamedNativeQuery(name=compositekey,
    query=select name, model, speed, lname as lastn, fname as firstn, length, width, length  width as surface from SpaceShip, 
    resultSetMapping=compositekey)
} )
public class SpaceShip {
    private String name;
    private String model;
    private double speed;
    private Captain captain;
    private Dimensions dimensions;

    @Id
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @ManyToOne(fetch= FetchType.LAZY)
    @JoinColumns( {
            @JoinColumn(name=fname, referencedColumnName = firstname),
            @JoinColumn(name=lname, referencedColumnName = lastname)
            } )
    public Captain getCaptain() {
        return captain;
    }

    public void setCaptain(Captain captain) {
        this.captain = captain;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public double getSpeed() {
        return speed;
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }

    public Dimensions getDimensions() {
        return dimensions;
    }

    public void setDimensions(Dimensions dimensions) {
        this.dimensions = dimensions;
    }
}

@Entity
@IdClass(Identity.class)
public class Captain implements Serializable {
    private String firstname;
    private String lastname;

    @Id
    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    @Id
    public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }
}


Tip
If you retrieve a single entity using the default mapping, you can specify the resultClass attribute instead of resultSetMapping
@NamedNativeQuery(name=implicitSample, query=select  from SpaceShip, resultClass=SpaceShip.class)
public class SpaceShip {
In some of your native queries, you'll have to return scalar values, for example when building report queries. You can map them in the @SqlResultsetMapping through @ColumnResult. You actually can even mix, entities and scalar returns in the same native query (this is probably not that common though).

Example 18.10. Scalar values via @ColumnResult

@SqlResultSetMapping(name=scalar, columns=@ColumnResult(name=dimension))
@NamedNativeQuery(name=scalar, query=select lengthwidth as dimension from SpaceShip, resultSetMapping=scalar)


An other query hint specific to native queries has been introduced org.hibernate.callable which can be true or false depending on whether the query is a stored procedure or not.

18.2.1. Using return-property to explicitly specify columnalias names

You can explicitly tell Hibernate what column aliases to use with return-property, instead of using the{}-syntax to let Hibernate inject its own aliases.For example

sql-query name=mySqlQuery
    return alias=person class=eg.Person
        return-property name=name column=myName
        return-property name=age column=myAge
        return-property name=sex column=mySex
    return
    SELECT person.NAME AS myName,
           person.AGE AS myAge,
           person.SEX AS mySex,
    FROM PERSON person WHERE person.NAME LIKE name
sql-query
return-property also works with multiple columns. This solves a limitation with the {}-syntax which cannot allow fine grained control of multi-column properties.

sql-query name=organizationCurrentEmployments
    return alias=emp class=Employment
        return-property name=salary
            return-column name=VALUE
            return-column name=CURRENCY
        return-property
        return-property name=endDate column=myEndDate
    return
        SELECT EMPLOYEE AS {emp.employee}, EMPLOYER AS {emp.employer},
        STARTDATE AS {emp.startDate}, ENDDATE AS {emp.endDate},
        REGIONCODE as {emp.regionCode}, EID AS {emp.id}, VALUE, CURRENCY
        FROM EMPLOYMENT
        WHERE EMPLOYER = id AND ENDDATE IS NULL
        ORDER BY STARTDATE ASC
sql-query
In this example return-property was used in combination with the {}-syntax for injection. This allows users to choose how they want to refer column and properties.

If your mapping has a discriminator you must use return-discriminator to specify the discriminator column.



18.2.2. Using stored procedures for querying 用存储过程查询

Hibernate3 provides support for queries via stored procedures and functions. Most of the following documentation is equivalent for both. The stored procedurefunction must return a resultset as the first out-parameter to be able to work with Hibernate. An example of such a stored function in Oracle 9 and higher is as follows

CREATE OR REPLACE FUNCTION selectAllEmployments
    RETURN SYS_REFCURSOR
AS
    st_cursor SYS_REFCURSOR;
BEGIN
    OPEN st_cursor FOR
 SELECT EMPLOYEE, EMPLOYER,
 STARTDATE, ENDDATE,
 REGIONCODE, EID, VALUE, CURRENCY
 FROM EMPLOYMENT;
      RETURN  st_cursor;
 END;
To use this query in Hibernate you need to map it via a named query.

sql-query name=selectAllEmployees_SP callable=true
    return alias=emp class=Employment
        return-property name=employee column=EMPLOYEE
        return-property name=employer column=EMPLOYER
        return-property name=startDate column=STARTDATE
        return-property name=endDate column=ENDDATE
        return-property name=regionCode column=REGIONCODE
        return-property name=id column=EID
        return-property name=salary
            return-column name=VALUE
            return-column name=CURRENCY
        return-property
    return
    {  = call selectAllEmployments() }
sql-query
Stored procedures currently only return scalars and entities. return-join and load-collection are not supported.

18.2.2.1. Ruleslimitations for using stored procedures 使用存储过程的规则和限制

You cannot use stored procedures with Hibernate unless you follow some procedurefunction rules. If they do not follow those rules they are not usable with Hibernate. If you still want to use these procedures you have to execute them via session.connection(). The rules are different for each database, since database vendors have different stored procedure semanticssyntax.

Stored procedure queries cannot be paged with setFirstResult()setMaxResults().

The recommended call form is standard SQL92 {  = call functionName(parameters) } or{  = call procedureName(parameters}. Native call syntax is not supported.

For Oracle the following rules apply

A function must return a result set. The first parameter of a procedure must be an OUT that returns a result set. This is done by using a SYS_REFCURSOR type in Oracle 9 or 10. In Oracle you need to define a REF CURSOR type. See Oracle literature for further information.
For Sybase or MS SQL server the following rules apply

The procedure must return a result set. Note that since these servers can return multiple result sets and update counts, Hibernate will iterate the results and take the first result that is a result set as its return value. Everything else will be discarded.
If you can enable SET NOCOUNT ON in your procedure it will probably be more efficient, but this is not a requirement.
