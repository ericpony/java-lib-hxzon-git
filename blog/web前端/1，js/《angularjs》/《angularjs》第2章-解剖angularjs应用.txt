《angularjs》第2章-解剖angularjs应用

注释by hxzon

====
Anatomy of an AngularJS Application
（Anatomy，解剖学。）

Unlike typical libraries where you pick and choose functions as you like, everything in
Angular is designed to be used as a collaborative suite. In this chapter we’ll cover all of
the basic building blocks in Angular so you can understand how they fit together. Many
of these blocks will be covered in more detail in later chapters.

Invoking Angular
启用angular

Any application must do two things to start Angular:
1. Load the angular.js library
2. Tell Angular which part of the DOM it should manage with the ng-appdirective

Loading the Script

Loading the library is straightforward and follows the same rules as any other JavaScript
library. You can load the script from Google’s content delivery network (CDN), like so:

<script
src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.4/angular.min.js">
</script>

Using Google’s CDN is recommended. Google’s servers are fast, and the script is cache‐
able across applications. That is, if your user has multiple apps that use Angular, she’ll
have to download only it once. Also, if the user has visited other sites that use the Google
CDN link for Angular, she won’t need to download it again when visiting your site.
If you prefer to host locally (or anywhere else), you can do that too. Just specify the
correct location in the src.

Declaring Angular’s Boundaries with ng-app
用ng-app指令声明angular的作用范围。

The ng-app directive lets you tell Angular which part of your page it should expect to
manage. If you’re building an all-Angular application, you should include  ng-app  as
part of the <html>tag, like so:

<html ng-app>
…
</html>

This tells Angular to manage all DOM elements in the page.
If you’ve got an existing app where some other technology expects to manage the DOM,
such as Java or Rails, you can tell Angular to manage only a part of the page by placing
it on some element like a <div>within the page.

<html>
…
<div ng-app>
…
</div>
…
</html>

Model View Controller

In Chapter 1, we mentioned that Angular supports the Model View Controller style of
application design. Though you have a lot of flexibility in designing your Angular app,
you will always have some flavor of:

• A model containing data that represents the current state of your application.
• Views that display this data.
• Controllers that manage the relationship between your model and your views.

You’ll create your model using object attributes, or even just primitive types containing
your data. There’s nothing special about model variables. If you want to display some
text to the user, you could have a string, like so:

var someText = 'You have started your journey.';

You create your views by writing a template as an HTML page and merging it with data
from your model. As we’ve seen, you can insert a placeholder in the DOM and set its
text like this:

<p>{{someText}}</p>

We call this double-curly syntax interpolation, as it inserts new content into an existing
template.
“插值”语法。

The controllers are classes or types you write to tell Angular which objects or primitives
make up your model by assigning them to the $scope object passed into your controller:

function TextController($scope) {
	$scope.someText = someText;
}

Bringing it all together, we have:

<html ng-app>
<body ng-controller="TextController">
<p>{{someText}}</p>
<script
src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.1/angular.min.js">
</script>

<script>

function TextController($scope) {
	$scope.someText = 'You have started your journey.';
}
</script>
</body>
</html>

Loading this in a browser, you would see:
You have started your journey.

Though this primitive-style model works in simple cases, for most applications you’ll
want to create a model object to contain your data. We’ll create a messages model object
and use it to store our someText. So instead of:

var someText = 'You have started your journey.';

you would write:

var messages = {};
messages.someText = 'You have started your journey.';

function TextController($scope) {
	$scope.messages = messages;
}

and use it in your template as:

<p>{{messages.someText}}</p>

As we’ll see later when we discuss the $scope object, creating a model object like this
will prevent unexpected behavior that could be caused by the prototypal inheritance in
$scope objects.

While we’re discussing practices that will save you in the long run, in the previous
example, we’ve created TextController  in the global  scope. While this is fine for 
examples, the right way to define a controller is as part of something called a module,
which provides a namespace for related parts of your application. 
模块，提供一个命名空间，用来组织相关的部分。
The updated code would look like the following:

<html ng-app='myApp'>
<body ng-controller='TextController'>
<p>{{someText.message}}</p>
<script
src="https://ajax.googleapis.com/ajax/libs/angularjs/1.0.1/angular.min.js">
</script>
<script>
var myAppModule = angular.module('myApp', []);

myAppModule.controller('TextController',
	function($scope) {
		var someText = {};
		someText.message = 'You have started your journey.';
		$scope.someText = someText;
	});
</script>
</body>
</html>

In this version, we told our ng-app element about the name of our module, myApp. We
then called the Angular object to create a module named  myApp  and pass our controller’s
function to a call to that module’s controller function.

We’ll get to all the whys and hows of modules in a bit. For now, just remember that
keeping things out of the global namespace is a good thing and that modules are the
mechanism we use to do so.

Templates and Data Binding
模板和数据绑定。

Templates in Angular applications are just HTML documents that we load from the
server or define in a <script>tag like any other static resource. You define your UI in
the template, using standard HTML plus Angular directives where you need UI com‐
ponents.

Once in the web browser, Angular expands these templates into your full application
by merging your template with data. We saw an example of this in Chapter 1when we
displayed a list of items in the shopping cart:
<div ng-repeat="item in items">
<span>{{item.title}}</span>
...
</div>
Here, it stamps out a copy of the outer <div>, and everything inside it, once for every
element in the items array.

So where does this data come from? In our shopping cart example, we just defined it in
an array in our code. This works great for when you’re starting to build a UI and just
want to test out how it will work. Most apps, however, will use some persistent data
source on the server. Your app in the browser connects to your server and requests
whatever it needs for the page the user is on, and Angular merges it with your template.
The basic startup flow looks like this:
1. A user requests the first page of your application.
2. The user’s browser makes an HTTP connection to your server and loads the  in
dex.htmlpage containing your template.
3. Angular loads into the page, waits for the page to be fully loaded, and then looks
for ng-appto define its template boundaries.
4. Angular traverses the template and looks for directives and bindings. This results
in registration of listeners and DOM manipulation, as well as fetching initial data
from the server. The end result of this work is that the app is bootstrapped and the
template is converted into view as a DOM.
5. You connect to your server to load additional data you need to show the user as
needed.
Steps 1 through 3 are standard for every Angular app. It’s in steps 4 and 5 that you have
choices. These steps can happen synchronously or asynchronously. For performance,
the data your app needs to display to the user on the first view can come down with the
HTML template to avoid multiple requests.
By structuring your application with Angular, your application’s templates are kept sep‐
arate from the data that populates them. The result of this is that these templates are
now cacheable. Only new data need come down to the browser after the first load. Just
as with JavaScript, images, CSS, and other resources, caching these templates can give
your application even better performance.
Displaying Text
You can display and update text anywhere in your UI using the ng-bind  directive. It has
two equivalent forms. One we’ve seen with double-curly braces:
<p>{{greeting}}</p>
Then there’s an attribute-based directive called ng-bind:
<p ng-bind="greeting"></p>
Both are equivalent in their output. If the model variable greeting is set to “Hi there,”
Angular will generate the HTML:
<p>Hi there</p>

And the browser will display “Hi there”.
So why would you use one form over the other? We created the double-curly interpo‐
lation syntax to read more naturally and require less typing. While both forms produce
equivalent output, with the double-curly syntax, on the very first page load of your
application’s  index.html, there’s a chance that your user will see the un-rendered template
before Angular has a chance to replace the curlies with your data. Subsequent views
won’t suffer from this.
The reason is that the browser loads the HTML page, renders it, and only then does
Angular get a chance to interpret it as you intended.
The good news is that you can still use {{ }} in the majority of your templates. For the
data binding you do in your index.html page, however, use ng-bindinstead. That way,
your users will see nothing until the data has loaded.
Form Inputs
Working with form elements in Angular is simple. As we’ve seen in several examples,
you can use the  ng-modelattribute to bind elements to your model properties. This
works with all the standard form elements like text inputs, radio buttons, checkboxes,
and so on. We can bind a checkbox to a property like so:
<form ng-controller="SomeController">
<input type="checkbox" ng-model="youCheckedIt">
</form>
This means that:
1. When the user checks the box, a property called youCheckedIton the  SomeCon
troller’ s  $scopewill become true. Unchecking the box makes youCheckedIt  false.
2. If you set  $scope.youCheckedItto true in  SomeController, the box becomes
checked in the UI. Setting it to false unchecks the box.
Now let’s say we actually want to take action when the user does something. For input
elements, you use the ng-changeattribute to specify a controller method that should be
called whenever the user changes the input’s value. Let’s do a simple calculator to help
startup owners understand how much money they need to get going:
<form ng-controller="StartUpController">
Starting: <input ng-change="computeNeeded()"
ng-model="funding.startingEstimate">
Recommendation: {{funding.needed}}
</form>
For our simplistic example, let’s just set the output to be ten times the user’s estimate.
We’ll also set a default value of zero to start:

function StartUpController($scope) {
$scope.funding = { startingEstimate: 0 };
$scope.computeNeeded = function() {
$scope.needed = $scope.startingEstimate * 10;
};
}
There is, however, a potential problem with the strategy in the preceding code. The issue
is that we’re only recomputing the needed amount when users type in the input field.
This works fine if this input field is only ever updated when users type in this particular
input. But what if other inputs bind to this property in the model? What if it gets updated
when data comes in from the server?
To update the field no matter how it gets updated, we want to use a $scope  function
called $watch(). We’ll talk about watch in detail later in this chapter. The basics are that
you can call $watch()with an expression to observe and a callback that gets invoked
whenever that expression changes.
In this case, we want to watch funding.startingEstimateand call computeNeeded()
whenever it changes. We could then rewrite the StartUpControllerto use this tech‐
nique:
function StartUpController($scope) {
$scope.funding = { startingEstimate: 0 };
computeNeeded = function() {
$scope.funding.needed = $scope.funding.startingEstimate * 10;
};
$scope.$watch('funding.startingEstimate', computeNeeded);
}
Note that the expression to watch is in quotes. Yes, it is a string. This string is evaluated
as something called an Angular expression. Expressions can do simple operations and
have access to the properties in the $scopeobject. We’ll cover expressions more later in
this chapter.
You could also watch the return value of a function, but it won’t work to watch the
property funding.startingEstimateas this evaluates to zero, its initial value, and that
zero never changes.
Then, because our funding.needed  will automatically update whenever funding.star
tingEstimatechanges, we can write a simpler template, like so:
<form ng-controller="StartUpController">
Starting: <input ng-model="funding.startingEstimate">
Recommendation: {{funding.needed}}
</form>

There are some cases where you don’t want to take action on every change; instead, you
want to wait until the user tells you he’s ready. Examples might be completing a purchase
or sending a chat message.
If you have a form that groups inputs, you can use the ng-submit directive on the form
itself to specify a function to call when the form submits. We can extend our previous
example to let the user request funding for her startup by clicking a button: 
<form ng-submit="requestFunding()" ng-controller="StartUpController">
Starting: <input ng-change="computeNeeded()" ng-model="startingEstimate">
Recommendation: {{needed}}
<button>Fund my startup!</button>
</form>
function StartUpController($scope) {
$scope.computeNeeded = function() {
$scope.needed = $scope.startingEstimate * 10;
};
$scope.requestFunding = function() {
window.alert("Sorry, please get more customers first.");
};
}
The ng-submitdirective also automatically prevents the browser from doing its default
POSTaction when it tries to submit the form.
To handle other event cases, like when you want to provide interactions that don’t submit
a form, Angular provides event-handling directives that resemble the browser’s native
event attributes. For onclick, you’d use ng-click. For ondblclick, use ng-dblclick,
and so on.
We can try this out by extending our startup calculator one last time with a reset button
that will reset the input value to zero: 
<form ng-submit="requestFunding()" ng-controller="StartUpController">
Starting: <input ng-change="computeNeeded()" ng-model="startingEstimate">
Recommendation: {{needed}}
<button>Fund my startup!</button>
<button ng-click="reset()">Reset</button>
</form>
function StartUpController($scope) {
$scope.computeNeeded = function() {
$scope.needed = $scope.startingEstimate * 10;
};
$scope.requestFunding = function() {
window.alert("Sorry, please get more customers first.");
};
$scope.reset = function() {

$scope.startingEstimate = 0;
};
}
A Few Words on Unobtrusive JavaScript
At some point in your JavaScript development career, someone probably told you that
you should be writing “unobtrusive JavaScript,” and that using click, mousedown, and
other such inline event handlers in your HTML was a bad idea. He was right.
The idea of unobtrusive JavaScript has been interpreted many ways, but the rationale
for this style of coding is something along the following lines:
1. Not everyone’s browser supports JavaScript. Let everyone see all of your content
and use your app without needing to execute code in the browser.
2. Some folks use browsers that work differently. Visually impaired folks who use
screen-readers and some mobile phone users can ’t use sites with JavaScript.
3. Javascript works differently across different platforms. IE is usually the culprit here.
Y ou need to put in different event-handling code depending on the browser.
4. These event handlers reference functions in the global namespace. It will cause you
headaches when you try to integrate other libraries with functions of the same
names.
5. These event handlers combine structure and behavior. This makes your code more
difficult to maintain, extend, and understand.
In most ways, life was better when you wrote JavaScript in this style. One thing that was
not better, however, was code complexity and readability. Instead of declaring your event
handler actions with the element they act on, you usually had to assign IDs to these
elements, get a reference to the element, and set up event handlers with callbacks. You
could invent a structure to only create these associations in well-known locations, but
most apps ended up with these handler setups littered all over.
In Angular, we decided to reexamine the problem.
The world has changed since these concepts were born. Point #1 is no longer true for
any interesting population. If you’re running a browser without JavaScript, you’re rele‐
gated to sites created in the 1990s. As for point #2, modern screen-readers have caught
up. With proper use of ARIA semantic tags, you can make very rich UIs easily accessible.
Mobile phones now run JavaScript on par with desktop machines.
So now the question is: could we solve #3 and #4 while regaining the readability and
simplicity of the inline technique?
As previously mentioned, for most inline event handlers, Angular has an equivalent in
the form of ng-eventhandler="expression"where eventhandlerwould be replaced

by click, mousedown, change, and so on. If you want to get notified when a user clicks
on an element, you simply use the ng-clickdirective like this:
<div ng-click="doSomething()">...</div>
Is your brain saying “No, no, no! Bad, bad, bad!”? The good news is that you can relax.
These directives differ from their event handler predecessors in that they:
• Behave the same in every browser. Angular takes care of the differences for you.
• Do not operate on the global namespace. The expressions you specify can only
access functions and data that is in the scope of the element’s controller.
This last point may sound a little cryptic, so let’s look at an example. In a typical app,
you would create a nav bar and a content area that changes as you select different menu
options from the nav. We could write the skeleton for it, like so:
<div class="navbar" ng-controller="NavController">
…
<li class="menu-item" ng-click="doSomething()">Something</li>
…
</div>
<div class="contentArea" ng-controller="ContentAreaController">
…
<div ng-click="doSomething()">...</div>
…
</div>
Here both the <li>in the navbar and the  <div>in the content area call a function called
doSomething() when a user clicks on them. As the developer, you set up the function
that these calls refer to in your controller code. They could be the same function or
different ones:
function NavController($scope) {
$scope.doSomething = doA;
}
function ContentAreaController($scope) {
$scope.doSomething = doB;
}
Here, doA()and doB()functions can be the same or different, as you define them.
We’re now left with point #5, combining structure and behavior. This is a hand-wavy
argument, as you can’t point to any concrete negative outcomes, but it’s very similar to
a real problem we had in mind, combining responsibilities of the presentation and your
application logic. This certainly does have the negative side effects that folks talk about
when describing the issue labeled as structure/behavior.

There’s a simple acid test we can use to figure out if our system suffers from this coupling:
can we create a unit test for our app logic that doesn’t require the DOM to be present?
In Angular, yes we can write controllers containing our business logic without having
references to the DOM.The problem was never in the event handlers, but rather in the
way we needed to write JavaScript previously. Notice that in all the controllers we’ve
written so far, here and elsewhere in this book, there are no references to the DOM or
DOM events anywhere. You can easily create these controllers without the DOM. All
of the work of locating elements and handling events happens within Angular.
This matters first when writing unit tests. If you need the DOM, you have to create it
in your test setup, adding to your test complexity. There’s more maintenance because
when your page changes, you need to change the DOM for your tests. Finally, DOM
access is slow. Slow tests mean slow feedback and eventually slow releases. Angular
controller tests have none of these problems.
So there you go. You can happily use declarative event handlers with simplicity and
readability, without the guilt of violating best practices.
Lists, Tables, and Other Repeated Elements
Possibly the most useful Angular directive,  ng-repeatcreates a copy of a set of elements
once for every item in a collection. You should use it everywhere you want to create lists
of things.
Let’s say we’re writing a student roster application for teachers. We’d likely get the student
data from a server, but for this example let’s just define it as a model in JavaScript:
var students = [{name:'Mary Contrary', id:'1'},
{name:'Jack Sprat', id:'2'},
{name:'Jill Hill', id:'3'}];
function StudentListController($scope) {
$scope.students = students;
}
To display this list of students, we can do something like the following:
<ul ng-controller=''>
<li ng-repeat='student in students'>
<a href='/student/view/{{student.id}}'>{{student.name}}</a>
</li>
</ul>
The ng-repeat  will make a copy of all of the HTML inside the tag, including the tag it’s
placed on. With this, we would see:
• Mary Contrary
• Jack Sprat

• Jill Hill
…linking to /student/view/1, /student/view/2, and /student/view/3, respectively .
As we’ve seen before, changing the student’s array will automatically change the ren‐
dered list. If we were to do something like inserting a new student into the list:
var students = [{name:'Mary Contrary', id:'1'},
{name:'Jack Sprat', id:'2'},
{name:'Jill Hill', id:'3'}];
function StudentListController($scope) {
$scope.students = students;
$scope.insertTom = function () {
$scope.students.splice(1, 0, {name:'Tom Thumb', id:'4'});
};
}
and adding a button to invoke it in the template:
<ul ng-controller=''>
<li ng-repeat='student in students'>
<a href='/student/view/{{student.id}}'>{{student.name}}</a>
</li>
</ul>
<button ng-click="insertTom()">Insert</button>
we now see:
• Mary Contrary
• Tom Thumb
• Jack Sprat
• Jill Hill
The ng-repeat directive also gives you references to the index of the current element
via $index, and booleans that tell you if you’re on the first element, somewhere in the
middle, or the last element of the collection with $first, $middle, and $last.
You might imagine using the $index to label rows in a table. Given a template like this:
<table ng-controller='AlbumController'>
<tr ng-repeat='track in album'>
<td>{{$index + 1}}</td>
<td>{{track.name}}</td>
<td>{{track.duration}}</td>
</tr>
</table>
and this controller:

var album = [{name:'Southwest Serenade', duration: '2:34'},
{name:'Northern Light Waltz', duration: '3:21'},
{name:'Eastern Tango', duration: '17:45'}];
function AlbumController($scope) {
$scope.album = album;
}
We get the following:
1 Southwest Serenade 2:34
2 Northern Light Waltz 3:21
3 Eastern Tango 17:45
Hiding and Showing
For menus, context-sensitive tools, and many other cases, showing and hiding elements
is a key feature. As with everything else in Angular, we drive UI changes based on change
in a model, and reflect that change into the UI through directives.
Here, it’s ng-showand ng-hide that do our work. They provide equivalent but inverse
functionality for showing and hiding based on the expression you pass to them. That
is,  ng-show  will show its element when its expression is true and hide it when false. The
ng-hidehides when true and shows when false. You should use whichever makes more
sense to express your intention.
These directives work by setting the element styles to  display:blockto show and
display:noneto hide as appropriate. Let’s take a fictitious example where we’re building
the control panel for a Death Ray.
<div ng-controller='DeathrayMenuController'>
<button ng-click='toggleMenu()'>Toggle Menu</button>
<ul ng-show='menuState.show'>
<li ng-click='stun()'>Stun</li>
<li ng-click='disintegrate()'>Disintegrate</li>
<li ng-click='erase()'>Erase from history</li>
</ul>
<div/>
function DeathrayMenuController($scope) {
$scope.menuState.show = false;
$scope.toggleMenu = function() {
$scope.menuState.show = !$scope.menuState.show;
};
// death ray functions left as exercise to reader
}

CSS Classes and Styles
I t may be obvious by now that you can dynamically set classes and styles in your appli‐
cation just by data binding them using the {{ }}interpolation notation. You can even
compose partial class name matches in your templates. If, for example, you want to
conditionally disable some menus, you might do something like the following to visually
indicate it to your user: 
Given this CSS:
.menu-disabled-true {
color: gray;
}
you could show the stunfunction of your DeathRayas disabled with this template:
<div ng-controller='DeathrayMenuController'>
<ul>
<li class='menu-disabled-{{isDisabled}}' ng-click='stun()'>Stun</li>
...
</ul>
<div/>
where you’d set the isDisabledproperty via your controller as appropriate:
function DeathrayMenuController($scope) {
$scope.isDisabled = false;
$scope.stun = function() {
// stun the target, then disable menu to allow regeneration
$scope.isDisabled = 'true';
};
}
The class on the  stunmenu item will be set to  menu-disabled-  plus the value of
$scope.isDisabled. As this is initially false, the result will be  menu-disabled-false.
As there’s no CSS rule that matches, there will be no effect. When  $scope.isDisa
bledis set to true, the CSS rule becomes  menu-disabled-true, which invokes the rule
to make the text gray.
This technique works equally well when combining inline styles with interpolation, such
as with style="{{some expression}}".
While kind of clever, this technique has the drawback of using a level of indirection in
composing your class names. While you can easily understand it in this small example,
it can quickly become unmanageable having to read both your template and JavaScript
to correctly create your CSS.
Because of this, Angular provides the ng-classand ng-style directives. Each of them
takes an expression. The result of evaluating this expression can be one of the following:

• A string representing space-delimited class names
• An array of class names
• A map of class names to boolean values
Let’s imagine that you want to display errors and warnings to your users in a standard
location in the application’s header. Using the ng-class directive, you could do some‐
thing like this:
.error {
background-color: red;
}
.warning {
background-color: yellow;
}
<div ng-controller='HeaderController'>
...
<div ng-class='{error: isError, warning: isWarning}'>{{messageText}}</div>
…
<button ng-click='showError()'>Simulate Error</button>
<button ng-click='showWarning()'>Simulate Warning</button>
</div>
function HeaderController($scope) {
$scope.isError = false;
$scope.isWarning = false;
$scope.showError = function() {
$scope.messageText = 'This is an error!';
$scope.isError = true;
$scope.isWarning = false;
};
$scope.showWarning = function() {
$scope.messageText = 'Just a warning. Please carry on.';
$scope.isWarning = true;
$scope.isError = false;
};
}
You can even do nifty things like highlighting a selected row in a table. Let’s say we’re
building a restaurant directory and we want to highlight a row that the user clicks on.
In our CSS, we set up the style for a highlighted row:
.selected {
background-color: lightgreen;
}

In the template, we set ng-class to {selected: $index==selectedRow}. This has the
effect of setting the selected class when our model property called  selectedRow  matches
the  ng-repeat’s  $index. We’ll also set up an  ng-clickto notify our controller as to
which row the user clicks: 
<table ng-controller='RestaurantTableController'>
<tr ng-repeat='restaurant in directory' ng-click='selectRestaurant($index)'
ng-class='{selected: $index==selectedRow}'>
<td>{{restaurant.name}}</td>
<td>{{restaurant.cuisine}}</td>
</tr>
</table>
In our JavaScript, we just set up some dummy restaurants and create the  selectRow
function:
function RestaurantTableController($scope) {
$scope.directory = [{name:'The Handsome Heifer', cuisine:'BBQ'},
{name:'Green's Green Greens', cuisine:'Salads'},
{name:'House of Fine Fish', cuisine:'Seafood'}];
$scope.selectRestaurant = function(row) {
$scope.selectedRow = row;
};
}
Considerations for src and href Attributes
When data binding to an <img>or <a>tag, the obvious path of using {{ }} in the src or
href attributes won’t work well. Because browsers are aggressive about loading images
parallel to other content, Angular doesn’t get a chance to intercept data binding requests.
While the obvious syntax for an <img>might be:
<img src="/images/cats/{{favoriteCat}}">
Instead, you should use the ng-srcattribute and write your template as:
<img ng-src="/images/cats/{{favoriteCat}}">
Similarly, for the <a>tag, you should use ng-href:
<a ng-href="/shop/category={{numberOfBalloons}}">some text</a>
Expressions
The goal behind the expressions that you use in templates is to let you be as clever as
you need to be to create hooks between your template, your application logic, and your
data, but at the same time prevent application logic from sneaking into the template.
Until this point, we’ve been mostly using references to data primitives as the expressions
passed to Angular directives. But these expressions can do much more. You can do

simple math (+, -, /, *, %), make comparisons (==, !=, >, <, >=, ⇐), perform boolean
logic (&&, ||, !) and bitwise operations (\^, &, |). You can call functions you expose on
$scopein your controller and you can reference arrays and object notation ([ ], { }, .).
All of these are valid examples of expressions:
<div ng-controller='SomeController'>
<div>{{recompute() / 10}}</div>
<ul ng-repeat='thing in things'>
<li ng-class='{highlight: $index % 4 >= threshold($index)}'>
{{otherFunction($index)}}
</li>
</ul>
</div>
The first expression here, recompute() / 10, while valid, is a good example of putting
logic in the template, and should be avoided. Keeping a separation of responsibilities
between your view and controllers ensures that they’re easy to reason and easy to test.
While you can do quite a lot with expressions, they are computed with a custom parser
that’s part of Angular. They are not evaluated using JavaScript’s  eval(), and are con‐
siderably more restrictive.
Instead, they are evaluated using a custom parser that comes with Angular. In it, you
won’t find looping constructs (for, while, and so on), flow-of-control operators (if-else,
throw) or operators that modify data (++, --). When you need these types of operations,
do them in your controller or via a directive.
Though expressions are more restrictive than JavaScript in many ways, they are more
forgiving to undefinedand null. Instead of throwing a NullPointerExceptionerror,
templates will simply render nothing. This allows you to safely use model values that
haven’t been set yet, and have them appear in the UI as soon as they get populated.
Separating UI Responsibilities with Controllers
Controllers have three responsibilities in your app:
• Set up the initial state in your application’s model
• Expose model and functions to the view (UI template) through $scope
• Watch other parts of the model for changes and take action
We’ve seen many examples of the first two in this chapter already. We’ll get to that last
one in a bit. The conceptual purpose of controllers, however, is to provide the code or
logic to execute the user’s wishes as they interact with the view.
To keep your controllers small and manageable, our recommendation is that you create
one controller per functional area in your view. That is, if you have a menu, create a

MenuController. If you have a navigational breadcrumb, write a BreadcrumbControl
ler, and so on.
You’re probably starting to get the picture, but to be explicit, controllers are tied to a
specific piece of the DOM that they’re in charge of managing. The two main ways of
associating a controller with a DOM node are specifying it in the template by declaring
it in an ng-controllerattribute, and associating it with a dynamically loadable DOM
template fragment, called a view, through a route.
We’ll talk about views and routes later in this chapter.
If you have complex sections of your UI, you can keep your code simple and maintain‐
able, by creating nested controllers that can share model and functions through an
inheritance tree. Nesting controllers is simple; you do it by simply assigning a controller
to a DOM element that is inside another one, like so:
<div ng-controller="ParentController">
<div ng-controller="ChildController">...</div>
</div>
Though we express this as nested controllers, the actual nesting happens in scopes. The
$scope passed to a nested controller prototypically inherits from its parent controller’s
$scope. In this case, this means that the $scope  passed to ChildControllerwill have
access to all the properties of the $scopepassed to ParentController.
Publishing Model Data with Scopes
The $scopeobject passed to our controllers is the mechanism we use to expose model
data to views. You may have other data in your application, but Angular only considers
it part of the model when it can reach these properties through a scope. You can think
of scopes as a context that you use to make changes to your model observable.
We’ve seen many examples of setting up scopes explicitly, as in  $scope.count = 5.
There are also some indirect ways to set up the model from the template itself. You can
do so in the following ways:
1. Through an expression. Since expressions execute in the context of the controller’s
scope associated with their element, setting properties in expressions is the same
as setting a property of the controller’s scope. That is, doing this:
<button ng-click='count=3'>Set count to three</button>
has the same effect as doing this:
<div ng-controller='CountController'>
<button ng-click='setCount()'>Set count to three</button>
</div>
with your CountControllerdefined as:

function CountController($scope) {
$scope.setCount = function() {
$scope.count=3;
}
}
2. Using ng-modelon a form input. As with expressions, the model specified as the
argument for  ng-modelalso works within the scope of the enclosing controller. The
one addition is that this creates a bi-directional data binding between the form field
state and your specified model.
Observing Model Changes with $watch
Possibly the most used of all scope functions is $watch, which notifies you when parts
of your model change. You can watch individual object properties and computed results
(functions), really anything that could be accessed as a property or computed as a Java‐
Script function. The function’s signature is:
$watch(watchFn, watchAction, deepWatch)
The details of each parameter are as follows:
watchFn
This parameter is a string with an Angular expression or a function that returns
the current value of the model that you want to watch. This expression will be
evaluated multiple times, so you need to make sure that it has no side effects. That
is, it can be called multiple times without changing state. For the same reason, watch
expressions should be computationally cheap. If you’ve passed in an Angular ex‐
pression in a string, it will be evaluated against objects available to the scope it’s
called on.
watchAction
This is the function or expression to be called when the watchFnchanges. In the
function form, it receives the new and old values of watchFnas well as a reference
to the scope. Its signature is function(newValue, oldValue, scope).
deepWatch
If set to true, this optional boolean parameter tells Angular to examine each prop‐
erty within the watched object for changes. You’d use this if you wanted to watch
individual elements in an array or properties in an object instead of just a simple
value. As Angular needs to walk the array or object, this can be computationally
expensive if the collection is large.
The $watch  function returns a function that will de-register the listener when you no
longer want to receive change notifications.
If we wanted to watch a property and then later de-register it, we would use the following:

...
var dereg = $scope.$watch('someModel.someProperty', callbackOnChange());
…
dereg();
Let’s revisit our shopping cart scenario from Chapter 1 for a full example. Let’s say that
we want to apply a $10 discount when the customer adds more than $100 worth of
merchandise to her cart. For a template, we’ll use:
<div ng-controller="CartController">
<div ng-repeat="item in items">
<span>{{item.title}}</span>
<input ng-model="item.quantity">
<span>{{item.price | currency}}</span>
<span>{{item.price * item.quantity | currency}}</span>
</div>
<div>Total: {{totalCart() | currency}}</div>
<div>Discount: {{bill.discount | currency}}</div>
<div>Subtotal: {{subtotal() | currency}}</div>
</div>
With a CartController, it would look like the following:
function CartController($scope) {
$scope.bill = {};
$scope.items = [
{title: 'Paint pots', quantity: 8, price: 3.95},
{title: 'Polka dots', quantity: 17, price: 12.95},
{title: 'Pebbles', quantity: 5, price: 6.95}
];
$scope.totalCart = function() {
var total = 0;
for (var i = 0, len = $scope.items.length; i < len; i++) {
total = total + $scope.items[i].price * $scope.items[i].quantity;
}
return total;
}
$scope.subtotal = function() {
return $scope.totalCart() - $scope.discount;
};
function calculateDiscount(newValue, oldValue, scope) {
$scope.bill.discount = newValue > 100 ? 10 : 0;
}
$scope.$watch($scope.totalCart, calculateDiscount);
}

Notice that at the bottom of  CartController, we ’ve set up a watch on the value of
totalCart() which we use to sum up the total price for this purchase. Whenever this
value changes, the watch will call calculateDiscount(), and we get to set the discount
to an appropriate value. If the total is $100, we’ll set the discount to $10. Otherwise, the
discount will be $0.
You can see how this example would look to a user in Figure 2-1.
Figure 2-1. Shopping cart with discount
Performance Considerations in watch()
The preceding example executes correctly, but there is a potential problem with per‐
formance. Though it isn’t obvious, if you put a debugger breakpoint in  totalCart(),
you’d see that it gets called six times to render this page. Though you’d never notice it
in this application, in more complex apps, running it six times could be an issue.
Why six? Three of them we can trace pretty easily, as it runs one time each in:
• The template as {{totalCart() | currency}}
• The subtotal()function
• The $watch()function
Then Angular runs all of these again, bringing us to six. Angular does this to verify that
transitive changes in your model have fully propagated and your model has  settled.
Angular does this checking by making a copy of all watched properties and comparing
them to the current value to see if they’ve changed. In fact, Angular may run this up to
ten times to ensure full propagation. If changes are still occurring after ten iterations,
Angular exits with an error. If that occurs, you probably have a dependency loop that
you’ll need to fix. 
Though you currently need to worry about this, by the time you’ve finished this book
it may be a non-issue. While Angular has had to implement data binding in JavaScript,
we’ve been working with the TC39 folks on a low-level native implementation called
Object.observe(). With this in place, Angular will automatically use  Object.ob
serve()wherever present to give you native-speed data binding.

As you’ll see in the next chapter, Angular has a nice Chrome debugging extension called
Batarang that will automatically highlight expensive data bindings for you.
Now that we know about this issue, there are a few ways we can solve it. One way would
be to create a  $watchon changes to the items array and just recalculate the total, discount,
and subtotal as properties on the $scope.
To do this, we’d update the template to use these properties:
<div>Total: {{bill.total | currency}}</div>
<div>Discount: {{bill.discount | currency}}</div>
<div>Subtotal: {{bill.subtotal | currency}}</div>
Then, in JavaScript, we’d watch the items array, and call a function to calculate the totals
on any change to that array, like so:
function CartController($scope) {
$scope.bill = {};
$scope.items = [
{title: 'Paint pots', quantity: 8, price: 3.95},
{title: 'Polka dots', quantity: 17, price: 12.95},
{title: 'Pebbles', quantity: 5, price: 6.95}
];
var calculateTotals = function() {
var total = 0;
for (var i = 0, len = $scope.items.length; i < len; i++) {
total = total + $scope.items[i].price * $scope.items[i].quantity;
}
$scope.bill.totalCart = total;
$scope.bill.discount = total > 100 ? 10 : 0;
$scope.bill.subtotal = total - $scope.bill.discount;
};
$scope.$watch('items', calculateTotals, true);
}
Notice here that the  $watchspecified  items as a string. This is possible because the
$watch function can take either a function (as we did previously) or a string. If a string
is passed to the $watch function, then it will be evaluated as an expression in the scope
of the $scopeit’s called on.
This strategy might work well for your app. However, since we’re watching the items
array, Angular will have to make a copy of it to compare it for us. For a large list of items,
it may perform better if we just recalculate the bill properties every time Angular eval‐
uates the page. We can do this by creating a $watch with only a watchFn that will recal‐
culate our properties like this:
$scope.$watch(function() {
var total = 0;

for (var i = 0; i < $scope.items.length; i++) {
total = total + $scope.items[i].price * $scope.items[i].quantity;
}
$scope.bill.totalCart = total;
$scope.bill.discount = total > 100 ? 10 : 0;
$scope.bill.subtotal = total - $scope.bill.discount;
});
Watching multiple things
What if you want to watch multiple properties or objects and execute a function when‐
ever any of them change? You’d have two basic options: 
• Put them into an array or object and pass in deepWatchas true.
• Watch a concatenated value of the properties.
In the first case, if you’ve got an object with two properties aand bin your scope, and
want to execute the callMe() function on change, you could watch both of them, like
so:
$scope.$watch('things.a + things.b', callMe(...));
Of course, aand b could be on different objects, and you could make the list as long as
you like. If the list is long, you would likely write a function that returns the concatenated
value rather than relying on an expression for the logic.
In the second case, you might want to watch all the properties on the thingsobject. In
this case, you could do this:
$scope.$watch('things', callMe(...), true);
Here, passing in  trueas the third parameter asks Angular to walk the properties of
thingsand call callMe()on a change to any of them. This works equally well on an
array as it does here on an object.
Organizing Dependencies with Modules
In any non-trivial application, figuring out how to organize the functionality of your
code into areas of responsibility is often a hard task. We’ve seen how controllers give us
a place to put the code that exposes the right data and functions to the view template.
But what about the rest of the code we need to support our applications? The most
obvious place to put this would be in functions on the controllers. 
This works fine for small apps and the examples that we’ve seen so far, but it quickly
becomes unmanageable in real apps. The controllers would become a dumping ground
for everything and anything we need to do. They’d be hard to understand and likely
hard to change. 

Enter modules. They provide a way to group dependencies for a functional area within
your application, and a mechanism to automatically resolve dependencies (also known
as dependency injection). Generically, we call these dependencies services, as they pro‐
vide specific services to our application.
For example, if in our shopping website a controller needs to get a list of items for sale
from the server, we’d want some object—let’s call it Items—to take care of getting the
items from the server. The Items  object, in turn, needs some way to communicate with
the database on the server over XHR or WebSockets.
Doing this without modules looks something like this:
function ItemsViewController($scope) {
// make request to server
…
// parse response into Item objects
…
// set Items array on $scope so the view can display it
...
}
While this would certainly work, it has a number of potential problems.
• If some other controller also needs to get  Itemsfrom the server, we now have to
replicate this code. This makes maintenance a burden, as now if we make schema
or other changes, we have to update that code in several places.
• With other factors like server authentication, parsing complexity, and so on, it is
difficult to reason about the boundaries of responsibility for this controller object,
and reading the code is harder.
• To unit test this bit of code, we’d either need to actually have a server running, or
monkey patchXMLHttpRequest to return mock data. Having to run the server will
make tests very slow, it’s a pain to set up, and it usually introduces flakiness into
tests. The monkey patching route solves the speed and flakiness problems, but it
means you have to remember to un-patch any patched objects between tests, and
it brings additional complexity and brittleness by forcing you to specify the exact
on-the-wire format for your data (and in having to update the tests whenever this
format changes).
With modules, and the dependency injection we get from them, we can write our con‐
troller much more simply, like this:
function ShoppingController($scope, Items) {
$scope.items = Items.query();
}

You’re probably now asking yourself, “Sure, that looks cool, but where does Items  come
from?” The preceding code assumes that we’ve defined Itemsas a service.
Services are singleton (single-instance) objects that carry out the tasks necessary to
support your application’s functionality. Angular comes with many services like $loca
tion, for interacting with the browser’s location, $route, for switching views based on
location (URL) changes, and $http, for communicating with servers.
You can, and should, create your own services to do all of the tasks unique to your
application. Services can be shared across any controllers that need them. As such,
they’re a good mechanism to use when you need to communicate across controllers and
share state. Angular’s bundled services start with a  $, so while you can name them
anything you like, its a good idea to avoid starting them with $ to avoid naming colli‐
sions.
You define services with the module object’s API. There are three functions for creating
generic services, with different levels of complexity and ability:
Function Defines
provider(name, Object
OR constructor() )
A configurable service with complex creation logic. If you pass an Object, it should have a
function named $get that returns an instance of the service. Otherwise, Angular assumes you’ve
passed a constructor that, when called, creates the instance.
factory(name, $get
Function() )
A non-configurable service with complex creation logic. You specify a function that, when
called, returns the service instance. You could think of this as  provider(name, { $get:
$getFunction() } ).
service(name, con
structor() )
A non-configurable service with simple creation logic. Like the constructor option with provider,
Angular calls it to create the service instance.
We’ll look at the configuration option for provider()  later, but let’s discuss an example
with factory()for our preceding Items example. We can write the service like this:
// Create a module to support our shopping views
var shoppingModule = angular.module('ShoppingModule', []);
// Set up the service factory to create our Items interface to the
// server-side database
shoppingModule.factory('Items', function() {
var items = {};
items.query = function() {
// In real apps, we'd pull this data from the server...
return [
{title: 'Paint pots', description: 'Pots full of paint', price: 3.95},
{title: 'Polka dots', description: 'Dots with polka, price: 2.95},
{title: 'Pebbles', description: 'Just little rocks', price: 6.95}
];
};
return items;
});

When Angular creates the ShoppingController, it will pass in  $scope  and the new
I tems service that we’ve just defined. This is done by parameter name matching. That
is, Angular looks at the function signature for our  ShoppingController  class, and
noticesthat it is asking for an  Itemsobject. Since we’ve defined Itemsas a service, it
knows where to get it.
The result of looking up these dependencies as strings means that the arguments of
injectable functions like controller constructors are order-independent. So instead of
this:
function ShoppingController($scope, Items) {...}
we can write this:
function ShoppingController(Items, $scope) {...}
and it all still functions as we intended.
To get this to work with our template, we need to tell the ng-appdirective the name of
our module, like the following:
<html ng-app='ShoppingModule'>
To complete the example, we could implement the rest of the template as:
<body ng-controller="ShoppingController">
<h1>Shop!</h1>
<table>
<td>{{item.title}}</td>
<td>{{item.description}}</td>
<td>{{item.price | currency}}</td>
</tr>
</table>
</div>
with a resulting app that looks like Figure 2-2.
Figure 2-2. Shop items
How Many Modules Do I Need?
As services themselves can have dependencies, the Module API lets you define depen‐
dencies for your dependencies.

In most applications, it will work well enough to create a single module for all the code
you create and put all of your dependencies in it. If you use services or directives from
third-party libraries, they’ll come with their own modules. As your app depends on
them, you’d refer to them as dependencies of your application’s module.
For instance, if you include the (fictitious) modules SnazzyUIWidgets and SuperData‐
Sync, your application’s module declaration would look like this:
var appMod = angular.module('app', ['SnazzyUIWidgets', 'SuperDataSync'];
Formatting Data with Filters
Filters allow you to declare how to transform data for display to the user within an
interpolation in your template. The syntax for using filters is:
{{ expression | filterName : parameter1 : ...parameterN }}
where expression is any Angular expression, filterName  is the name of the filter you
want to use, and the parameters to the filter are separated by colons. The parameters
themselves can be any valid Angular expression.
Angular comes with several filters, like currency, which we’ve seen:
{{12.9 | currency}}
This bit of code will display the following:
$12.90
We put this declaration in the view (rather than in the controller or model) because the
dollar sign in front of the number is only important to humans, and not to the logic we
use to process the number.
Other filters that come with Angular include date, number, uppercase, and more.
Filters can also be chained with additional pipe symbols in the binding. For example,
we can format the previous example for no digits after the decimal by adding the number
filter, which takes the number of decimals to round to as a parameter. So: 
{{12.9 | currency | number:0 }}
displays:
$13
You’re not limited to the bundled filters, and it is simple to write your own. If we wanted
to create a filter that title-cased strings for our headings, for example, we could do so as
follows:
var homeModule = angular.module('HomeModule', []);
homeModule.filter('titleCase', function() {
var titleCaseFilter = function(input) {
var words = input.split(' ');
for (var i = 0; i < words.length; i++) {
words[i] = words[i].charAt(0).toUpperCase() + words[i].slice(1);
}
return words.join(' ');
};
return titleCaseFilter;
});
With a template like this:
<body ng-app='HomeModule' ng-controller="HomeController">
<h1>{{pageHeading | titleCase}}</h1>
</body>
and inserting the pageHeadingas a model variable via a controller:
function HomeController($scope) {
$scope.pageHeading = 'behold the majesty of your page title';
}
we would see something resembling Figure 2-3.
Figure 2-3. Title case filter
Changing Views with Routes and $location
Though AJAX apps are technically single-page apps (in the sense that they only load an
HTML page on the first request, and then just update areas within the DOM thereafter),
we usually have multiple sub-page views that we show or hide from the user, as appro‐
priate.
We can use Angular’s  $routeservice to manage this scenario for us. Routes let you
specify that, for a given URL that the browser points to, Angular should load and display
a template, and instantiate a controller to provide context for the template.
You create routes in your application by calling functions on the  $routeProvider  service
as a configuration block. It goes something like this pseudo-code:
var someModule = angular.module('someModule', [...module dependencies...])
someModule.config(function($routeProvider) {
$routeProvider.
when('url', {controller:aController, templateUrl:'/path/to/tempate'}).
when(...other mappings for your app...).
…
otherwise(...what to do if nothing else matches...);
)};

The preceding code says that when the browser’s URL changes to the specified URL,
Angular will load the template in /path/to/template, and associate the root element of
this template with aController(as if we’d typed ng-controller=aController).
The otherwise()  call in the last line tells the route where to go if nothing else matches.
Let’s put it to use. We’re building an email app that will easily win out over Gmail,
Hotmail, and all the others. We’ll call it…A-Mail. For now, let’s start simply. We’ll have
a first view that displays a list of email messages with a date, title, and the sender. When
you click a message, it should show you a new view with the body of that message.
Due to browser security restrictions, if you’re trying the code out your‐
self, you’ll need to serve it from a web server instead of just  file://. If you
have python installed, you could serve it by executing python -m Sim
pleHTTPServer 8888from your working directory.
For the main template, we’ll do something a bit different. Instead of putting everything
in the first page loaded, we’ll just create a layout template that we’ll put our views into.
We’ll place everything that persists from view to view, like our menus, here. In this case,
we’ll just display a heading with the name of our app. We’ll then use the  ng-view  directive
to tell Angular where we want our views to appear.
index.html
<html ng-app="AMail">
<head>
<script src="src/angular.js"></script>
<script src="src/controllers.js"></script>
</head>
<body>
<h1>A-Mail</h1>
<div ng-view></div>
</body>
</html>
As our view templates will be inserted into the shell we just created, we can write them
as partial HTML documents. For the email list, we’ll use ng-repeatto iterate through
a list of messages and render them into a table.
list.html
<table>
<tr>
<td><strong>Sender</strong></td>
<td><strong>Subject</strong></td>
<td><strong>Date</strong></td>

</tr>
<tr ng-repeat='message in messages'>
<td>{{message.sender}}</td>
<td><a href='#/view/{{message.id}}'>{{message.subject}}</td>
<td>{{message.date}}</td>
</tr>
</table>
Notice here that we’re going to let the user navigate to a particular message by clicking
on the subject. We’ve data bound the URL to message.id, so clicking on a message with
id=1will take the user to  /#/view/1. We’ll use this navigation-by-url, also known as deeplinking, in the message detail view’s controller, to make a particular message available
to the detail view.
To create this message detail view, we’ll create a template that displays properties from
a single message object.
detail.html
<div><strong>Subject:</strong>{{message.subject}}</div>
<div><strong>Sender:</strong>{{message.sender}}</div>
<div><strong>Date:</strong>{{message.date}}</div>
<div>
<strong>To:</strong>
<span ng-repeat='recipient in message.recipients'>{{recipient}} </span>
<div>{{message.message}}</div>
<a href='#/'>Back to message list</a>
Now, to associate these templates with some controllers, we’ll configure the $routePro
viderwith the URLs that invoke our controllers and templates.
controllers.js
// Create a module for our core AMail services
var aMailServices = angular.module('AMail', []);
// Set up our mappings between URLs, templates, and controllers
function emailRouteConfig($routeProvider) {
$routeProvider.
when('/', {
controller: ListController,
templateUrl: 'list.html'
}).
// Notice that for the detail view, we specify a parameterized URL component
// by placing a colon in front of the id
when('/view/:id', {
controller: DetailController,
templateUrl: 'detail.html'
}).
otherwise({
redirectTo: '/'
});
}
// Set up our route so the AMail service can find it
aMailServices.config(emailRouteConfig);
// Some fake emails
messages = [{
id: 0, sender: 'jean@somecompany.com', subject: 'Hi there, old friend',
date: 'Dec 7, 2013 12:32:00', recipients: ['greg@somecompany.com'],
message: 'Hey, we should get together for lunch sometime and catch up.'
+'There are many things we should collaborate on this year.'
}, {
id: 1,  sender: 'maria@somecompany.com',
subject: 'Where did you leave my laptop?',
date: 'Dec 7, 2013 8:15:12', recipients: ['greg@somecompany.com'],
message: 'I thought you were going to put it in my desk drawer.'
+'But it does not seem to be there.'
}, {
id: 2, sender: 'bill@somecompany.com', subject: 'Lost python',
date: 'Dec 6, 2013 20:35:02', recipients: ['greg@somecompany.com'],
message: "Nobody panic, but my pet python is missing from her cage.'
+'She doesn't move too fast, so just call me if you see her."
}, ];
// Publish our messages for the list template
function ListController($scope) {
$scope.messages = messages;
}
// Get the message id from the route (parsed from the URL) and use it to
// find the right message object.
function DetailController($scope, $routeParams) {
$scope.message = messages[$routeParams.id];
}
We’ve created the basic structure for an app with many views. We switch views by
changing the URL. This means that the forward and back buttons just workfor users.
Users are able to bookmark and email links to views within the app, even though there
is only one real HTML page.
Talking to Servers
Okay, enough messing around. Real apps generally talk to real servers. Mobile apps and
the emerging Chrome desktop apps may be exceptions, but for everything else, whether
you want persistence in the cloud or real-time interactions with other users, you prob‐
ably want your app to talk to a server.
For this, Angular provides a service called $http. It has an extensive list of abstractions
that make it easier to talk to servers. It supports vanilla HTTP, JSONP, and CORS. It

includes security provisions to protect from both JSON vulnerabilities and XSRF. It lets
you easily transform the request and response data, and it even implements simple
caching.
Let’s say we want to retrieve products for our shopping site from a server instead of from
our silly in-memory mocks. Writing the server bits is beyond the scope of this book, so
let’s just imagine that we’ve created a service that will return a list of products as JSON
when you make a query to /products.
Given a response that looks like this:
[
{
"id": 0,
"title": "Paint pots",
"description": "Pots full of paint",
"price": 3.95
},
{
"id": 1,
"title": "Polka dots",
"description": "Dots with that polka groove",
"price": 12.95
},
{
"id": 2,
"title": "Pebbles",
"description": "Just little rocks, really",
"price": 6.95
}
...etc...
]
we could write the query like so:
function ShoppingController($scope, $http) {
$http.get('/products').success(function(data, status, headers, config) {
$scope.items = data;
});
}
and use it in a template like this:
<body ng-controller="ShoppingController">
<h1>Shop!</h1>
<table>
<tr ng-repeat="item in items">
<td>{{item.title}}</td>
<td>{{item.description}}</td>
<td>{{item.price | currency}}</td>
</tr>
</table>

</div>
</body>
As we learned previously, we would be better off in the long run by delegating the work
of talking to the server to a service that could be shared across controllers. We’ll take a
look at this structure and the full range of $httpfunctions in Chapter 5.
Changing the DOM with Directives
Directives extend HTML syntax, and are the way to associate behavior and DOM trans‐
formations with custom elements and attributes. Through them, you can create reusable
UI components, configure your application, and do almost anything else you can imag‐
ine wanting to do in your UI template.
You can write apps with the built-in directives that come with Angular, but you’ll likely
run into situations where you want to write your own. You’ll know it’s time to break
into directives when you want to deal with browser events or modify the DOM in a way
that isn’t already supported by the built-in directives. This code of yours belongs in a
directive that you write, and not in a controller, service, or any other place in your app.
As with services, you define directives through the module object’s API by calling its
directive()function, where  directiveFunctionis a factory function that defines
your directive’s features.
var appModule = angular.module('appModule', [...]);
appModule.directive('directiveName', directiveFunction);
Writing the directive factory function is a deep area, and we’ve dedicated an entire
chapter to it in this book. To whet your appetite, though, let’s look at a simple example.
HTML5 has a great new attribute called autofocus that will place keyboard focus on an
input element. You’d use it to let the user start interacting with the element via his
keyboard without having to click on it first. This is great, as it lets you declaratively
specify what you want the browser to do without having to write any JavaScript. But
what if you wanted to place focus on some non-input element, like a link or any div?
And what if you wanted it to work on non-HTML5 browsers as well? We could do it
with a directive.
var appModule = angular.module('app', []);
appModule.directive('ngbkFocus', function() {
return {
link: function(scope, element, attrs, controller) {
element[0].focus();
}
};
});

Here, we’re returning the directive configuration object with its link function specified.
The link function gets a reference to the enclosing scope, the DOM element it lives on,
an array of any attributes passed to the directive, and the controller on the DOM element,
if it exists. Here, we only need to get at the element and call its focus()method.
We can then use it in an example like so:
index.html
<html lang='en' ng-app='app'>
...include angular and other scripts...
<body ng-controller="SomeController">
<button ng-click="clickUnfocused()">
Not focused
</button>
<button ngbk-focus ng-click="clickFocused()">
I'm very focused!
</button>
<div>{{message.text}}</div>
</body>
</html>
controllers.js
function SomeController($scope) {
$scope.message = { text: 'nothing clicked yet' };
$scope.clickUnfocused = function() {
$scope.message.text = 'unfocused button clicked';
};
$scope.clickFocused = function {
$scope.message.text = 'focus button clicked';
}
}
var appModule = angular.module('app', ['directives']);
When the page loads, the user will see the button labeled “I’m very focused!” with the
focus highlight. Hitting the spacebar or the enter key will cause a click and invoke the
ng-click, which will set the div text to ‘focus button clicked’. Opening this example in
a browser, we’d see something that looks like Figure 2-4.
Figure 2-4. Focus directive

Validating User Input
Angular automatically augments  <form>elements with several nice features suitable for
single-page applications. One of these nice features is that Angular lets you declare valid
states for inputs within the form and allow submission only when the entire set of
elements is valid.
For example, if we’re creating a signup form where we require entering a name and
email, but have an optional age field, we can validate several user entries before they are
submitted to the server. Loading the example that follows into a browser will display
what is shown in Figure 2-5.
Figure 2-5. Form validation
We’d want to make sure the user had entered text in the name fields, that he had entered
a properly formed email address, and that if he entered an age, it was valid.
We can do this all in the template, using Angular’s extensions to <form>  and the various
input elements, like this:
<h1>Sign Up</h1>
<form name='addUserForm'>
<div>First name: <input ng-model='user.first' required></div>
<div>Last name: <input ng-model='user.last' required></div>
<div>Email: <input type='email' ng-model='user.email' required></div>
<div>Age: <input type='number'
ng-model='user.age'
ng-maxlength='3'
ng-minlength='1'></div>
<div><button>Submit</button></div>
</form>
Notice that we’re using the required attribute and input types for email and number
from HTML5 to do our validation on some of the fields. This works great with Angular,
and in older non-HTML5 browsers, Angular will polyfill these with directives that per‐
form the same jobs.
We can then add a controller to this to handle the submission by changing the form to
reference it.

<form name='addUserForm' ng-controller="AddUserController">
Inside the controller, we can access the validation state of the form through a property
called $valid. Angular will set this to true when all the inputs in the form are valid. We
can use this  $validproperty to do nifty things such as disabling the Submit button
when the form isn’t completed yet.
We can prevent form submission in an invalid state by adding  ng-disabledto the
Submit button:
<button ng-disabled='!addUserForm.$valid'>Submit</button>
Finally, we might want the controller to tell the user she’s been successfully added. Our
final template would look like:
<h1>Sign Up</h1>
<form name='addUserForm' ng-controller="AddUserController">
<div ng-show='message'>{{message}}</div>
<div>First name: <input name='firstName' ng-model='user.first' required></div>
<div>Last name: <input ng-model='user.last' required></div>
<div>Email: <input type='email' ng-model='user.email' required></div>
<div>Age: <input type='number'
ng-model='user.age'
ng-maxlength='3'
ng-min='1'></div>
<div><button ng-click='addUser()'
ng-disabled='!addUserForm.$valid'>Submit</button>
</ng-form>
with controller:
function AddUserController($scope) {
$scope.message = '';
$scope.addUser = function () {
// TODO for the reader: actually save user to database...
$scope.message = 'Thanks, ' + $scope.user.first + ', we added you!';
};
}
Moving On
In the last two chapters, we looked at all the most commonly used features in the Angular
framework. For each feature discussed, there are many additional details we have yet to
cover. In the next chapter, we’ll get you going by examining a typical development
workflow.


