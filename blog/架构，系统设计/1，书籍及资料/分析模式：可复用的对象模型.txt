分析模式：可复用的对象模型
福勒(Martin Fowler) (作者), 樊东平 (译者), 张路 (译者)
==============
出版社: 机械工业出版社; 第1版 (2010年5月1日)
外文书名: Analysis Patterns : Reusable Object Models
丛书名: 经典重读
平装: 319页
语种： 简体中文
开本: 16
ISBN: 7111305302, 9787111305309
==============
编辑推荐
《分析模式：可复用的对象模型》：Martin Fowler认识到面向对象研究团体需要一本超越传统方法学著作所包含的工具和技术的书，因此撰写了《分析模式可复用的对象模型》，重点介绍面向对象分析和设计的最终结果——模型本身。他将自己丰富的对象建模专业经验与读者分享，着眼于找出重复问题并把这些问题转换为可复用的模型。《分析模式：可复用的对象模型》提供一个模式目录，涉及交易.测量、财务和组织内部关系等广泛领域。

鉴于概念模式不能孤立存在，Martin Fowler还提出一系列“支持模式”，这些支持模式讨论如何将概念模式转变为适合大型信息系统构架的软件。在介绍每种模式时，都讲述设计背后的缘由以及使用这种模式的规则。书中的示例包含有用模型的使用细节并进一步探讨了将会改进分析、建模和实现的复用技巧。

--
媒体推荐
“本书是对不断发展的模式文献的一个重要贡献。它捕捉来自不同领域的深奥的对象建模专业知识，形成一个模式目录。这些领域模式将有助于你解决不同领域中具有挑战性的建模问题。” 
　　——Erich Gamma 
“Martin Fowler为我们给出答案，而不仅仅是一个可以找到这些答案的过程。在本书中，透过作者平实朴素的语言，你将找到自己下一个业务对象模型的重要内容。” 
　　——Ward Cunningham 
“就像‘四人帮’在他们的经典著作《设计模式》中总结出了通用的设计模式，Martin Fowler在这本让人期待已久的书中为我们总结出应用领域的诸多模式。本书是从事面向对象业务建模和业务过程重组工作的所有分析人员和设计人员的必备之书。” 
　　——Donald G. Firesmith

--
作者：（英国）福勒（Martin Fowler） 译者：樊东平 张路 等

福勒（Martin Fowler），在面向对象分析设计、UML、模式、软件开发方法学、XP、重构等方面，都是世界顶级的专家，现为Thought Works公司的首席科学家。Thougtlt Works是一家从事企业应用开发和集成的公司。早在20世纪80年代，Fowler就是使用对象技术构建多层企业应用的倡导者，他著有几本经典书籍：《分析模式》、《UML精粹》和《重构》等。

==============
目录
Ralph Johnson序 
Ward Cunningham序 
前言 

第1章 绪论 1 

1.1 概念模型 1 
1.2 模式世界 4 
1.2.1 Christopher Alexander 5 
1.2.2 描述格式 5 
1.2.3 关于模式的抽象程度 6 
1.3 本书中的模式 7 
1.3.1 建模实例 8 
1.3.2 模式的来源 8 
1.3.3 跨领域的模式 9 
1.4 概念模型与业务过程重组 9 
1.5 模式与框架 10 
1.6 本书的使用 11 

第一部分 分析模式 

第2章 责任模式 17 

2.1 团体 18 
2.2 组织层次 19 
2.3 组织结构 21 
2.4 责任 22 
2.5 责任知识级 24 
2.6 团体类型泛化 26 
2.7 层次型责任 27 
2.8 操作范围 29 
2.9 职位 31 

第3章 观察和测量模式 33 

3.1 数量 34 
3.2 转换率 36 
3.3 复合单位 37 
3.4 测量 38 
3.5 观察 40 
3.6 观察概念的子类型化 43 
3.7 观察方案 44 
3.8 双时间记录 44 
3.9 被否决的观察 45 
3.10 临床观察、假设与推理 45 
3.11 关联观察 46 
3.12 观察过程 48 

第4章 针对公司财务的观察模式 52 

4.1 企业片断 53 
4.1.1 定义维度 57 
4.1.2 维度的属性以及企业片断 59 

4.2 测量方案 60 
4.2.1 保持计算的有效性 61 
4.2.2 比较和因果测量方案 62 
4.2.3 状态类型：定义计划的和实际的状态 63 
4.2.4 构造测量 66 
4.2.5 维度合并 66 

4.3 范围 69 
4.4 带范围的现象 70 
4.4.1 带范围属性的现象 71 
4.4.2 范围函数 73 
4.5 使用最终框架 75 

第5章 引用对象 77 

5.1 名称 77 
5.2 标识方案 79 

5.3 对象合并 81 
5.3.1 复制并替换 82 
5.3.2 替代 82 
5.3.3 本质/表象 83 

5.4 对象等价 83 

第6章 库存与账务 85 

6.1 账目 87 
6.2 事务 88 
6.3 汇总账目 90 
6.4 备注账目 92 

6.5 记入规则 93 
6.5.1 可逆性 94 
6.5.2 不使用事务 94 

6.6 个体实例方法 95 
6.6.1 使用singleton类实现 95 
6.6.2 使用策略模式实现 96 
6.6.3 使用内部case语句实现 97 
6.6.4 使用参数化方法实现 98 
6.6.5 使用解释器实现 98 
6.6.6 实现方式的选择 99 

6.7 记入规则的执行 99 
6.7.1 急切触发 99 
6.7.2 基于账目的触发 101 
6.7.3 基于记入规则的触发 102 
6.7.4 向后链式触发 102 
6.7.5 触发手段的比较 102 

6.8 多个账目的记入规则 103 
6.9 选择条目 106 
6.10 账务实践 107 
6.11 条目来源 109 
6.12 结算单和所得计算书 110 
6.13 对应账目 111 
6.14 专门化的账目模型 112 

6.15 登记条目到多个账目 113 
6.15.1 使用备注账目 116 
6.15.2 派生账目 116 
进一步阅读 118 

第7章 使用财务模型 119 

7.1 结构模型 120 
7.2 结构的实现 122 
7.3 设置新的电话服务 124 
7.4 建立通话 126 
7.5 实现基于账目的触发 127 
7.6 把电话分成白天和夜晚两类 128 
7.7 按时间收费 130 
7.8 计算税款 133 

7.9 结论 134 
7.9.1 记入规则的结构 134 
7.9.2 什么时候不能使用框架 136 
7.9.3 账务实践图 137 

第8章 计划 139 

8.1 提议和执行的动作 140 
8.2 完成和放弃的动作 141 
8.3 挂起 142 
8.4 计划 143 
8.5 方案 146 
8.6 资源分配 149 
8.7 输出和启动函数 153 

第9章 交易 156 

9.1 合同 156 
9.2 合同夹 160 
9.3 报价 165 
9.4 场景 168 

第10章 派生合同 176 

10.1 期货合同 177 

10.2 期权 179 
10.2.1 多头、空头、看涨和看跌：体现一种谋略的词汇 181 
10.2.2 子类型化或者非子类型化 182 

10.3 产品 184 

10.4 子类型状态机 188 
10.4.1 确保状态图的一致 190 
10.4.2 一致性的使用问题 192 

10.5 并行的应用和领域层次结构 194 
10.5.1 应用外观的类型检查 195 
10.5.2 给超类型一个包装性接口 196 
10.5.3 使用一个运行时属性 196 
10.5.4 使应用外观对领域模型可见 198 
10.5.5 使用异常处理 199 

第11章 交易包 201 

11.1 对一个包的多重访问级别 201 
11.2 相互可见性 205 
11.3 包的子类型化 208 
11.4 结论 209 

第二部分 支持模式 

第12章 信息系统的分层构架 213 

12.1 两层构架 214 
12.2 三层构架 215 

12.3 表示层和应用逻辑层 218 
12.3.1 表示层/应用逻辑层分离的优点 222 
12.3.2 在客户/服务器环境中伸展外观 222 

12.4 数据库交互 224 
12.4.1 把领域层连接到数据源 224 
12.4.2 数据库接口层 225 
12.5 结论 227 

第13章 应用外观 229 

13.1 一个医疗保健示例 229 

13.2 外观的内容 231 
13.2.1 方法的类型 232 
13.2.2 样本方法 233 

13.3 公共方法 234 
13.4 操作 235 
13.5 类型转换 236 
13.6 多重外观 237 

第14章 类型模型的模式—设计模板 240 

14.1 实现关联 242 
14.1.1 双向关联和单向关联 243 
14.1.2 关联的接口 243 
14.1.3 基础类型 245 
14.1.4 实现一个单向关联 246 
14.1.5 在两个方向上都使用指针的双向实现 246 
14.1.6 在一个方向上使用指针的双向实现 247 
14.1.7 使用关联对象的双向实现 248 
14.1.8 双向实现的比较 248 
14.1.9 派生映射 249 
14.1.10 非集合映射 249 

14.2 实现泛化 249 
14.2.1 用继承实现 249 
14.2.2 用多重继承组合类实现 250 
14.2.3 用标志实现 250 
14.2.4 用委托给一个隐藏类来实现 251 
14.2.5 通过创建一个替换来实现 253 
14.2.6 泛化的接口 254 
14.2.7 实现hasType操作 255 

14.3 对象创建 255 
14.3.1 创建的接口 256 
14.3.2 创建的实现 256 

14.4 对象析构 256 
14.4.1 析构的接口 257 
14.4.2 析构的实现 257 

14.5 入口点 258 
14.5.1 查找对象的接口 259 
14.5.2 查找操作的实现 260 
14.5.3 使用类或者登记表对象 260 

14.6 实现约束 260 
14.7 其它技术的设计模板 261 

第15章 关联模式 263 

15.1 关联类型 264 
15.2 带键值的映射 266 
15.3 历史映射 268 

第16章 后记 273 

第三部分 附 录 
附录A 技术和符号 277 
附录B 模式列表 293 
索引 301