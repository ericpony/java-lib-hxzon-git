（hxzon学习笔记）clojure-流程控制

补充by hxzon
======

clojure-基本语法-流程控制
http://dead-knight.iteye.com/blog/1828668
http://dead-knight.iteye.com/blog/1829618

hxzon摘要：

1，标准流程控制
if，if-not，if-let，
when，when-not，when-let，
cond，condp，cond-> ，cond->> ，
case，do，
loop..recur。
while（循环）。

2，异常处理
try..catch..finally，throw。
assert。

3，基于函数的流程控制
repeatedly（重复执行函数），iterate（返回延迟序列）。

4，基于序列的流程控制。
dotimes，doseq，for。

5，or，and，not。

============
一、标准的流程控制 

----
1，if： 
将一个判断表达式作为它的第一个参数进行求值。
如果求值为true，那么就返回它的第二个参数（相当于“then”子句）的求值结果。
如果结果为false（包括nil）就返回第三个参数的求值结果（相当于“else”子句），前提是有提供第三个参数并且不为空。 

user=> (defn is-small [number] (if (< number 100) "yes" "no"))  
#'user/is-small  

user=> (is-small 50)  
"yes"  

user=> (is-small 110)  
"no"  

if条件中除了false和nil，其他都为true： 

user=> (if true "true")  
"true"  
user=> (if 0 "true")  
"true"  
user=> (if "" "true")  
"true"  
user=> (if nil "true")  
nil  
user=> (if false "true")  
nil  

----
2，if-not： 
跟 if 的用法相同，但是作用是相反的。
当逻辑为false的时候会去计算第二个参数的值，为true的时候才计算第三个参数的值。

user=> (if-not (zero? 0) "no" "yes")  
"yes"  
user=> (if (not (zero? 0)) "no" "yes")  
"yes"  

----
3，if-let： 
if-let宏接受两个参数，第一个参数为绑定变量，第二个参数为表达式。
并根据第二个表达式参数返回的值确定执行then、else语句。 

user=> (defn if-let-test [arg] (if-let [x arg] "true" "false"))  
#'user/if-let-test  

user=> (if-let-test 1)  
"true"  
user=> (if-let-test nil)  
"false"  
user=> (if-let-test false)  
"false"  

--
if-let
macro
Usage: (if-let bindings then)
       (if-let bindings then else & oldform)
bindings => binding-form test

If test is true, evaluates then with binding-form bound to the value of test, if not, yields else
如果 test 为真，那么结合 binding-form 绑定，对 then 部分进行求值。
如果 test 为假，那么对 else 部分进行求值。

user=> (defn sum-all-even-number [all-number]
           (if-let [all-even-number (filter even? all-number)]
               (reduce + all-even-number)
               0))
#'user/sum-all-even-number

（hxzon：这里test表达式为(filter even? all-number)，找出偶数，如果含有偶数，整体为真，则绑定到all-even-number。）

user=> (sum-all-even-number [1 2 3 4 5 6 7 8 9])
20  ; 2 + 4 + 6 + 8

user=> (sum-all-even-number [1 3 5 7 9])
0

http://clojure-api-cn.readthedocs.org/en/latest/clojure.core/if-let.html

(defmacro if-let
  "bindings => binding-form test

  If test is true, evaluates then with binding-form bound to the value of 
  test, if not, yields else"
  {:added "1.0"}
  ([bindings then]
   `(if-let ~bindings ~then nil))
  ([bindings then else & oldform]
   (assert-args
     (vector? bindings) "a vector for its binding"
     (nil? oldform) "1 or 2 forms after binding vector"
     (= 2 (count bindings)) "exactly 2 forms in binding vector")
   (let [form (bindings 0) tst (bindings 1)]
     `(let [temp# ~tst]
        (if temp#
          (let [~form temp#]
            ~then)
          ~else)))))

----
4，when: 
when没有else子句，如果when后面第一个参数为true，则执行条件后的所有语句，否则返回nil。 

user=> (when false (println "is true") "return true")  
nil  

user=> (when true (println "is true") "return true")  
is true  
"return true"  

user=> (def has-value (when true (println "hello world") "returned value"))  
hello world  
#'user/has-value  

user=> has-value  
"returned value"  

----
5，when-not： 
when-not与when类似，只是第一个参数返回false，才执行后面所有语句，否则返回nil。 

user=> (when-not  false (println "is true") "return true")  
is true  
"return true"  
user=> (when-not true (println "is true") "return true")  
nil  

----
6，when-let： 
when-let与if-let类似，只有绑定变量值不是false、nil时，才执行后面所有语句，否则直接返回nil。 

user=> (when-let [a true] (println "true") "return true")  
true  
"return true"  

user=> (when-let [a false] (println "true"))  
nil  

user=> (when-let [a nil] (println "true"))  
nil  

----
7，cond： 
cond 可以有任意个“判断/表达式”对，作为它的参数。
如果满足第一个判断，就执行第一个判断对应的表达式。
如果没有满足第一个条件，就会尝试后面的判断表达式，以此类推。
如果一个都没有满足，那么返回 nil 。
除非你用一个 :else 关键字放在最后来抓住剩下的所有可能性。

cond类似于java中的if..else if...else语句。 

user=> (defn f [n] (cond (< n 0) "<0" (< n 10) "<10" :else ">=10"))  
#'user/f  

user=> (f -2)  
"<0"  

user=> (f 2)  
"<10"  

user=> (f 10)  
">=10"  

----
7.1，condp
macro
Usage: (condp pred expr & clauses)

condp类似于if(pred test-expr expr)...else if(pred test-expr expr) 。

Takes a binary predicate, an expression, and a set of clauses.
pred是一个两元谓词。

Each clause can take the form of either:
test-expr result-expr
result-expr :>> result-fn
Note :>> is an ordinary keyword.
（ordinary，普通。）
每个子句或者含有测试表达式和结果表达式两部分，
或者含有 test-expr  :>> result-fn 三部分（这里，:>> 只是一个普通关键字）。

For each clause, (pred test-expr expr) is evaluated. 
pred以expr表达式和每个子句的测试表达式求值。
If it returns logical true, the clause is a match. 
如果谓词返回真，这个子句匹配。
If a binary clause matches, the result-expr is returned, 
如果子句是两部分，返回子句的result-expr的值。
if a ternary clause matches, its result-fn,
which must be a unary function, is called with the result of the predicate as its argument, 
the result of that call being the return value of condp. 
如果子句是三部分，
子句的result-fn部分必须是一元函数，将谓词表达式的值作为它的参数，返回result-fn的值。

A single default expression can follow the clauses,
and its value will be returned if no clause matches. 
在最后，可以有一个没有测试表达式的子句，作为默认值。
If no default expression is provided and no clause matches, 
an IllegalArgumentException is thrown.
如果没有子句匹配，也没有提供默认值，将抛出异常。

(defrecord Point [x y]
    Matrix
    (lookup [pt i j]
        (when (zero? j)
            (case i
                  0 x
                  1 y)))
    (update [pt i j value]
        (if (zero? j)
            (condp = i
                0 (Point. value y)
                1 (Point. x value))
            pt))
    (rows [pt] [[x] [y]])
    (cols [pt] [[x y]])
    (dims [pt] [2 1]))

(condp some [1 2 3 4]
         #{0 6 7} :>> inc
         #{4 5 9} :>> dec
         #{1 2 3} :>> #(+ % 3))
;= 3

(some #{0 6 7}  [1 2 3 4] )
;= nil
(some #{4 5 9} [1 2 3 4])
;= 4
----
7.2，cond->
macro
Usage: (cond-> expr & clauses)

Takes an expression and a set of test/form pairs. 
Threads expr (via ->) through each form for which the corresponding test expression is true. 

Note that, unlike cond branching, 
cond-> threading does not short circuit after the first true test expression.
和cond不一样，cond->不是短路的。

----
7.3，cond->>
macro
Usage: (cond->> expr & clauses)

Takes an expression and a set of test/form pairs. 
Threads expr (via ->>) through each form for which the corresponding test expression is true.
  
Note that, unlike cond branching, 
cond->> threading does not short circuit after the first true test expression.
和cond不一样，cond->>不是短路的。

----
8，case： 
case可以简单理解为java中switch的case，如下 

user=> (let [mystr "hello"];首先绑定mystr的值为hello  
          (case mystr    
            "" 0   
            "hello" (count mystr)));case用于匹配mystr的值  
5       

user=> (let [mystr "no match"]   
          (case mystr    
                "" 0   
                "hello" (count mystr)   
                "default")) ;最后一个表达式只有匹配不成功时才执行  
"default"  

--
case可以用列表一次匹配多个值： 

user=> (defn f [x] (case x  
       (5 10) "*5"  
       (3 6 9) "*3"  
       "others"))  
#'user/f  

user=> (f 5)  
"*5"  

user=> (f 10)  
"*5"  

user=> (f 6)  
"*3"  

user=> (f 1)  
"others"  

----
9，do： 
do执行多条语句，返回最后一条语句值 

user=> (def v (do (println 123) (println 321) -1))  
123  
321  
#'user/v  

user=> v  
-1  

----
10，loop、recur： 

如果递归的层次太深的话，那么可能会产生内存不足的情况。
所以一些编程语言利用 “tail call optimization” (TCO)的技术来解决这个问题。
在Clojure里面避免这个问题的一个办法是使用loop 和recur。 

;定义递归语句完成10+9+……1=55  
user=> (loop [sum 0 cnt 10] (if (= cnt 0) sum (recur (+ cnt sum) (dec cnt))))  
55  

--
(def factorial
  (fn [n]
    (loop [cnt n acc 1]
       (if (zero? cnt)
            acc
          (recur (dec cnt) (* acc cnt))))))

（hxzon：
loop建立了一个递归点。
初始时，用n和1初始化cnt和acc。
执行到recur时，cnt和acc重新绑定为（dec cnt）和（* acc cnt），
再次回到loop处开始执行。
）

--
loop/recur 组合把一个看似递归的调用变成一个迭代，迭代不需要占用栈空间。 
loop special form 跟let special form 类似的地方是它们都会建立一个本地binding，但是同时它也建立一个递归点，
而这个递归点就是recur的参数里面的那个函数。

loop给这些binding一个初始值。
对recur 的调用使得程序的控制权返回给loop， 并且给那些本地binding赋了新的值。
给recur传递的参数一定要和loop所创建的binding的个数一样。
同样recur只能出现在loop这个special form的最后一行。

--
recur
special form
Usage: (recur exprs*)

Evaluates the exprs in order, then, in parallel, rebinds the bindings of the recursion point to the values of the exprs.
Execution then jumps back to the recursion point, a loop or fn method.

Please see http://clojure.org/special_forms#recur

--
loop
special form
Usage: (loop [bindings*] exprs*)

Evaluates the exprs in a lexical context in 
which the symbols in the binding-forms are bound to their respective init-exprs or parts therein. 
Acts as a recur target.

----
11，while
macro
Usage: (while test & body)

Repeatedly executes body while test expression is true. 
Presumes some side-effect will cause test to become false/nil. 
Returns nil.
当test表达式为true时不断执行body，确保test能变为false或nil。
返回nil。

============
二、异常处理
 
Clojure代码里面抛出来的异常都是运行时异常。
当然从Clojure代码里面调用的java代码还是可能抛出那种需要检查的异常的。

----
try,catch,finally 以及throw 提供了和java里面类似的功能: 

user=> (try (throw (Exception. "error")) (finally (println "final")))  
final  
Exception error  user/eval310 (NO_SOURCE_FILE:1)  


user=> (try (/ 3 0) (catch Exception e (println e)))  
#<ArithmeticException java.lang.ArithmeticException: Divide by zero>  
nil  

----
assert： 
它测试一个表达式， 如果这个表达式的值为false的话，它会抛出异常。 

user=> (assert true)  
nil  

user=> (assert false)  
AssertionError Assert failed: false  user/eval317 (NO_SOURCE_FILE:1)  

user=> (assert nil)  
AssertionError Assert failed: nil  user/eval319 (NO_SOURCE_FILE:1)  

user=> (assert 0)  
nil  

user=> (assert [1 2 3])  
nil  

user=> (assert "foo")  
nil  


==========
三、基于函数的流程控制 

----
1，repeatedly： 
repeatedly字面意思为重复函数。一般的用法如下： 

user=> (repeatedly 5 #(rand-int 11))  
(6 8 2 6 6)  

重复产生5次随机数。
rand-int 11表示0至11的随机数。 

--
这里顺便提一下repeat函数：repeat函数接受一/两个常量参数，用法如下： 

user=> (repeat 5 (int (rand-int 100)))  
(30 30 30 30 30)  

当repeat、repeatedly函数只接受一个参数时（即没有重复次数的参数），需要配合take来中止，否则会产生内存溢出的错误。

user=> (repeatedly #(rand-int 11))  
OutOfMemoryError Java heap space  java.util.Arrays.copyOf (Arrays.java:2882)  

user=> (take 5 (repeatedly #(rand-int 11)))  
(10 7 0 2 8)  

----
2，iterate： 
(iterate f v)
返回一个惰性序列， 序列元素的值为 x 、 (f x) 、 (f (f x)) 、 (f (f (f x))) ， 诸如此类。
函数 f 必须是无副作用的。 
相当于： 
while(true) { v = f(v) } 
所以一般要配合(take n sequence)来中止。

user=> (take 10 (iterate inc 5)) ; (5 6 7 8 9 10 11 12 13 14)  
user=> (take 10 (iterate #(+ % 5) 5)) ; (5 10 15 20 25 30 35 40 45 50)  
user=> (take 10 (iterate #(* % 2) 2)) ; (2 4 8 16 32 64 128 256 512 1024)  


========
四、基于序列的流程控制

----
1，dotimes： 
dotimes 会执行给定的表达式一定次数, 一个本地binding会被给定值：从0到一个给定的数值。

user=> (dotimes [num 3] (println "number:" (inc num)))  
number: 1  
number: 2  
number: 3  
nil  

--
dotimes
macro
Usage: (dotimes bindings & body)
bindings => name n

Repeatedly executes body (presumably for side-effects) with name
bound to integers from 0 through n-1.

----
2，doseq： 
doseq和for的语法是一样的，只不过for返回lazy seq而doseq接受任意数量的表达式，以有副作用的方式执行它们，并且返回nil 。

user=> (doseq [i (range 10)] (println i))  
0  
1  
2  
3  
4  
5  
6  
7  
8  
9  
nil  

user=> (doseq [i [1 2 3] j [10 20]] (println i "-" j))  
1 - 10  
1 - 20  
2 - 10  
2 - 20  
3 - 10  
3 - 20  
nil  

--
doseq
macro
Usage: (doseq seq-exprs & body)

Repeatedly executes body (presumably for side-effects) with bindings and filtering as provided by "for".  
Does not retain the head of the sequence. 
Returns nil.

----
3，for： 
for、doseq都支持遍历多个集合(最右边的最快)，同时还可以用:when 和 :while来过滤。 

--
http://qiujj.com/static/clojure-handbook.html

clojure中的for，类似于scala的for..yield和Python的list comps。
用于简化map、filter、#()、fn。

user=> (for [x (range 3 7)] (* x x))  
(9 16 25 36) 

(for [i (range 10)] (* i i)) 
; (0 1 4 9 16 25 36 49 64 81)

(for [i (range 10) :when (> 20 (* i i))] (* i i)) 
; (0 1 4 9 16) 平方小于20。

注：上例中(* i i)算了两次没有必要，可用:let来解决。

(for [i (range 10) :let [ii (* i i)] :when (> 20 ii)] ii)
map对单个集合的操作都可以用for来代替（选择原则：很简单的用map，其他都用for）。

user=> (for [x [0 1 2 3 4 5] :let [y (* x 3)] :when (even? y)] y)  
(0 6 12)  

上面语句可理解为：先定义x为集合，再使用let将y赋值为x*3，最后判断y是否为偶数，偶数才返回。

例子：
(map (comp count str) '[aa bbb cccc])      
; (2 3 4)

(for [i '[aa bbb cccc]] (count (str i)))   
; (2 3 4)

例子：
(map #(* % %) [1 2 3 4 5]))  
; (1 4 9 16 25)

(for [i [1 2 3 4 5]] (* i i))
 
for比map少的功能：不能操作多个集合，如(map + [1 2] [10 20] [100 200]) 。
for比map多出来的功能：可用多个变量，还可加when。

例子：乘法口诀表
(for	[i (range 1 10) j (range 1 10) :when (>= i j)]  ;只保留i小于等于j的组合。
		(str j "x" i "=" (* i j))) 

(for 	[i (range 1 10) j (range 1 (inc i))] 	;每次遍历i时，j从1到(inc i) 。
		(str j "x" i "=" (* i j)))
该简单问题的最佳解决方案还是分而治之：
(defn f [n] 
		(for [i (range 1 (inc n))] (format "%d*%d=%d" i n (* i n))))
(dotimes [i 9] (println (f (inc i))))

--
for循环中进行解构。
(for [[a b c] '((A B C) (D E F))] b) 
; (B E)
不需要的也可忽略：
(for [[a b] '((A B C) (D E F))] b) 
; (B E)

还可以使用 &:
(for [ [a & r] '((A B C) (D E F))]  r) 
; ((B C) (E F))

--
区别:when和:while
(for [x [1 2 0 3 4] :when (pos? x)] x)   
; (1 2 3 4) 全部做完为止

(for [x [1 2 0 3 4] :while (pos? x)] x)  
; (1 2)     碰到不满足就停

(for [i (range 10) :when (even? i)] i) 
; (0 2 4 6 8) 做到完

(for [i (range 10) :while (even? i)] i) 
; (0) 碰到false停止

多个变量：
(for [x (range 10) y (range 3) :while (< y x)] [x y])

(for [a [1 3 5] b [2 4]] [a b]) 
; ([1 2] [1 4] [3 2] [3 4] [5 2] [5 4]) 组合。
 
 
例子：找杨辉三角形
(defn tri-yang? [a b] (def c (Math/sqrt (+ (* a a) (* b b)))) (= (int c) c))

(defn f [n] (for [a (range 1 n) b (range (inc a) n) :when (tri-yang? a b)] (list a b)))

(f 21) 
; ((3 4) (5 12) (6 8) (8 15) (9 12) (12 16) (15 20))


--
for
macro
Usage: (for seq-exprs body-expr)

List comprehension. 
Takes a vector of one or more binding-form/collection-expr pairs, 
each followed by zero or more modifiers, and yields a lazy sequence of evaluations of expr.
Collections are iterated in a nested fashion, rightmost fastest,
and nested coll-exprs can refer to bindings created in prior binding-forms.  
Supported modifiers are: 
 :let [binding-form expr ...], :while test, :when test.

(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))

========
========
1，or
macro
Usage: (or)
       (or x)
       (or x & next)

Evaluates exprs one at a time, from left to right. 
If a form returns a logical true value, or returns that value 
and doesn't evaluate any of the other expressions, 
otherwise it returns the value of the last expression. (or) returns nil.

从左到右，每次计算一个形式，如果该形式返回逻辑真值，停下，返回该值。
否则，继续，直到返回最后一个形式的值。
如果没有任何形式，返回nil。

2，and
macro
Usage: (and)
       (and x)
       (and x & next)

Evaluates exprs one at a time, from left to right. 
If a form returns logical false (nil or false), 
and returns that value and doesn't evaluate any of the other expressions, 
otherwise it returns the value of the last expr. 
(and) returns true.

从左到右，每次计算一个形式，如果该形式返回逻辑假值（nil或false），停下，返回该值。
否则，继续，直到返回最后一个形式的值。
如果没有任何形式，返回true。

3，not
function
Usage: (not x)

Returns true if x is logical false, false otherwise.
返回相反的逻辑值。

4，