linux学习笔记001-磁盘与目录的容量（df和du）

《鸟哥的linux私房菜：基础篇：第八章、Linux 磁盘与文件系统管理》
http://vbird.dic.ksu.edu.tw/linux_basic/0230filesystem.php


2. 文件系统的简单操作
　　2.1 磁盘与目录的容量： df, du
　　2.2 实体链接与符号链接： ln


============
1，磁盘与目录的容量：

现在我们知道磁盘的整体数据是在 superblock 区块中，但是每个各别文件的容量则在 inode 当中记载的。 
那在文字接口底下该如何叫出这几个数据呢？底下就让我们来谈一谈这两个命令：

df：列出文件系统的整体磁盘使用量；
du：评估文件系统的磁盘使用量(常用在推估目录所占容量)

--------
df

[root@www ~]# df [-ahikHTm] [目录或文件名]

选项与参数：
-a  ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；
-T  ：连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；
-i  ：不用硬盘容量，而以 inode 的数量来显示
-h  ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；

-H  ：以 M=1000K 取代 M=1024K 的进位方式；
-k  ：以 KBytes 的容量显示各文件系统；
-m  ：以 MBytes 的容量显示各文件系统；

--
范例一：将系统内所有的 filesystem 列出来！
[root@www ~]# df

Filesystem      1K-blocks      Used Available Use% Mounted on
/dev/hdc2         9920624   3823112   5585444  41% /
/dev/hdc3         4956316    141376   4559108   4% /home
/dev/hdc1          101086     11126     84741  12% /boot
tmpfs              371332         0    371332   0% /dev/shm

# 在 Linux 底下如果 df 没有加任何选项，那么默认会将系统内所有的 
# (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！
# 至于那个 /dev/shm 是与内存有关的挂载，先不要理他！

--
范例二：将容量结果以易读的容量格式显示出来
[root@www ~]# df -h

Filesystem            Size  Used Avail Use% Mounted on
/dev/hdc2             9.5G  3.7G  5.4G  41% /
/dev/hdc3             4.8G  139M  4.4G   4% /home
/dev/hdc1              99M   11M   83M  12% /boot
tmpfs                 363M     0  363M   0% /dev/shm

# 不同于范例一，这里会以 G/M 等容量格式显示出来，比较容易看啦！

--
范例三：将系统内的所有特殊文件格式及名称都列出来
[root@www ~]# df -aT

Filesystem    Type 1K-blocks    Used Available Use% Mounted on
/dev/hdc2     ext3   9920624 3823112   5585444  41% /
proc          proc         0       0         0   -  /proc
sysfs        sysfs         0       0         0   -  /sys
devpts      devpts         0       0         0   -  /dev/pts
/dev/hdc3     ext3   4956316  141376   4559108   4% /home
/dev/hdc1     ext3    101086   11126     84741  12% /boot
tmpfs        tmpfs    371332       0    371332   0% /dev/shm
none   binfmt_misc         0       0         0   -  /proc/sys/fs/binfmt_misc
sunrpc  rpc_pipefs         0       0         0   -  /var/lib/nfs/rpc_pipefs

# 系统里面其实还有很多特殊的文件系统存在的。
那些比较特殊的文件系统几乎都是在内存当中，例如 /proc 这个挂载点。
因此，这些特殊的文件系统都不会占据硬盘空间。

--
范例四：将 /etc 底下的可用的磁盘容量以易读的容量格式显示
[root@www ~]# df -h /etc

Filesystem            Size  Used Avail Use% Mounted on
/dev/hdc2             9.5G  3.7G  5.4G  41% /

# 这个范例比较有趣一点啦，在 df 后面加上目录或者是文件时， df
# 会自动的分析该目录或文件所在的 partition ，并将该 partition 的容量显示出来，
# 所以，您就可以知道某个目录底下还有多少容量可以使用了！ ^_^

--
范例五：将目前各个 partition 当中可用的 inode 数量列出
[root@www ~]# df -ih 

Filesystem            Inodes   IUsed   IFree IUse% Mounted on
/dev/hdc2               2.5M    147K    2.3M    6% /
/dev/hdc3               1.3M      46    1.3M    1% /home
/dev/hdc1                26K      34     26K    1% /boot
tmpfs                    91K       1     91K    1% /dev/shm

# 这个范例则主要列出可用的 inode 剩余量与总容量。分析一下与范例一的关系，
# 你可以清楚的发现到，通常 inode 的数量剩余都比 block 还要多呢

先来说明一下范例一所输出的结果信息为：

Filesystem：代表该文件系统是在哪个 partition ，所以列出装置名称；
1k-blocks：说明底下的数字单位是 1KB 呦！可利用 -h 或 -m 来改变容量；
Used：顾名思义，就是使用掉的硬盘空间啦！
Available：也就是剩下的磁盘空间大小；
Use%：就是磁盘的使用率啦！如果使用率高达 90% 以上时， 最好需要注意一下了，免得容量不足造成系统问题喔！
(例如最容易被灌爆的 /var/spool/mail 这个放置邮件的磁盘)
Mounted on：就是磁盘挂载的目录所在啦！(挂载点啦！)

由于 df 主要读取的数据几乎都是针对一整个文件系统，
因此读取的范围主要是在 Superblock 内的信息， 所以这个命令显示结果的速度非常的快速！
在显示的结果中你需要特别留意的是那个根目录的剩余容量！ 
因为我们所有的数据都是由根目录衍生出来的，因此当根目录的剩余容量剩下 0 时，那你的 Linux 可能就问题很大了。

另外需要注意的是，如果使用 -a 这个参数时，系统会出现 /proc 这个挂载点，但是里面的东西都是 0 ，不要紧张！ 
/proc 的东西都是 Linux 系统所需要加载的系统数据，而且是挂载在『内存当中』的， 所以当然没有占任何的硬盘空间啰！

至于那个 /dev/shm/ 目录，其实是利用内存虚拟出来的磁盘空间！ 
由于是透过内存仿真出来的磁盘，因此你在这个目录底下创建任何数据文件时，访问速度是非常快速的！(在内存内工作) 
不过，也由于他是内存仿真出来的，因此这个文件系统的大小在每部主机上都不一样，
而且创建的东西在下次启动时就消失了！ 因为是在内存中嘛！

---------
du

[root@www ~]# du [-ahskm] 文件或目录名称

选项与参数：
-a  ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。
-h  ：以人们较易读的容量格式 (G/M) 显示；
-s  ：列出总量而已，而不列出每个各别的目录占用容量；
-S  ：不包括子目录下的总计，与 -s 有点差别。
-k  ：以 KBytes 列出容量显示；
-m  ：以 MBytes 列出容量显示；

--
范例一：列出目前目录下的所有文件容量
[root@www ~]# du

8       ./test4     <==每个目录都会列出来
8       ./test2
....中间省略....
12      ./.gconfd   <==包括隐藏文件的目录
220     .           <==这个目录(.)所占用的总量

# 直接输入 du 没有加任何选项时，则 du 会分析『目前所在目录』
# 的文件与目录所占用的硬盘空间。但是，实际显示时，仅会显示目录容量(不含文件)，
# 因此 . 目录有很多文件没有被列出来，所以全部的目录相加不会等于 . 的容量喔！
# 此外，输出的数值数据为 1K 大小的容量单位。


--
范例二：同范例一，但是将文件的容量也列出来
[root@www ~]# du -a

12      ./install.log.syslog   <==有文件的列表了
8       ./.bash_logout
8       ./test4
8       ./test2
....中间省略....
12      ./.gconfd
220     .

--
范例三：检查根目录底下每个目录所占用的容量
[root@www ~]# du -sm /*

7       /bin
6       /boot
.....中间省略....
0       /proc
.....中间省略....
1       /tmp
3859    /usr     <==系统初期最大就是他了啦！
77      /var
# 这是个很常被使用的功能～利用通配符 * 来代表每个目录，
# 如果想要检查某个目录下，哪个次目录占用最大的容量，可以用这个方法找出来
# 值得注意的是，如果刚刚安装好 Linux 时，那么整个系统容量最大的应该是 /usr 
# 而 /proc 虽然有列出容量，但是那个容量是在内存中，不占硬盘空间。


与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据， 
所以上述第三个范例命令的运行会运行一小段时间！
此外，在默认的情况下，容量的输出是以 KB 来设计的， 如果你想要知道目录占了多少 MB ，那么就使用 -m 这个参数即可啰！
而如果你只想要知道该目录占了多少容量的话，使用 -s 就可以啦！

至于 -S 这个选项部分，由于 du 默认会将所有文件的大小均列出，
因此假设你在 /etc 底下使用 du 时， 所有的文件大小，包括 /etc 底下的次目录容量也会被计算一次。
然后最终的容量 (/etc) 也会加总一次， 因此很多朋友都会误会 du 分析的结果不太对劲。
所以啰，如果想要列出某目录下的全部数据， 或许也可以加上 -S 的选项，减少次目录的加总喔！


==========
2，链接文件（略）





