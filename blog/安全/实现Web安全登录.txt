实现Web安全登录
http://blog.csdn.net/zhgflx/article/details/4440750

对于 Web 应用程序，安全登录是很重要的。但是目前大多数 Web 系统在发送登录密码时是发送的明文，这样很容易被入侵者监听到密码。当然，通过 SSL 来实现安全连接是个不错的方法，但是很多情况下我们没办法将服务器设置为带有 SSL 的 Web 服务器。因此如果在登录系统中加入安全登录机制，则可以在没有 SSL 的 Web 服务器上实现安全登录。

要实现安全登录，可以采用下面三种方法，一种基于非对称加密算法，一种基于对称加密算法，最后一种基于散列算法。下面我们来分别讨论这三种方法。

非对称加密算法中，目前最常用的是 RSA 算法和 ECC（椭圆曲线加密）算法。要采用非对称加密算法实现安全登录的话，首先需要在客户端向服务器端请求登录页面时，服务器生成公钥和私钥，然后将公钥随登录页面一起传递给客户端浏览器，当用户输入完用户名密码点击登录时，登录页面中的 JavaScript 调用非对称加密算法对用户名和密码用用公钥进行加密。然后再提交到服务器端，服务器端利用私钥进行解密，再跟数据库中的用户名密码进行比较，如果一致，则登录成功，否则登录失败。

看上去很简单，但是这里有这样几个问题。目前 RSA 算法中，1024－2048 位的密钥被认为是安全的。如果密钥长度小于这个长度，则认为可以被破解。但这样的长度超过了程序设计语言本身所允许的数字运算范围，需要通过模拟来实现大数运算。而在 Web 系统的客户端，如果通过 JavaScript 来模拟大数运行的话，效率将会是很低的，因此要在客户端采用这样的密钥来加密数据的话，许多浏览器会发出执行时间过长，停止运行的警告。然而，解密或者密钥生成的时间相对于加密来说要更长。虽然解密和密钥生成是在服务器端执行的，但是如果服务器端是 PHP、ASP 这样的脚本语言的话，它们也将很难胜任这样的工作。ECC 算法的密钥长度要求比 RSA 算法要低一些，ECC 算法中 160 位的密钥长度被认为与 RSA 算法中 1024 位的密钥长度的安全性是等价的。虽然仍然要涉及的模拟大数运算，但 ECC 算法的密钥长度的运算量还算是可以接受的，但是 ECC 算法比 RSA 算法要复杂的多，因此实现起来也很困难。

对称加密算法比非对称加密算法要快得多，但是对称加密算法需要数据发送方和接受方共用一个密钥，密钥是不能通过不安全的网络直接传递的，否则密钥和加密以后的数据如果同时监听到的话，入侵者就可以直接利用监听到的密钥来对加密后的信息进行解密了。

那是不是就不能通过对称加密算法实现安全登录呢？其实只要通过密钥交换算法就可以实现安全登录了，常用的密钥交换算法是 Diffie-Hellman 密钥交换算法。我们可以这样来实现密钥的安全传递，首先在客户端向服务器端请求登录页面时，服务器端生成一个大素数 p，它的本原根 g，另外生成一个随机数 Xa，然后计算出 Ya = gXa mod p，将 p、g、Ya 连同登录页面一起发送给客户端，然后客户端也生成一个随机数 Xb，计算 Yb = gXb mod p，然后再计算 K = YaXb mod p，现在 K 就是密钥，接下来就可以用 K 作密钥，用对称加密算法对用户输入进行加密了，然后将加密后的信息连同计算出来的 Yb一同发送给服务器端，服务器端计算 K = YbXa mod p，这样就可以得到跟客户端相同的密钥 K 了，最后用客户端加密算法的相应解密算法，就可以在服务器端将加密信息进行解密了，信息解密以后进行比较，一致则登录成功，否则登录失败。需要注意的时候，这里服务器端生成的随机数 Xa 和 客户端生成的随机数 Xb 都不传递给对方。传递的数据只有 p、g、Ya、Yb 和加密后的数据。

但是如果我们不采用加密算法而采用散列算法对登录密码进行处理的话，可以避免被直接解密出原文，但是如果直接采用 MD5 或者 SHA1 来对登录密码进行处理后提交的话，一旦入侵者监听到散列后的密码，则不需要解密出原文，直接将监听到的数据提交给服务器，就可以实现入侵的目的了。而且，目前 MD5 算法已被破解，SHA1 算法则被证明从理论上可破解，就算采用离线碰撞，也可以找出与原密码等价的密码来。所以直接采用 MD5 或者 SHA1 来对密码进行散列处理也是不可行的。

但是如果在散列算法中加入了密钥，情况就不一样了。hmac 算法正好作了这样的事情，下面我们来看看如何用 hmac 算法实现安全登录。首先在客户端向服务器端请求登录页面时，服务器端生成一个随机字符串，连同登录页面一同发送给客户端浏览器，当用户输入完用户名密码后，将密码采用 MD5 或者 SHA1 来生成散列值作为密钥，服务器端发送来的随机字符串作为消息数据，进行 hmac 运算。然后将结果提交给服务器。之所以要对用户输入的密码进行散列后再作为密钥，而不是直接作为密钥，是为了保证密钥足够长，而又不会太长。服务器端接受到客户端提交的数据后，将保存在服务器端的随机字符串和用户密码进行相同的运算，然后进行比较，如果结果一致，则认为登录成功，否则登录失败。当然如果不用 hmac 算法，直接将密码和服务器端生成的随机数合并以后再做 MD5 或者 SHA1，应该也是可以的。

这里客户端每次请求时服务器端发送的随机字符串都是不同的，因此即使入侵者监听到了这个随机字符串和加密后的提交的数据，它也无法再次提交相同的数据通过验证。而且通过监听到的数据也无法计算出密钥，所以也就无法伪造登录信息了。

对称和非对称加密算法不仅适用于登录验证，还适合用于最初的密码设置和以后密码修改的过程中，而散列算法仅适用于登录验证。但是散列算法要比对称和非对称加密算法效率高。