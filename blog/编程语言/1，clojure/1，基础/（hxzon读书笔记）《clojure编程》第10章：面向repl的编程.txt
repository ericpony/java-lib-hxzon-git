（hxzon读书笔记）《clojure编程》第10章：面向repl的编程

by hxzon
====
1，clojure总是被编译的，没有解释器。
clojure编译器在运行时也是完全可用的，
这使得整个语言在运行时可用，因而也可用于clojure repl。

2，交互式开发。

程序和程序员之间的反馈循环更紧密。

----
defonce在当前命名空间里定义了一个var的值，
但不会重新定义已经有值的任何var。

----
持续，演化的环境。

-1，clojure不要求基于文件的工作流。
-2，clojure设计的许多基础方面，明确鼓励（或者不阻止）在运行时动态重定义它的结构。

=======
3，工具集。

JLine
rlwrap
nREPL

Emacs：inferior-lisp，SLIME。

----
repl绑定的var：
*1，*2，*3存有最近求值的表达式的值。
*e提供repl会话里发生的最后一个未捕获的异常。

clojure.repl命名空间里的几个有用的函数。

pst将会打印提供的任何异常的堆栈追踪，默认绑定到*e 。

apropos，显示在载入的命名空间里有什么函数，根据正则表达式或字符串匹配。

find-doc，在文档里搜索。

source，打印从源文件载入的任何函数的源代码。

doc，打印给定var的文档。

dir，打印给定命名空间里声明的公共var列表。

----
内省命名空间，见《（hxzon学习笔记）clojure-命名空间，关键字，符号及相关函数》。

=======
4，在repl里调试、监测，打补丁。

需要注意的问题：
所有的改变都是临时的。
clojure repl的网络实现没有提供安全和访问控制。

=======
5，重定义结构的限制。

5.1，主要是jvm本身的限制。

-1，固定的classpath。
jvm的classpath通常不能在运行时修改或扩展，
这意味着不能载入和使用在jvm/clojure进程启动时没有预期或不存在的新依赖。
其中一种绕过的办法：pomegranate。

-2，gen-class从来都不是动态的。
gen-class严格在提前编译时生成静态的java类。
jvm生态系统已经演化出一些方法来重新载入和更新静态类。

-3，类实例永远保留inline实现。
由deftype和defrecord定义的类的Inline接口和协议实现，
不能动态更新这些类的已有实现。
一种解决办法是，把实现委派给单独的函数，以便根据需要可重新定义，使用#'varA 写法。

----
5.2，clojure特有的两个问题。

-1，重定义宏不会重新扩展对宏的使用。
例如一个函数的定义里使用了宏，那它需要重新编译。

-2，重新定义多重方法，不会更新多重方法的转发函数。
defmulti有defonce的语义，
解决方法是用ns-unmap来解除多重方法的var，但这会要求重新载入多重方法的每个方法实现。

-3，理解何时捕获一个值，而不是解引用一个var 。

varA捕获当时的值。
#‘varA捕获此时的值。

(defn a [x] (+ 5 x))
;= #'user/a

(def b (partial a 5))
;= #'user/b

(def c (partial #'a 5))
;= #'user/c

(b)
;= 10

(c)
;= 10

(defn a [x] (+10 b))
;= #'user/a

(b)
;= 10

(c)
;= 15



