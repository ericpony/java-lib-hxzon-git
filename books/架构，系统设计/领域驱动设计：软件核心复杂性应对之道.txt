领域驱动设计：软件核心复杂性应对之道
~ 埃文斯(Eric Evans) (作者), 赵俐 (译者), 盛海艳 (译者), 刘霞 (译者), 等 (译者)
============
出版社: 人民邮电出版社; 第1版 (2010年11月1日)
外文书名: Domain-Driven Design:Tackling Complexity in the Heart of Software
丛书名: 图灵程序设计丛书
平装: 369页
语种： 简体中文
开本: 16
ISBN: 9787115238870, 7115238871
----
编辑推荐

《领域驱动设计:软件核心复杂性应对之道》：众多世界级软件大师鼎力推荐
凝聚领域建模专家数十年的实战经验
深度剖析构建高质量复杂系统的核心技术
《领域驱动设计》与《企业应用架构模式》两大名著精髓的实战演练
领域模型使开发人员可以表达丰富的软件功能需求，由此实现的软件可以满足用户真正的需要，因此被公认为是软件设计的关键所在，其重要性显而易见。但讲述如何将领域模型用于软件开发过程的优秀实用资料却不多见。《领域驱动设计:软件核心复杂性应对之道》正是这一领域最著名的作品，受到众多业界大师的赞美和推介，广受读者好评。
要通过创建领域模型来加速复杂的软件开发，就需要利用大量最佳实践和标准模式在开发团队中形成统一的交流语言；不仅重构代码，而且要重构代码底层的模型；同时采取反复迭代的敏捷开发方法，深入理解领域特点，促进领域专家与程序员的良好沟通。针对这些内容，《领域驱动设计:软件核心复杂性应对之道》结合真实项目，系统地介绍了领域驱动开发的目标、意义和方法，充分讨论了复杂系统的建模与设计问题。
《领域驱动设计:软件核心复杂性应对之道》将指导面向对象开发人员、系统分析人员和设计人员合理地组织工作，各有侧重、彼此协作，有条不紊地进行复杂系统的开发，帮助他们建立丰富而实用的领域模型，并由此创建长期适用的优质软件。
Eric Evans强调要聚焦于软件的核心领域，以它来驱动开发。软件能够在市场上卖出去，是因为它封装了別的软件所没有的一些核心领域知识、这就是核心竞争力，是利润所在的地方，也是最值得下工夫的地方，再难也不能逃避。
----
媒体推荐

“这本书应该出现在每个软件开发人员的书架上。”
　　——Kent Beck 软件开发方法学泰斗，极限编程的创始人
“Eric的这本书太棒太神奇了，他准确地告诉你如何让软件设计满足你理想中的模型需求。……本书读起来趣味无穷，Eric有许多有趣的故事，而且描述起来很有一套。它出版后将成为软件开发人员必读的经典之作。”
　　——Ralph Johnson 《设计模式》的作者
“如果你认为自己在面向对象编程中的投资没有收到回报，那么读了本书你就会知道自己漏掉了什么。”
　　——Ward Cunningham 设计模式和敏捷软件方法的先驱
“Eric Evarts力证作为开发核心的领域模型的重要性，他搭建了一个稳固的框架并提供了一套实现技术和技巧。这里沉淀下来的是亘古不变的智慧，在应时的方法论都沦为明日黄花后，它依然光华璀璨。”
　　——Dave Collins Designing Object-Oriented User Interfaces的作者
“Eric完全从实战者的角度着笔，描述了无处不用的语言、与用户共享模型的好处、对象生命周期的管理、深度重构的过程和结果，这是对我们这个领域的巨大贡献。”
　　——Luke Hohmann Beyond Software Architecture的作者
----
作者简介

作者：（美国）埃文斯（Eric Evans） 译者：赵俐 盛海艳 刘霞 等

Eric Evans，世界著名软件建模专家，创建了Domain Language公司，致力于帮助公司机构创建与业务紧密相关的软件。他在全球各地宣讲领域驱动设计的思想，开设课程，参加会议，接受专访，拥有大批的追随者。从20世纪80年代开始，他就以设计师和程序员的双重身份参与过许多大型面向对象系统的设计和开发，涉及各种复杂的业务和技术领域，同时，他还培训和指导过许多开发团队开展极限编程实践。

===================
目录

第一部分 让领域模型发挥作用

第1章 消化知识 5 

1.1 有效建模的因素 9 
1.2 知识消化 10 
1.3 持续学习 11 
1.4 知识丰富的设计 12 
1.5 深层模型 15 

第2章 交流及语言的使用 17 

2.1 通用语言 17 
2.2 利用对话改进模型 22 
2.3 一个团队，一种语言 24 
2.4 文档和图 25 
2.4.1 书面的设计文档 27 
2.4.2 执行的基础 29 
2.5 说明性模型 29 

第3章 将模型和实现绑定 32 

3.1 模型驱动设计 33 
3.2 建模范型和工具支持 36 
3.3 突出主旨：为什么模型对用户很关键 41 
3.4 实践型建模人员 43 

第二部分 模型驱动设计的构建块 

第4章 分离领域 47 

4.1 分层架构 47 
4.1.1 层间的联系 51 
4.1.2 架构框架 51 

4.2 模型属于领域层 52 
4.3 其他种类的隔离 55 

第5章 软件中的模型描述 56 

5.1 关联 57 

5.2 实体(又称引用对象) 62 
5.2.1 实体建模 65 
5.2.2 设计标识操作 66 

5.3 值对象 68 
5.3.1 设计值对象 71 
5.3.2 设计包含值对象的关联 73 

5.4 服务 74 
5.4.1 服务和分隔的领域层 75 
5.4.2 粒度 77 
5.4.3 访问服务 77 

5.5 模块(包) 77 
5.5.1 敏捷的模块 79 
5.5.2 基础结构驱动打包的缺陷 80 

5.6 建模范式 82 
5.6.1 对象范式的优势 82 
5.6.2 对象世界中的非对象 84 
5.6.3 在混合范式中使用模型驱动设计 85 

第6章 领域对象的生命周期 87 

6.1 聚合 88 

6.2 工厂 96 
6.2.1 工厂及其应用场所的选择99 
6.2.2 只需构造函数的情况 101 
6.2.3 接口的设计 102 
6.2.4 如何放置不变量的逻辑 103 
6.2.5 实体工厂与值对象工厂 103 
6.2.6 存储对象的重建 103 

6.3 仓储 105 
6.3.1 查询仓储 109 
6.3.2 了解仓储实现的必要性 111 
6.3.3 实现仓储 111 
6.3.4 在框架内工作 113 
6.3.5 与工厂的关系 113 

6.4 为关系数据库设计对象 115 

第7章 使用语言：扩展示例 117 

7.1 货物运输系统概述 117 
7.2 隔离领域：系统简介 119 
7.3 区分实体和值对象 120 
7.4 运输领域中的关联设计 121 
7.5 聚合的边界 123 
7.6 选择仓储 124 

7.7 场景概述 125 
7.7.1 应用特性示例：改变一件货物的目的地126 
7.7.2 应用特性示例：重复业务126 

7.8 对象的创建 126 
7.8.1 cargo的工厂和构造函数 126 
7.8.2 添加一个handling event127 

7.9 停下来重构：cargo聚合的另一种设计 129 
7.10 运输模型中的模块 131 

7.11 引入新特性：配额检查 133 
7.11.1 连接两个系统 134 
7.11.2 改进模型：划分业务 135 
7.11.3 性能调整 137 

7.12 小结 137 

第三部分 面向更深层解的重构 

第8章 突破 143 

8.1 关于突破的故事 144 
8.1.1 中看不中用的模型 144 
8.1.2 突破 146 
8.1.3 更深层的模型 148 
8.1.4 冷静的决定 149 
8.1.5 成效 150 

8.2 时机 150 
8.3 着眼于根本 151 
8.4 尾声：一连串的新理解 151 

第9章 隐含概念转变为显式概念 153 

9.1 概念挖掘 153 
9.1.1 倾听表达用语 154 
9.1.2 检查不协调之处 157 
9.1.3 研究矛盾之处 162 
9.1.4 查阅书籍 162 
9.1.5 尝试，再尝试 164 

9.2 如何建模不太明显的概念 164.. 
9.2.1 显式的约束 165 
9.2.2 作为领域对象的流程 167 
9.2.3 规格 168 
9.2.4 规格的应用和实现 171 

第10章 柔性设计 184 

10.1 释意接口 186 
10.2 无副作用函数 190 
10.3 断言 194 
10.4 概念轮廓 197 
10.5 孤立类 201 
10.6 操作封闭 203 
10.7 声明性设计 205 
10.8 一个声明性风格的设计 207 

10.9 攻击角度 215 
10.9.1 切分子领域 215 
10.9.2 尽可能利用现成的形式 216 

第11章 应用分析模式 225 

第12章 把设计模式和模型联系起来 237 

12.1 策略 238 
12.2 组合 241 
12.3 为什么不用flyweight？ 245 

第13章 向更深层理解重构 247 

13.1 发起重构 247 
13.2 探索团队 248 
13.3 前期工作 249 
13.4 针对开发人员设计 249 
13.5 时机选择 250 
13.6 将危机视为机会 250 

第四部分 战略性设计 

第14章 维护模型完整性 255 

14.1 限界上下文 257 
14.2 持续集成 261 

14.3 上下文映射 263 
14.3.1 在上下文边界上的测试 269 
14.3.2 组织和文档化上下文映射 269 

14.4 限界上下文之间的关系 270 

14.5 共享内核 271 
14.6 顾客/供应商开发团队 272 
14.7 同流者 275 

14.8 防腐层 277 
14.8.1 设计防腐层的接口 279 
14.8.2 实现防腐层 279 
14.8.3 一个关于警戒的故事 282 

14.9 隔离方式 282 
14.10 开放主机服务 284 
14.11 公布语言 284 
14.12 盲人摸象 287 

14.13 选择模型上下文的策略 290 
14.13.1 团队或更高层的决策 290 
14.13.2 把自己放在上下文中 291 
14.13.3 转换边界 291 
14.13.4 接受我们不能改变的东西：描绘外部系统 292 
14.13.5 与外部系统的关系 292 
14.13.6 在设计系统 293 
14.13.7 满足不同模型的特别需要 293 
14.13.8 部署 294 
14.13.9 权衡 295 
14.13.10 考虑项目已经进行的情况 295 

14.14 转换 296 
14.14.1 合并上下文：隔离方式→共享内核 296 
14.14.2 合并上下文：共享内核→持续集成 297 
14.14.3 逐步淘汰原有系统 298 
14.14.4 开放主机服务→公布语言 299 

第15章 精炼 301 

15.1 核心领域 302 
15.1.1 选择核心 305 
15.1.2 谁来负责精炼工作 305 

15.2 精炼的逐步升级 306 

15.3 通用子域 307 
15.3.1 通用不一定可重用 312 
15.3.2 项目风险管理 313 

15.4 领域愿景声明 313 

15.5 突出核心 315 
15.5.1 精炼文档 316 
15.5.2 把核心标记出来 317 
15.5.3 把精炼文档作为开发过程的工具 318 

15.6 内聚机制 319 
15.6.1 通用子域与内聚机制 320 
15.6.2 属于核心领域的机制 321 

15.7 精炼到声明性风格 321 

15.8 隔离核心 322 
15.8.1 创建隔离核心的代价 323 
15.8.2 推进团队决策 323 

15.9 抽象核心 328 
15.10 深层模型精炼 329 
15.11 选择重构的目标 329 

第16章 大比例结构 330 

16.1 渐进顺序 333 
16.2 系统隐喻 335 
16.3 职责层 337 
16.4 知识级别 349 
16.5 插件框架 356 
16.6 结构的约束 360 

16.7 重构到合适的结构 361 
16.7.1 最小化 362 
16.7.2 交流和自律 362 
16.7.3 结构重组产生柔性设计 362 
16.7.4 精炼为开发指路 363 

第17章 综合应用战略性设计 364 

17.1 大比例结构和限界上下文的结合 364 
17.2 大比例结构和精炼的结合 367 
17.3 首先进行评估 369 

17.4 由谁制定策略 369 
17.4.1 在开发过程中自发产生 369 
17.4.2 以客户为中心的架构团队 370 

17.5 制定战略性设计决策的6个要点 370 
17.5.1 技术框架同样如此 373 
17.5.2 提防总体规划 374 

第18章 尾声 375 
附录a 关于模式 380 
附录b 术语表 383 

附录c 参考文献 387 
附录d 关系图 389



