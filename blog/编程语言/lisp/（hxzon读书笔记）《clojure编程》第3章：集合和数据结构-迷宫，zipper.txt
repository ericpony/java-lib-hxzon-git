（hxzon读书笔记）《clojure编程》第3章：集合和数据结构-迷宫，zipper

(defn maze
"Returns a random maze carved out of walls; walls is a set of
2-item sets #{a b} where a and b are locations.
The returned maze is a set of the remaining walls."
[walls]
(let [paths (reduce (fn [index [a b]] 
(merge-with into index {a [b] b [a]}))
{} (map seq walls)) 
start-loc (rand-nth (keys paths))] 
(loop [walls walls
unvisited (disj (set (keys paths)) start-loc)] 
(if-let [loc (when-let [s (seq unvisited)] (rand-nth s))] 
(let [walk (iterate (comp rand-nth paths) loc) 
steps (zipmap (take-while unvisited walk) (next walk))] 
(recur (reduce disj walls (map set steps)) 
(reduce disj unvisited (keys steps))))
walls))))

(defn grid
[w h]
(set (concat
(for [i (range (dec w)) j (range h)] #{[i j] [(inc i) j]})
(for [i (range w) j (range (dec h))] #{[i j] [i (inc j)]}))))
(defn draw
[w h maze]
(doto (javax.swing.JFrame. "Maze")
(.setContentPane
(doto (proxy [javax.swing.JPanel] []
(paintComponent [^java.awt.Graphics g]
(let [g (doto ^java.awt.Graphics2D (.create g)
(.scale 10 10)
(.translate 1.5 1.5)
(.setStroke (java.awt.BasicStroke. 0.4)))]
(.drawRect g -1 -1 w h)

(doseq [[[xa ya] [xb yb]] (map sort maze)]
(let [[xc yc] (if (= xa xb)
[(dec xa) ya]
[xa (dec ya)])]
(.drawLine g xa ya xc yc))))))
(.setPreferredSize (java.awt.Dimension.
(* 10 (inc w)) (* 10 (inc h))))))
.pack
(.setVisible true)))
(draw 40 40 (maze (grid 40 40)))

====
(defn wmaze
"The original Wilson's algorithm."
[walls]
(let [paths (reduce (fn [index [a b]]
(merge-with into index {a [b] b [a]}))
{} (map seq walls))
start-loc (rand-nth (keys paths))]
(loop [walls walls unvisited (disj (set (keys paths)) start-loc)]
(if-let [loc (when-let [s (seq unvisited)] (rand-nth s))]
(let [walk (iterate (comp rand-nth paths) loc)
steps (zipmap (take-while unvisited walk) (next walk))
walk (take-while identity (iterate steps loc)) 
steps (zipmap walk (next walk))] 
(recur (reduce disj walls (map set steps))
(reduce disj unvisited (keys steps))))
walls))))

Generating Random Spanning Trees More Quickly than the Cover Timeby David Bruce Wilson http:
//citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.8598

(defn hex-grid
[w h]
(let [vertices (set (for [y (range h) x (range (if (odd? y) 1 0) (* 2 w) 2)]
[x y]))
deltas [[2 0] [1 1] [-1 1]]]
(set (for [v vertices d deltas f [+ -]
:let [w (vertices (map f v d))]
:when w] #{v w}))
(defn- hex-outer-walls
[w h]
(let [vertices (set (for [y (range h) x (range (if (odd? y) 1 0) (* 2 w) 2)]
[x y]))
deltas [[2 0] [1 1] [-1 1]]]
(set (for [v vertices d deltas f [+ -]
:let [w (map f v d)]
:when (not (vertices w))] #{v (vec w)}))
(defn hex-draw
[w h maze]
(doto (javax.swing.JFrame. "Maze")
(.setContentPane
(doto (proxy [javax.swing.JPanel] []
(paintComponent [^java.awt.Graphics g]
(let [maze (into maze (hex-outer-walls w h))
g (doto ^java.awt.Graphics2D (.create g)
(.scale 10 10)
(.translate 1.5 1.5)
(.setStroke (java.awt.BasicStroke. 0.4
java.awt.BasicStroke/CAP_ROUND
java.awt.BasicStroke/JOIN_MITER)))
draw-line (fn [[[xa ya] [xb yb]]]
(.draw g
(java.awt.geom.Line2D$Double.
xa (* 2 ya) xb (* 2 yb))))]
(doseq [[[xa ya] [xb yb]] (map sort maze)]
(draw-line
(cond
(= ya yb) [[(inc xa) (+ ya 0.4)] [(inc xa) (- ya 0.4)]]
(< ya yb) [[(inc xa) (+ ya 0.4)] [xa (+ ya 0.6)]]
:else [[(inc xa) (- ya 0.4)] [xa (- ya 0.6)]]))))))
(.setPreferredSize (java.awt.Dimension.
(* 20 (inc w)) (* 20 (+ 0.5 h))))))
.pack
(.setVisible true)))
(hex-draw 40 40 (maze (hex-grid 40 40)))

=======
clojure.zip

(require '[clojure.zip :as z])
(def v [[1 2 [3 4]] [5 6]])
;= #'user/v
(-> v z/vector-zip z/node)
;= [[1 2 [3 4]] [5 6]]
(-> v z/vector-zip z/down z/node)
;= [1 2 [3 4]]
(-> v z/vector-zip z/down z/right z/node)
;= [5 6]

https://en.wikipedia.org/wiki/Ariadne

(-> v z/vector-zip z/down z/right (z/replace 56) z/node)
;= 56
(-> v z/vector-zip z/down z/right (z/replace 56) z/root) 
;= [[1 2 [3 4]] 56]
(-> v z/vector-zip z/down z/right z/remove z/node) 
;= 4
(-> v z/vector-zip z/down z/right z/remove z/root)
;= [[1 2 [3 4]]]
(-> v z/vector-zip z/down z/down z/right (z/edit * 42) z/root) 
;= [[1 84 [3 4]] [5 6]]

======
自定义zipper。

(defn html-zip [root]
(z/zipper
vector?
(fn [[tagname & xs]]
(if (map? (first xs)) (next xs) xs))
(fn [[tagname & xs] children]
(into (if (map? (first xs)) [tagname (first xs)] [tagname])
children))
root))

(defn wrap
"Wraps the current node in the specified tag and attributes."
([loc tag]
(z/edit loc #(vector tag %)))
([loc tag attrs]
(z/edit loc #(vector tag attrs %))))
(def h [:body [:h1 "Clojure"]
[:p "What a wonderful language!"]])
;= #'user/h
(-> h html-zip z/down z/right z/down (wrap :b) z/root)
;= [:body [:h1 "Clojure"] [:p [:b "What a wonderful language!"]]]

======
(def labyrinth (maze (grid 10 10)))

(def labyrinth (let [g (grid 10 10)] (reduce disj g (maze g))))

(def theseus (rand-nth (distinct (apply concat labyrinth))))

(def minotaur (rand-nth (distinct (apply concat labyrinth))))

(defn ariadne-zip
[labyrinth loc]
(let [paths (reduce (fn [index [a b]]
(merge-with into index {a [b] b [a]}))
{} (map seq labyrinth))
children (fn [[from to]]
(seq (for [loc (paths to) 
:when (not= loc from)]
[to loc])))]
(z/zipper (constantly true) 
children
nil 
[nil loc]))) 

(->> theseus
(ariadne-zip labyrinth)
(iterate z/next)
(filter #(= minotaur (second (z/node %))))
first z/path
(map second))
([3 9] [4 9] [4 8] [4 7] [4 6] [5 7] [5 6] [5 5] [5 4]
[5 8] [6 8] [6 7] [6 6] [6 5] [7 6] [8 6] [9 6] [9 5]
[9 4] [9 3] [9 2] [9 1] [9 0] [8 2] [8 1] [8 0] [7 0]
[6 0] [7 1] [7 2] [6 2] [6 1] [5 1] [4 1] [4 0] [5 0]
[3 0] [4 2] [5 2] [3 2] [3 3] [4 3] [4 4] [4 5] [3 5])

(defn draw
[w h maze path]
(doto (javax.swing.JFrame. "Maze")
(.setContentPane
(doto (proxy [javax.swing.JPanel] []
(paintComponent [^java.awt.Graphics g]
(let [g (doto ^java.awt.Graphics2D (.create g)
(.scale 10 10)
(.translate 1.5 1.5)
(.setStroke (java.awt.BasicStroke. 0.4)))]
(.drawRect g -1 -1 w h)
(doseq [[[xa ya] [xb yb]] (map sort maze)]
(let [[xc yc] (if (= xa xb)
[(dec xa) ya]
[xa (dec ya)])]
(.drawLine g xa ya xc yc)))
(.translate g -0.5 -0.5)
(.setColor g java.awt.Color/RED)
(doseq [[[xa ya] [xb yb]] path] 
(.drawLine g xa ya xb yb)))))
(.setPreferredSize (java.awt.Dimension.
(* 10 (inc w)) (* 10 (inc h))))))
.pack
(.setVisible true)))

(let [w 40, h 40
grid (grid w h)
walls (maze grid)
labyrinth (reduce disj grid walls)
places (distinct (apply concat labyrinth))
theseus (rand-nth places)
minotaur (rand-nth places)
path (->> theseus
(ariadne-zip labyrinth)
(iterate z/next)
(filter #(= minotaur (first (z/node %))))
first z/path rest)] 
(draw w h walls path))

