（hxzon读书笔记）《大型多人在线游戏开发》2，MMP体系结构

by hxzon
======
《2，MMP体系结构》

《2.1，为MMP游戏制作仿真框架，第一部分》

=======
《2.2，为MMP游戏制作仿真框架，第二部分》
《2.2.1，把用户和行动者关联起来》
服务端仿真（ServerSimulation），客户端仿真，连接用户（attachUser），断开用户（DetachUser）。

设计者把用户与行动者连接起来后，就可以发送动作请求并且接受仿真事件了。
目标行动者对象（target actor）是接受还是拒绝这个连接请求完全取决于它当前所处的控制状态。
这样的连接机制还有另一个好处，譬如说可以让多个用户与同一个行动者对象连接。客户支持人员，可通过此功能来临时接管玩家的角色，站在和玩家相同的视角。

《2.2.2，动作请求》
客户端仿真类的SendActionRequest方法接受一个动作状态标识（ActionStateId），以及一个代表用户想要执行的动作的参数列表，并把它们传递给服务端仿真层。
服务端把这些请求依次委派给由所连接的行动者对象及“其控制状态组成的”一个职责链，由它来决定到底是处理还是拒绝这个请求。

《2.2.3，动作调度》
服务端仿真类提供了一个tick方法，游戏开发人员可以从仿真层的外部调用这个方法来对所有未执行的动作进行处理。
这个方法负责计算仿真处理可用的时间片，并且把这个时间片通过processTasks方法传送给调度管理器。
因为通常服务端物理层的处理频率必须比仿真层更高，所以tick方法为维护游戏主循环的物理层提供了一个很好的回调方法。

《2.2.4，事件广播和处理》
当行动者试图进行转换时，它会调用控制状态对象（ControlState）的performAction方法，这个方法会返回一个目标动作状态（desiredActionState）。

随后行动者调用这个目标动作状态的canTransition方法来进行预检，如果通过了，就可以调用目标动作状态的transition方法来进行真正的转换操作。
每个动作状态都需要提供其各自的特定实现。

通常这个实现需要把状态转换通知给其它仿真对象，这可以通过使用仿真事件来完成。
活动的仿真对象还维护一个订阅者列表，对其动作感兴趣的其它对象可以进行登记。
仿真对象会调用这些订阅者的receiveEvent方法来通知他们，并由消息的接收者决定是立即还是消极处理。
在前一种情况下，消息会在接收后立刻得到处理；
后一种情况下，消息在接收者的performAction方法下一次被tick调用时进行处理。

《2.2.5，服务端事件处理》
当事件订阅者接收到一个事件时，它会把这个事件传递给这个类型的事件所对应的事件处理程序。
这个事件处理程序会负责进行所有的服务端处理。
另外，它还需要检查这个行动者对象是否有一个相连接的用户。
如果有的话，必须从服务端仿真中把事件发送给客户端仿真。

《2.2.6，客户端事件处理》
一旦客户端接收到事件消息，就会把事件的源行动者标识（sourceId）从事件对象中取出，并把它传递给客户端仿真的行动者管理器（actorManager），以查找相应的行动代理（ActorProxy）对象。
这个代理对象是服务端对应的行动者对象在客户端的代表。
把消息传递给行动代理对象。

《2.2.7，客户端代理》
当客户端代理对象接收到一个事件时，它处理该事件的方式与之前服务端处理该事件的方式相似。
行动代理对象为事件类型确定合适的处理程序，并把事件传递给它。
它是一个负责进行客户端处理的代理事件处理对象（ProxyEventHandler）。
为了复制服务端相应对象的状态，通常这些处理需要把行动代理对象转换到相应的代理行动状态（ProxyActionState）。

《2.2.8，仿真与表示分离》
通常，状态转换需要在客户端有一个可视化的表示。
仿真框架提供一个钩子，以通知任何对状态变化或其他相关事件感兴趣的“展示管理器（presentation manager）”。
=======
《2.3，为游戏脚本创建一个“安全沙盘”》
《2.4，大型多人游戏中的单元测试》
《2.5，使用Twisted框架进行MMP服务整合》
《2.6，Beyond 2：构建虚拟世界的开源平台》
《2.7，使用并行状态机来创建可信的角色》
《2.8，在MMP服务中使用观察者/可观察者设计模式》

（第2章结束。）